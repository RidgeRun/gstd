/* gst-client.c generated by valac, the Vala compiler
 * generated from gst-client.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <dbus/dbus-glib-lowlevel.h>
#include <dbus/dbus-glib.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gi18n-lib.h>
#include <stdio.h>
#include <float.h>
#include <math.h>
#include <readline/history.h>
#include <readline/readline.h>


#define TYPE_GSTD_CLI (gstd_cli_get_type ())
#define GSTD_CLI(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GSTD_CLI, GstdCli))
#define GSTD_CLI_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GSTD_CLI, GstdCliClass))
#define IS_GSTD_CLI(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GSTD_CLI))
#define IS_GSTD_CLI_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GSTD_CLI))
#define GSTD_CLI_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GSTD_CLI, GstdCliClass))

typedef struct _GstdCli GstdCli;
typedef struct _GstdCliClass GstdCliClass;
typedef struct _GstdCliPrivate GstdCliPrivate;
#define _dbus_g_connection_unref0(var) ((var == NULL) ? NULL : (var = (dbus_g_connection_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_option_context_free0(var) ((var == NULL) ? NULL : (var = (g_option_context_free (var), NULL)))

struct _GstdCli {
	GObject parent_instance;
	GstdCliPrivate * priv;
};

struct _GstdCliClass {
	GObjectClass parent_class;
};

struct _GstdCliPrivate {
	DBusGConnection* conn;
	DBusGProxy* factory;
	char* active_pipe;
	gboolean cli_enable;
	DBusGProxy* pipeline;
	char** cmds;
	gint cmds_length1;
	gint cmds_length2;
};


static char* gstd_cli_obj_path;
static char* gstd_cli_obj_path = NULL;
static gboolean gstd_cli__signals;
static gboolean gstd_cli__signals = FALSE;
static gboolean gstd_cli__debug;
static gboolean gstd_cli__debug = FALSE;
static char** gstd_cli__remaining_args;
static char** gstd_cli__remaining_args = NULL;
static gpointer gstd_cli_parent_class = NULL;

GType gstd_cli_get_type (void);
#define GSTD_CLI_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_GSTD_CLI, GstdCliPrivate))
enum  {
	GSTD_CLI_DUMMY_PROPERTY
};
GstdCli* gstd_cli_new (GError** error);
GstdCli* gstd_cli_construct (GType object_type, GError** error);
void gstd_cli_Error_cb (GstdCli* self);
void gstd_cli_Eos_cb (GstdCli* self);
void gstd_cli_StateChanged_cb (GstdCli* self);
static char* _dynamic_Create0 (DBusGProxy* self, const char* param1, gboolean param2, GError** error);
gboolean gstd_cli_create_proxypipe (GstdCli* self, const char* object_path);
static gboolean gstd_cli_pipeline_create (GstdCli* self, const char* description);
static gboolean _dynamic_Destroy1 (DBusGProxy* self, const char* param1, GError** error);
static gboolean gstd_cli_pipeline_destroy (GstdCli* self, const char* objpath);
static gboolean _dynamic_PipelinePlay2 (DBusGProxy* self, GError** error);
static gboolean _dynamic_PipelineAsyncPlay3 (DBusGProxy* self, GError** error);
static gboolean gstd_cli_pipeline_play (GstdCli* self, DBusGProxy* pipeline, gboolean sync);
static gboolean _dynamic_PipelinePause4 (DBusGProxy* self, GError** error);
static gboolean _dynamic_PipelineAsyncPause5 (DBusGProxy* self, GError** error);
static gboolean gstd_cli_pipeline_pause (GstdCli* self, DBusGProxy* pipeline, gboolean sync);
static gboolean _dynamic_PipelineNull6 (DBusGProxy* self, GError** error);
static gboolean _dynamic_PipelineAsyncNull7 (DBusGProxy* self, GError** error);
static gboolean gstd_cli_pipeline_null (GstdCli* self, DBusGProxy* pipeline, gboolean sync);
static gboolean _dynamic_Ping8 (DBusGProxy* self, GError** error);
static gboolean gstd_cli_gstd_ping (GstdCli* self);
static gboolean _dynamic_ElementGetPropertyBoolean9 (DBusGProxy* self, const char* param1, const char* param2, GError** error);
static gint _dynamic_ElementGetPropertyInt10 (DBusGProxy* self, const char* param1, const char* param2, GError** error);
static glong _dynamic_ElementGetPropertyLong11 (DBusGProxy* self, const char* param1, const char* param2, GError** error);
static char* _dynamic_ElementGetPropertyString12 (DBusGProxy* self, const char* param1, const char* param2, GError** error);
static gboolean gstd_cli_pipeline_get_property (GstdCli* self, DBusGProxy* pipeline, char** args, int args_length1);
static gboolean _dynamic_ElementSetPropertyBoolean13 (DBusGProxy* self, const char* param1, const char* param2, gboolean param3, GError** error);
static gboolean _dynamic_ElementSetPropertyInt14 (DBusGProxy* self, const char* param1, const char* param2, gint param3, GError** error);
static gboolean _dynamic_ElementSetPropertyLong15 (DBusGProxy* self, const char* param1, const char* param2, glong param3, GError** error);
static gboolean _dynamic_ElementSetPropertyString16 (DBusGProxy* self, const char* param1, const char* param2, const char* param3, GError** error);
static gboolean gstd_cli_pipeline_set_property (GstdCli* self, DBusGProxy* pipeline, char** args, int args_length1);
static gint _dynamic_PipelineGetDuration17 (DBusGProxy* self, GError** error);
static gboolean gstd_cli_pipeline_get_duration (GstdCli* self, DBusGProxy* pipeline);
static gint _dynamic_PipelineGetPosition18 (DBusGProxy* self, GError** error);
static gboolean gstd_cli_pipeline_get_position (GstdCli* self, DBusGProxy* pipeline);
static char* _dynamic_PipelineGetState19 (DBusGProxy* self, GError** error);
static gboolean gstd_cli_pipeline_get_state (GstdCli* self, DBusGProxy* pipeline);
static gboolean _dynamic_PipelineSeek20 (DBusGProxy* self, gint param1, GError** error);
static gboolean gstd_cli_pipeline_seek (GstdCli* self, DBusGProxy* pipeline, char** args, int args_length1);
static gboolean _dynamic_PipelineSkip21 (DBusGProxy* self, gint param1, GError** error);
static gboolean gstd_cli_pipeline_skip (GstdCli* self, DBusGProxy* pipeline, char** args, int args_length1);
static gboolean _dynamic_PipelineSpeed22 (DBusGProxy* self, double param1, GError** error);
static gboolean gstd_cli_pipeline_speed (GstdCli* self, DBusGProxy* pipeline, char** args, int args_length1);
static gboolean gstd_cli_set_active (GstdCli* self, const char* path);
static gboolean gstd_cli_get_active (GstdCli* self);
static char* _dynamic_List23 (DBusGProxy* self, GError** error);
static gboolean gstd_cli_pipeline_list (GstdCli* self);
static gboolean _dynamic_PipelineIsInitialized24 (DBusGProxy* self, GError** error);
void gstd_cli_parse_options (GstdCli* self, char** args, int args_length1);
static void _gstd_cli_Error_cb_dynamic_Error0_ (DBusGProxy* _sender, gpointer self);
void _dynamic_Error1_connect (gpointer obj, const char * signal_name, GCallback handler, gpointer data);
static void _gstd_cli_Eos_cb_dynamic_Eos2_ (DBusGProxy* _sender, gpointer self);
void _dynamic_Eos3_connect (gpointer obj, const char * signal_name, GCallback handler, gpointer data);
static void _gstd_cli_StateChanged_cb_dynamic_StateChanged4_ (DBusGProxy* _sender, gpointer self);
void _dynamic_StateChanged5_connect (gpointer obj, const char * signal_name, GCallback handler, gpointer data);
gboolean gstd_cli_parse_cmd (GstdCli* self, char** args, int args_length1, GError** error);
gboolean gstd_cli_cli (GstdCli* self, GError** error);
gboolean gstd_cli_parse (GstdCli* self, char** args, int args_length1, GError** error);
static gint gstd_cli_main (char** args, int args_length1);
static void gstd_cli_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);
static int _vala_strcmp0 (const char * str1, const char * str2);

static const GOptionEntry GSTD_CLI_options[] = {{"path", 'p', 0, G_OPTION_ARG_STRING, &gstd_cli_obj_path, "Pipeline path or path_id, for which command will be apply." "Usage:-p <path_id>", NULL}, {"enable_signals", 's', 0, G_OPTION_ARG_INT, &gstd_cli__signals, "Flag to enable the signals reception.Usage:-s <1>", NULL}, {"debug", 'd', 0, G_OPTION_ARG_INT, &gstd_cli__debug, "Flag to enable debug information on a pipeline,useful just for 'create'" " command.Usage:-d <1>", NULL}, {"", '\0', 0, G_OPTION_ARG_FILENAME_ARRAY, &gstd_cli__remaining_args, NULL, N_ ("[COMMANDS...]")}, {NULL}};


GstdCli* gstd_cli_construct (GType object_type, GError** error) {
	GError * _inner_error_;
	GstdCli * self;
	DBusGConnection* _tmp0_;
	DBusGConnection* _tmp1_;
	DBusGProxy* _tmp2_;
	_inner_error_ = NULL;
	self = (GstdCli*) g_object_new (object_type, NULL);
	_tmp0_ = dbus_g_bus_get (DBUS_BUS_SYSTEM, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		return NULL;
	}
	self->priv->conn = (_tmp1_ = _tmp0_, _dbus_g_connection_unref0 (self->priv->conn), _tmp1_);
	self->priv->factory = (_tmp2_ = dbus_g_proxy_new_for_name (self->priv->conn, "com.ridgerun.gstreamer.gstd", "/com/ridgerun/gstreamer/gstd/factory", "com.ridgerun.gstreamer.gstd.FactoryInterface"), _g_object_unref0 (self->priv->factory), _tmp2_);
	return self;
}


GstdCli* gstd_cli_new (GError** error) {
	return gstd_cli_construct (TYPE_GSTD_CLI, error);
}


void gstd_cli_Error_cb (GstdCli* self) {
	g_return_if_fail (self != NULL);
	fprintf (stdout, "Error signal received\n");
}


void gstd_cli_Eos_cb (GstdCli* self) {
	g_return_if_fail (self != NULL);
	fprintf (stdout, "End of Stream signal received\n");
}


void gstd_cli_StateChanged_cb (GstdCli* self) {
	g_return_if_fail (self != NULL);
	fprintf (stdout, "StateChanged signal received\n");
}


static char* _dynamic_Create0 (DBusGProxy* self, const char* param1, gboolean param2, GError** error) {
	char* result;
	dbus_g_proxy_call (self, "Create", error, G_TYPE_STRING, param1, G_TYPE_BOOLEAN, param2, G_TYPE_INVALID, G_TYPE_STRING, &result, G_TYPE_INVALID);
	if (*error) {
		return NULL;
	}
	return result;
}


static gboolean gstd_cli_pipeline_create (GstdCli* self, const char* description) {
	gboolean result;
	GError * _inner_error_;
	g_return_val_if_fail (self != NULL, FALSE);
	_inner_error_ = NULL;
	if (description == NULL) {
		fprintf (stderr, "Error:\nDescription between quotes(\"\") needed\n");
		result = FALSE;
		return result;
	}
	{
		char* new_objpath;
		new_objpath = _dynamic_Create0 (self->priv->factory, description, gstd_cli__debug, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch0_g_error;
			goto __finally0;
		}
		if (_vala_strcmp0 (new_objpath, "") == 0) {
			fprintf (stderr, "Error:\nFailed to create pipeline\n");
			result = FALSE;
			_g_free0 (new_objpath);
			return result;
		}
		if (self->priv->cli_enable) {
			char* _tmp0_;
			self->priv->active_pipe = (_tmp0_ = g_strdup (new_objpath), _g_free0 (self->priv->active_pipe), _tmp0_);
			gstd_cli_create_proxypipe (self, self->priv->active_pipe);
		}
		fprintf (stdout, "Pipeline path created: %s\n", new_objpath);
		fprintf (stdout, "Ok.\n");
		result = TRUE;
		_g_free0 (new_objpath);
		return result;
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			fprintf (stderr, "Error:\nCreating pipeline:%s\n", e->message);
			result = FALSE;
			_g_error_free0 (e);
			return result;
		}
	}
	__finally0:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
}


static gboolean _dynamic_Destroy1 (DBusGProxy* self, const char* param1, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "Destroy", error, G_TYPE_STRING, param1, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


static gboolean gstd_cli_pipeline_destroy (GstdCli* self, const char* objpath) {
	gboolean result;
	GError * _inner_error_;
	gboolean ret;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (objpath != NULL, FALSE);
	_inner_error_ = NULL;
	ret = _dynamic_Destroy1 (self->priv->factory, objpath, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	if (!ret) {
		fprintf (stderr, "Error:\nFailed to put the pipeline to null\n");
		result = FALSE;
		return result;
	}
	fprintf (stdout, "Pipeline with path:%s, destroyed\n", objpath);
	fprintf (stdout, "Ok.\n");
	result = TRUE;
	return result;
}


static gboolean _dynamic_PipelinePlay2 (DBusGProxy* self, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "PipelinePlay", error, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


static gboolean _dynamic_PipelineAsyncPlay3 (DBusGProxy* self, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "PipelineAsyncPlay", error, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


static gboolean gstd_cli_pipeline_play (GstdCli* self, DBusGProxy* pipeline, gboolean sync) {
	gboolean result;
	GError * _inner_error_;
	gboolean ret = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pipeline != NULL, FALSE);
	_inner_error_ = NULL;
	{
		if (sync) {
			gboolean _tmp0_;
			_tmp0_ = _dynamic_PipelinePlay2 (pipeline, &_inner_error_);
			if (_inner_error_ != NULL) {
				goto __catch1_g_error;
				goto __finally1;
			}
			ret = _tmp0_;
		} else {
			gboolean _tmp1_;
			_tmp1_ = _dynamic_PipelineAsyncPlay3 (pipeline, &_inner_error_);
			if (_inner_error_ != NULL) {
				goto __catch1_g_error;
				goto __finally1;
			}
			ret = _tmp1_;
		}
		if (!ret) {
			fprintf (stdout, "Error:\nFailed to put the pipeline to play\n");
			result = FALSE;
			return result;
		}
		fprintf (stdout, "Ok.\n");
		result = ret;
		return result;
	}
	goto __finally1;
	__catch1_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			fprintf (stdout, "Error:\n%s\n", e->message);
			result = FALSE;
			_g_error_free0 (e);
			return result;
		}
	}
	__finally1:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
}


static gboolean _dynamic_PipelinePause4 (DBusGProxy* self, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "PipelinePause", error, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


static gboolean _dynamic_PipelineAsyncPause5 (DBusGProxy* self, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "PipelineAsyncPause", error, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


static gboolean gstd_cli_pipeline_pause (GstdCli* self, DBusGProxy* pipeline, gboolean sync) {
	gboolean result;
	GError * _inner_error_;
	gboolean ret = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pipeline != NULL, FALSE);
	_inner_error_ = NULL;
	{
		if (sync) {
			gboolean _tmp0_;
			_tmp0_ = _dynamic_PipelinePause4 (pipeline, &_inner_error_);
			if (_inner_error_ != NULL) {
				goto __catch2_g_error;
				goto __finally2;
			}
			ret = _tmp0_;
		} else {
			gboolean _tmp1_;
			_tmp1_ = _dynamic_PipelineAsyncPause5 (pipeline, &_inner_error_);
			if (_inner_error_ != NULL) {
				goto __catch2_g_error;
				goto __finally2;
			}
			ret = _tmp1_;
		}
		if (!ret) {
			fprintf (stdout, "Error:\nFailed to put the pipeline to pause\n");
			result = FALSE;
			return result;
		}
		fprintf (stdout, "Ok.\n");
		result = ret;
		return result;
	}
	goto __finally2;
	__catch2_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			fprintf (stdout, "Error:\n%s\n", e->message);
			result = FALSE;
			_g_error_free0 (e);
			return result;
		}
	}
	__finally2:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
}


static gboolean _dynamic_PipelineNull6 (DBusGProxy* self, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "PipelineNull", error, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


static gboolean _dynamic_PipelineAsyncNull7 (DBusGProxy* self, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "PipelineAsyncNull", error, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


static gboolean gstd_cli_pipeline_null (GstdCli* self, DBusGProxy* pipeline, gboolean sync) {
	gboolean result;
	GError * _inner_error_;
	gboolean ret = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pipeline != NULL, FALSE);
	_inner_error_ = NULL;
	{
		if (sync) {
			gboolean _tmp0_;
			_tmp0_ = _dynamic_PipelineNull6 (pipeline, &_inner_error_);
			if (_inner_error_ != NULL) {
				goto __catch3_g_error;
				goto __finally3;
			}
			ret = _tmp0_;
		} else {
			gboolean _tmp1_;
			_tmp1_ = _dynamic_PipelineAsyncNull7 (pipeline, &_inner_error_);
			if (_inner_error_ != NULL) {
				goto __catch3_g_error;
				goto __finally3;
			}
			ret = _tmp1_;
		}
		if (!ret) {
			fprintf (stderr, "Error:\nFailed to put the pipeline to null\n");
			result = FALSE;
			return result;
		}
		fprintf (stdout, "Ok.\n");
		result = ret;
		return result;
	}
	goto __finally3;
	__catch3_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			fprintf (stdout, "Error:\n%s\n", e->message);
			result = FALSE;
			_g_error_free0 (e);
			return result;
		}
	}
	__finally3:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
}


static gboolean _dynamic_Ping8 (DBusGProxy* self, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "Ping", error, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


static gboolean gstd_cli_gstd_ping (GstdCli* self) {
	gboolean result;
	GError * _inner_error_;
	gboolean ret;
	g_return_val_if_fail (self != NULL, FALSE);
	_inner_error_ = NULL;
	ret = FALSE;
	{
		gboolean _tmp0_;
		_tmp0_ = _dynamic_Ping8 (self->priv->factory, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch4_g_error;
			goto __finally4;
		}
		ret = _tmp0_;
	}
	goto __finally4;
	__catch4_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			fprintf (stderr, "Error:\nFailed to reach gstd!\n");
			result = ret;
			_g_error_free0 (e);
			return result;
		}
	}
	__finally4:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	fprintf (stdout, "pong\n");
	result = ret;
	return result;
}


static gboolean _dynamic_ElementGetPropertyBoolean9 (DBusGProxy* self, const char* param1, const char* param2, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "ElementGetPropertyBoolean", error, G_TYPE_STRING, param1, G_TYPE_STRING, param2, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


static gint _dynamic_ElementGetPropertyInt10 (DBusGProxy* self, const char* param1, const char* param2, GError** error) {
	gint result;
	dbus_g_proxy_call (self, "ElementGetPropertyInt", error, G_TYPE_STRING, param1, G_TYPE_STRING, param2, G_TYPE_INVALID, G_TYPE_INT, &result, G_TYPE_INVALID);
	if (*error) {
		return 0;
	}
	return result;
}


static glong _dynamic_ElementGetPropertyLong11 (DBusGProxy* self, const char* param1, const char* param2, GError** error) {
	glong result;
	dbus_g_proxy_call (self, "ElementGetPropertyLong", error, G_TYPE_STRING, param1, G_TYPE_STRING, param2, G_TYPE_INVALID, dbus_g_type_get_struct ("GValueArray", G_TYPE_INVALID), &result, G_TYPE_INVALID);
	if (*error) {
		return 0L;
	}
	return result;
}


static char* _dynamic_ElementGetPropertyString12 (DBusGProxy* self, const char* param1, const char* param2, GError** error) {
	char* result;
	dbus_g_proxy_call (self, "ElementGetPropertyString", error, G_TYPE_STRING, param1, G_TYPE_STRING, param2, G_TYPE_INVALID, G_TYPE_STRING, &result, G_TYPE_INVALID);
	if (*error) {
		return NULL;
	}
	return result;
}


static gboolean gstd_cli_pipeline_get_property (GstdCli* self, DBusGProxy* pipeline, char** args, int args_length1) {
	gboolean result;
	GError * _inner_error_;
	gboolean ret;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	char* element;
	char* property;
	GQuark _tmp4_;
	char* _tmp3_;
	static GQuark _tmp4__label0 = 0;
	static GQuark _tmp4__label1 = 0;
	static GQuark _tmp4__label2 = 0;
	static GQuark _tmp4__label3 = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pipeline != NULL, FALSE);
	_inner_error_ = NULL;
	ret = TRUE;
	if (args[1] == NULL) {
		_tmp1_ = TRUE;
	} else {
		_tmp1_ = args[2] == NULL;
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = args[3] == NULL;
	}
	if (_tmp0_) {
		fprintf (stdout, "Error:\nMissing argument.Execute:'help get'\n");
		result = FALSE;
		return result;
	}
	element = g_strdup (args[1]);
	property = g_strdup (args[2]);
	_tmp3_ = g_utf8_strdown (args[3], -1);
	_tmp4_ = (NULL == _tmp3_) ? 0 : g_quark_from_string (_tmp3_);
	g_free (_tmp3_);
	if (_tmp4_ == ((0 != _tmp4__label0) ? _tmp4__label0 : (_tmp4__label0 = g_quark_from_static_string ("boolean"))))
	do {
		gboolean boolean_v;
		const char* _tmp2_;
		boolean_v = _dynamic_ElementGetPropertyBoolean9 (pipeline, element, property, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_free0 (element);
			_g_free0 (property);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		_tmp2_ = NULL;
		if (boolean_v) {
			_tmp2_ = "true";
		} else {
			_tmp2_ = "false";
		}
		fprintf (stdout, "The '%s' value on element '%s' is: %s\n", property, element, _tmp2_);
		break;
	} while (0); else if (_tmp4_ == ((0 != _tmp4__label1) ? _tmp4__label1 : (_tmp4__label1 = g_quark_from_static_string ("integer"))))
	do {
		gint integer_v;
		integer_v = _dynamic_ElementGetPropertyInt10 (pipeline, element, property, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_free0 (element);
			_g_free0 (property);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		fprintf (stdout, "The '%s' value on element '%s' is: %d\n", property, element, integer_v);
		if (integer_v == (-1)) {
			ret = FALSE;
		}
		break;
	} while (0); else if (_tmp4_ == ((0 != _tmp4__label2) ? _tmp4__label2 : (_tmp4__label2 = g_quark_from_static_string ("long"))))
	do {
		glong long_v;
		long_v = _dynamic_ElementGetPropertyLong11 (pipeline, element, property, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_free0 (element);
			_g_free0 (property);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		fprintf (stdout, "The '%s' value on element '%s' is: %ld\n", property, element, long_v);
		if (long_v == (-1)) {
			ret = FALSE;
		}
		break;
	} while (0); else if (_tmp4_ == ((0 != _tmp4__label3) ? _tmp4__label3 : (_tmp4__label3 = g_quark_from_static_string ("string"))))
	do {
		char* string_v;
		string_v = _dynamic_ElementGetPropertyString12 (pipeline, element, property, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_free0 (element);
			_g_free0 (property);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		fprintf (stdout, "The '%s' value on element '%s' is: %s\n", property, element, string_v);
		if (string_v == NULL) {
			ret = FALSE;
		}
		_g_free0 (string_v);
		break;
	} while (0); else
	do {
		fprintf (stderr, "Error:\nDatatype not supported: %s\n", args[3]);
		result = FALSE;
		_g_free0 (element);
		_g_free0 (property);
		return result;
	} while (0);
	if (!ret) {
		fprintf (stdout, "Error:\nFailed to get property:%s\n", property);
		result = FALSE;
		_g_free0 (element);
		_g_free0 (property);
		return result;
	}
	fprintf (stdout, "Ok.\n");
	result = ret;
	_g_free0 (element);
	_g_free0 (property);
	return result;
}


static gboolean string_to_bool (const char* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	if (_vala_strcmp0 (self, "true") == 0) {
		result = TRUE;
		return result;
	} else {
		result = FALSE;
		return result;
	}
}


static gboolean _dynamic_ElementSetPropertyBoolean13 (DBusGProxy* self, const char* param1, const char* param2, gboolean param3, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "ElementSetPropertyBoolean", error, G_TYPE_STRING, param1, G_TYPE_STRING, param2, G_TYPE_BOOLEAN, param3, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


static gboolean _dynamic_ElementSetPropertyInt14 (DBusGProxy* self, const char* param1, const char* param2, gint param3, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "ElementSetPropertyInt", error, G_TYPE_STRING, param1, G_TYPE_STRING, param2, G_TYPE_INT, param3, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


static gboolean _dynamic_ElementSetPropertyLong15 (DBusGProxy* self, const char* param1, const char* param2, glong param3, GError** error) {
	GValueArray* dbus_param3;
	gboolean result;
	dbus_param3 = g_value_array_new (0);
	dbus_g_proxy_call (self, "ElementSetPropertyLong", error, G_TYPE_STRING, param1, G_TYPE_STRING, param2, dbus_g_type_get_struct ("GValueArray", G_TYPE_INVALID), dbus_param3, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


static gboolean _dynamic_ElementSetPropertyString16 (DBusGProxy* self, const char* param1, const char* param2, const char* param3, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "ElementSetPropertyString", error, G_TYPE_STRING, param1, G_TYPE_STRING, param2, G_TYPE_STRING, param3, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


static gboolean gstd_cli_pipeline_set_property (GstdCli* self, DBusGProxy* pipeline, char** args, int args_length1) {
	gboolean result;
	GError * _inner_error_;
	gboolean ret = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	char* element;
	char* property;
	GQuark _tmp11_;
	char* _tmp10_;
	static GQuark _tmp11__label0 = 0;
	static GQuark _tmp11__label1 = 0;
	static GQuark _tmp11__label2 = 0;
	static GQuark _tmp11__label3 = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pipeline != NULL, FALSE);
	_inner_error_ = NULL;
	if (args[1] == NULL) {
		_tmp2_ = TRUE;
	} else {
		_tmp2_ = args[2] == NULL;
	}
	if (_tmp2_) {
		_tmp1_ = TRUE;
	} else {
		_tmp1_ = args[3] == NULL;
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = args[4] == NULL;
	}
	if (_tmp0_) {
		fprintf (stdout, "Error:\nMissing argument.Execute:'help set'\n");
		result = FALSE;
		return result;
	}
	element = g_strdup (args[1]);
	property = g_strdup (args[2]);
	_tmp10_ = g_utf8_strdown (args[3], -1);
	_tmp11_ = (NULL == _tmp10_) ? 0 : g_quark_from_string (_tmp10_);
	g_free (_tmp10_);
	if (_tmp11_ == ((0 != _tmp11__label0) ? _tmp11__label0 : (_tmp11__label0 = g_quark_from_static_string ("boolean"))))
	do {
		char* _tmp3_;
		gboolean _tmp4_;
		gboolean boolean_v;
		const char* _tmp5_;
		gboolean _tmp6_;
		boolean_v = (_tmp4_ = string_to_bool (_tmp3_ = g_utf8_strdown (args[4], -1)), _g_free0 (_tmp3_), _tmp4_);
		_tmp5_ = NULL;
		if (boolean_v) {
			_tmp5_ = "true";
		} else {
			_tmp5_ = "false";
		}
		fprintf (stdout, "Trying to set '%s' on element '%s' to the value:%s\n", property, element, _tmp5_);
		_tmp6_ = _dynamic_ElementSetPropertyBoolean13 (pipeline, element, property, boolean_v, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_free0 (element);
			_g_free0 (property);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		ret = _tmp6_;
		break;
	} while (0); else if (_tmp11_ == ((0 != _tmp11__label1) ? _tmp11__label1 : (_tmp11__label1 = g_quark_from_static_string ("integer"))))
	do {
		gint integer_v;
		gboolean _tmp7_;
		integer_v = atoi (args[4]);
		fprintf (stdout, "Trying to set '%s' on element '%s' to the value:%d\n", property, element, integer_v);
		_tmp7_ = _dynamic_ElementSetPropertyInt14 (pipeline, element, property, integer_v, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_free0 (element);
			_g_free0 (property);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		ret = _tmp7_;
		break;
	} while (0); else if (_tmp11_ == ((0 != _tmp11__label2) ? _tmp11__label2 : (_tmp11__label2 = g_quark_from_static_string ("long"))))
	do {
		glong long_v;
		gboolean _tmp8_;
		long_v = atol (args[4]);
		fprintf (stdout, "Trying to set '%s' on element '%s' to the value:%ld\n", property, element, long_v);
		_tmp8_ = _dynamic_ElementSetPropertyLong15 (pipeline, element, property, long_v, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_free0 (element);
			_g_free0 (property);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		ret = _tmp8_;
		break;
	} while (0); else if (_tmp11_ == ((0 != _tmp11__label3) ? _tmp11__label3 : (_tmp11__label3 = g_quark_from_static_string ("string"))))
	do {
		char* string_v;
		gboolean _tmp9_;
		string_v = g_strdup (args[4]);
		fprintf (stdout, "Trying to set '%s' on element '%s' to the value:%s\n", property, element, string_v);
		_tmp9_ = _dynamic_ElementSetPropertyString16 (pipeline, element, property, string_v, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_free0 (string_v);
			_g_free0 (element);
			_g_free0 (property);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		ret = _tmp9_;
		_g_free0 (string_v);
		break;
	} while (0); else
	do {
		fprintf (stderr, "Error:\nDatatype not supported: %s\n", args[3]);
		result = FALSE;
		_g_free0 (element);
		_g_free0 (property);
		return result;
	} while (0);
	if (!ret) {
		fprintf (stderr, "Error:\nFailed to set property:%s\n", property);
		result = FALSE;
		_g_free0 (element);
		_g_free0 (property);
		return result;
	}
	fprintf (stdout, "Ok.\n");
	result = ret;
	_g_free0 (element);
	_g_free0 (property);
	return result;
}


static gint _dynamic_PipelineGetDuration17 (DBusGProxy* self, GError** error) {
	gint result;
	dbus_g_proxy_call (self, "PipelineGetDuration", error, G_TYPE_INVALID, G_TYPE_INT, &result, G_TYPE_INVALID);
	if (*error) {
		return 0;
	}
	return result;
}


static gboolean gstd_cli_pipeline_get_duration (GstdCli* self, DBusGProxy* pipeline) {
	gboolean result;
	GError * _inner_error_;
	gint time;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pipeline != NULL, FALSE);
	_inner_error_ = NULL;
	time = _dynamic_PipelineGetDuration17 (pipeline, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	if (time < 0) {
		fprintf (stderr, "Error:\nFailed to get pipeline duration\n");
		result = FALSE;
		return result;
	}
	fprintf (stdout, "The duration on the pipeline is %u:%02u:%02u.%03u\n", (guint) (time / ((1000 * 60) * 60)), (guint) ((time / (1000 * 60)) % 60), (guint) ((time / 1000) % 60), (guint) (time % 1000));
	fprintf (stdout, "Ok.\n");
	result = TRUE;
	return result;
}


static gint _dynamic_PipelineGetPosition18 (DBusGProxy* self, GError** error) {
	gint result;
	dbus_g_proxy_call (self, "PipelineGetPosition", error, G_TYPE_INVALID, G_TYPE_INT, &result, G_TYPE_INVALID);
	if (*error) {
		return 0;
	}
	return result;
}


static gboolean gstd_cli_pipeline_get_position (GstdCli* self, DBusGProxy* pipeline) {
	gboolean result;
	GError * _inner_error_;
	gint pos;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pipeline != NULL, FALSE);
	_inner_error_ = NULL;
	pos = _dynamic_PipelineGetPosition18 (pipeline, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	if (pos < 0) {
		fprintf (stderr, "Error:\nFailed to get position the pipeline to null\n");
		result = FALSE;
		return result;
	}
	fprintf (stdout, "The position on the pipeline is %u:%02u:%02u.%03u\n", (guint) (pos / ((1000 * 60) * 60)), (guint) ((pos / (1000 * 60)) % 60), (guint) ((pos / 1000) % 60), (guint) (pos % 1000));
	fprintf (stdout, "Ok.\n");
	result = TRUE;
	return result;
}


static char* _dynamic_PipelineGetState19 (DBusGProxy* self, GError** error) {
	char* result;
	dbus_g_proxy_call (self, "PipelineGetState", error, G_TYPE_INVALID, G_TYPE_STRING, &result, G_TYPE_INVALID);
	if (*error) {
		return NULL;
	}
	return result;
}


static gboolean gstd_cli_pipeline_get_state (GstdCli* self, DBusGProxy* pipeline) {
	gboolean result;
	GError * _inner_error_;
	char* state;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pipeline != NULL, FALSE);
	_inner_error_ = NULL;
	state = _dynamic_PipelineGetState19 (pipeline, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	if (state == NULL) {
		fprintf (stderr, "Error:\nFailed to get the pipeline state\n");
		result = FALSE;
		_g_free0 (state);
		return result;
	}
	fprintf (stdout, "The pipeline state is: %s\n", state);
	fprintf (stdout, "Ok.\n");
	result = TRUE;
	_g_free0 (state);
	return result;
}


static gboolean _dynamic_PipelineSeek20 (DBusGProxy* self, gint param1, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "PipelineSeek", error, G_TYPE_INT, param1, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


static gboolean gstd_cli_pipeline_seek (GstdCli* self, DBusGProxy* pipeline, char** args, int args_length1) {
	gboolean result;
	GError * _inner_error_;
	gint pos_ms;
	gboolean ret;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pipeline != NULL, FALSE);
	_inner_error_ = NULL;
	if (args[1] == NULL) {
		fprintf (stdout, "Error:\nMissing argument.Execute:'help seek'\n");
		result = FALSE;
		return result;
	}
	pos_ms = atoi (args[1]);
	ret = _dynamic_PipelineSeek20 (pipeline, pos_ms, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	if (!ret) {
		fprintf (stderr, "Error:\nSeek fail: Media type not seekable\n");
		result = FALSE;
		return result;
	}
	fprintf (stdout, "Ok.\n");
	result = ret;
	return result;
}


static gboolean _dynamic_PipelineSkip21 (DBusGProxy* self, gint param1, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "PipelineSkip", error, G_TYPE_INT, param1, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


static gboolean gstd_cli_pipeline_skip (GstdCli* self, DBusGProxy* pipeline, char** args, int args_length1) {
	gboolean result;
	GError * _inner_error_;
	gint period_ms;
	gboolean ret;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pipeline != NULL, FALSE);
	_inner_error_ = NULL;
	if (args[1] == NULL) {
		fprintf (stdout, "Error:\nMissing argument.Execute:'help skip'\n");
		result = FALSE;
		return result;
	}
	period_ms = atoi (args[1]);
	ret = _dynamic_PipelineSkip21 (pipeline, period_ms, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	if (!ret) {
		fprintf (stderr, "Error:\nSkip fail: Media type not seekable\n");
		result = FALSE;
		return result;
	}
	fprintf (stdout, "Ok.\n");
	result = ret;
	return result;
}


static gboolean _dynamic_PipelineSpeed22 (DBusGProxy* self, double param1, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "PipelineSpeed", error, G_TYPE_DOUBLE, param1, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


static gboolean gstd_cli_pipeline_speed (GstdCli* self, DBusGProxy* pipeline, char** args, int args_length1) {
	gboolean result;
	GError * _inner_error_;
	double rate;
	gboolean ret;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pipeline != NULL, FALSE);
	_inner_error_ = NULL;
	if (args[1] == NULL) {
		fprintf (stdout, "Error:\nMissing argument.Execute:'help speed'\n");
		result = FALSE;
		return result;
	}
	rate = g_ascii_strtod (args[1], NULL);
	ret = _dynamic_PipelineSpeed22 (pipeline, rate, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	if (!ret) {
		fprintf (stderr, "Error:\nSpeed could not be set\n");
		result = FALSE;
		return result;
	}
	fprintf (stdout, "Ok.\n");
	result = ret;
	return result;
}


static gboolean gstd_cli_set_active (GstdCli* self, const char* path) {
	gboolean result;
	char* new_active;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (path != NULL, FALSE);
	new_active = NULL;
	if (self->priv->cli_enable) {
		char* _tmp2_;
		if (g_utf8_get_char (g_utf8_offset_to_pointer (path, 0)) != '/') {
			char* _tmp0_;
			new_active = (_tmp0_ = g_strconcat ("/com/ridgerun/gstreamer/gstd/pipe", path, NULL), _g_free0 (new_active), _tmp0_);
		} else {
			char* _tmp1_;
			new_active = (_tmp1_ = g_strdup (path), _g_free0 (new_active), _tmp1_);
		}
		if (!gstd_cli_create_proxypipe (self, new_active)) {
			gstd_cli_create_proxypipe (self, self->priv->active_pipe);
			fprintf (stderr, "Error:\nInvalid path\n");
			result = FALSE;
			_g_free0 (new_active);
			return result;
		}
		self->priv->active_pipe = (_tmp2_ = g_strdup (new_active), _g_free0 (self->priv->active_pipe), _tmp2_);
		fprintf (stdout, "Ok.\n");
		result = TRUE;
		_g_free0 (new_active);
		return result;
	} else {
		fprintf (stderr, "%s", "Error:\nThis command is exclusive for" " interactive console mode\n");
		result = FALSE;
		_g_free0 (new_active);
		return result;
	}
	_g_free0 (new_active);
}


static gboolean gstd_cli_get_active (GstdCli* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	if (self->priv->cli_enable) {
		if (self->priv->active_pipe != NULL) {
			fprintf (stdout, "The active pipeline path is: %s\n", self->priv->active_pipe);
			fprintf (stdout, "Ok.\n");
			result = TRUE;
			return result;
		} else {
			fprintf (stderr, "Error:\nThere is no active pipeline\n");
			result = FALSE;
			return result;
		}
	} else {
		fprintf (stderr, "%s", "Error:\nCommand used only on the interactive" " console mode\n");
		result = FALSE;
		return result;
	}
}


static char* _dynamic_List23 (DBusGProxy* self, GError** error) {
	char* result;
	dbus_g_proxy_call (self, "List", error, G_TYPE_INVALID, G_TYPE_STRING, &result, G_TYPE_INVALID);
	if (*error) {
		return NULL;
	}
	return result;
}


static gboolean gstd_cli_pipeline_list (GstdCli* self) {
	gboolean result;
	GError * _inner_error_;
	char** _tmp0_;
	gint list_size;
	gint list_length1;
	char** list;
	char* paths;
	gint index;
	char* _tmp3_;
	char* _tmp4_;
	char** _tmp6_;
	char** _tmp5_;
	g_return_val_if_fail (self != NULL, FALSE);
	_inner_error_ = NULL;
	list = (_tmp0_ = g_new0 (char*, 20 + 1), list_length1 = 20, list_size = list_length1, _tmp0_);
	paths = g_strdup ("");
	index = 0;
	{
		gboolean _tmp1_;
		index = 0;
		_tmp1_ = TRUE;
		while (TRUE) {
			char* _tmp2_;
			if (!_tmp1_) {
				index++;
			}
			_tmp1_ = FALSE;
			if (!(index < list_length1)) {
				break;
			}
			list[index] = (_tmp2_ = NULL, _g_free0 (list[index]), _tmp2_);
		}
	}
	_tmp3_ = _dynamic_List23 (self->priv->factory, &_inner_error_);
	if (_inner_error_ != NULL) {
		list = (_vala_array_free (list, list_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (paths);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	paths = (_tmp4_ = _tmp3_, _g_free0 (paths), _tmp4_);
	list = (_tmp6_ = _tmp5_ = g_strsplit (paths, ",", -1), list = (_vala_array_free (list, list_length1, (GDestroyNotify) g_free), NULL), list_length1 = _vala_array_length (_tmp5_), list_size = list_length1, _tmp6_);
	if (list[0] == NULL) {
		fprintf (stderr, "Error:\nThere is no pipelines on factory!\n");
		result = FALSE;
		list = (_vala_array_free (list, list_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (paths);
		return result;
	}
	fprintf (stdout, "The actual pipelines are:\n");
	{
		gboolean _tmp7_;
		index = 0;
		_tmp7_ = TRUE;
		while (TRUE) {
			if (!_tmp7_) {
				index++;
			}
			_tmp7_ = FALSE;
			if (!(index < list_length1)) {
				break;
			}
			fprintf (stdout, "  %i. %s\n", index + 1, list[index]);
		}
	}
	fprintf (stdout, "Ok.\n");
	result = TRUE;
	list = (_vala_array_free (list, list_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (paths);
	return result;
}


static gboolean _dynamic_PipelineIsInitialized24 (DBusGProxy* self, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "PipelineIsInitialized", error, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


gboolean gstd_cli_create_proxypipe (GstdCli* self, const char* object_path) {
	gboolean result;
	GError * _inner_error_;
	DBusGProxy* _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_inner_error_ = NULL;
	if (object_path == NULL) {
		result = FALSE;
		return result;
	}
	self->priv->pipeline = (_tmp0_ = dbus_g_proxy_new_for_name (self->priv->conn, "com.ridgerun.gstreamer.gstd", object_path, "com.ridgerun.gstreamer.gstd.PipelineInterface"), _g_object_unref0 (self->priv->pipeline), _tmp0_);
	{
		gboolean ret;
		ret = _dynamic_PipelineIsInitialized24 (self->priv->pipeline, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch5_g_error;
			goto __finally5;
		}
		if (!ret) {
			result = FALSE;
			return result;
		}
	}
	goto __finally5;
	__catch5_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			result = FALSE;
			_g_error_free0 (e);
			return result;
		}
	}
	__finally5:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = TRUE;
	return result;
}


void gstd_cli_parse_options (GstdCli* self, char** args, int args_length1) {
	GError * _inner_error_;
	char** _tmp0_;
	char* _tmp1_;
	GOptionContext* opt;
	gboolean _tmp4_ = FALSE;
	g_return_if_fail (self != NULL);
	_inner_error_ = NULL;
	gstd_cli__signals = FALSE;
	gstd_cli__debug = FALSE;
	gstd_cli__remaining_args = (_tmp0_ = NULL, gstd_cli__remaining_args = (_vala_array_free (gstd_cli__remaining_args, _vala_array_length (gstd_cli__remaining_args), (GDestroyNotify) g_free), NULL), _tmp0_);
	gstd_cli_obj_path = (_tmp1_ = NULL, _g_free0 (gstd_cli_obj_path), _tmp1_);
	opt = g_option_context_new ("(For Commands HELP: 'gst-client help')");
	g_option_context_set_help_enabled (opt, TRUE);
	g_option_context_add_main_entries (opt, GSTD_CLI_options, NULL);
	{
		gboolean _tmp2_ = FALSE;
		g_option_context_parse (opt, &args_length1, &args, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_OPTION_ERROR) {
				goto __catch6_g_option_error;
			}
			goto __finally6;
		}
		if (gstd_cli_obj_path != NULL) {
			_tmp2_ = g_utf8_get_char (g_utf8_offset_to_pointer (gstd_cli_obj_path, 0)) != '/';
		} else {
			_tmp2_ = FALSE;
		}
		if (_tmp2_) {
			char* _tmp3_;
			gstd_cli_obj_path = (_tmp3_ = g_strconcat ("/com/ridgerun/gstreamer/gstd/pipe", gstd_cli_obj_path, NULL), _g_free0 (gstd_cli_obj_path), _tmp3_);
		}
	}
	goto __finally6;
	__catch6_g_option_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			fprintf (stderr, "OptionError failure: %s\n", e->message);
			_g_error_free0 (e);
		}
	}
	__finally6:
	if (_inner_error_ != NULL) {
		_g_option_context_free0 (opt);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	if (self->priv->cli_enable) {
		_tmp4_ = gstd_cli_obj_path != NULL;
	} else {
		_tmp4_ = FALSE;
	}
	if (_tmp4_) {
		char* _tmp5_;
		self->priv->active_pipe = (_tmp5_ = g_strdup (gstd_cli_obj_path), _g_free0 (self->priv->active_pipe), _tmp5_);
	}
	_g_option_context_free0 (opt);
}


static void _gstd_cli_Error_cb_dynamic_Error0_ (DBusGProxy* _sender, gpointer self) {
	gstd_cli_Error_cb (self);
}


void _dynamic_Error1_connect (gpointer obj, const char * signal_name, GCallback handler, gpointer data) {
	dbus_g_object_register_marshaller (g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, G_TYPE_INVALID);
	dbus_g_proxy_add_signal (obj, "Error", G_TYPE_INVALID);
	dbus_g_proxy_connect_signal (obj, signal_name, handler, data, NULL);
}


static void _gstd_cli_Eos_cb_dynamic_Eos2_ (DBusGProxy* _sender, gpointer self) {
	gstd_cli_Eos_cb (self);
}


void _dynamic_Eos3_connect (gpointer obj, const char * signal_name, GCallback handler, gpointer data) {
	dbus_g_object_register_marshaller (g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, G_TYPE_INVALID);
	dbus_g_proxy_add_signal (obj, "Eos", G_TYPE_INVALID);
	dbus_g_proxy_connect_signal (obj, signal_name, handler, data, NULL);
}


static void _gstd_cli_StateChanged_cb_dynamic_StateChanged4_ (DBusGProxy* _sender, gpointer self) {
	gstd_cli_StateChanged_cb (self);
}


void _dynamic_StateChanged5_connect (gpointer obj, const char * signal_name, GCallback handler, gpointer data) {
	dbus_g_object_register_marshaller (g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, G_TYPE_INVALID);
	dbus_g_proxy_add_signal (obj, "StateChanged", G_TYPE_INVALID);
	dbus_g_proxy_connect_signal (obj, signal_name, handler, data, NULL);
}


gboolean gstd_cli_parse_cmd (GstdCli* self, char** args, int args_length1, GError** error) {
	gboolean result;
	GQuark _tmp24_;
	char* _tmp23_;
	static GQuark _tmp24__label0 = 0;
	static GQuark _tmp24__label1 = 0;
	static GQuark _tmp24__label2 = 0;
	static GQuark _tmp24__label3 = 0;
	static GQuark _tmp24__label4 = 0;
	static GQuark _tmp24__label5 = 0;
	static GQuark _tmp24__label6 = 0;
	static GQuark _tmp24__label7 = 0;
	static GQuark _tmp24__label8 = 0;
	static GQuark _tmp24__label9 = 0;
	static GQuark _tmp24__label10 = 0;
	static GQuark _tmp24__label11 = 0;
	static GQuark _tmp24__label12 = 0;
	static GQuark _tmp24__label13 = 0;
	static GQuark _tmp24__label14 = 0;
	static GQuark _tmp24__label15 = 0;
	static GQuark _tmp24__label16 = 0;
	static GQuark _tmp24__label17 = 0;
	static GQuark _tmp24__label18 = 0;
	static GQuark _tmp24__label19 = 0;
	static GQuark _tmp24__label20 = 0;
	static GQuark _tmp24__label21 = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	if (!gstd_cli_create_proxypipe (self, gstd_cli_obj_path)) {
		gboolean _tmp0_ = FALSE;
		gboolean _tmp1_ = FALSE;
		gboolean _tmp2_ = FALSE;
		gboolean _tmp3_ = FALSE;
		gboolean _tmp4_ = FALSE;
		gboolean _tmp5_ = FALSE;
		gboolean _tmp6_ = FALSE;
		char* _tmp7_;
		gboolean _tmp8_;
		if ((_tmp8_ = _vala_strcmp0 (_tmp7_ = g_utf8_strdown (args[0], -1), "create") != 0, _g_free0 (_tmp7_), _tmp8_)) {
			char* _tmp9_;
			_tmp6_ = _vala_strcmp0 (_tmp9_ = g_utf8_strdown (args[0], -1), "help") != 0;
			_g_free0 (_tmp9_);
		} else {
			_tmp6_ = FALSE;
		}
		if (_tmp6_) {
			char* _tmp10_;
			_tmp5_ = _vala_strcmp0 (_tmp10_ = g_utf8_strdown (args[0], -1), "active") != 0;
			_g_free0 (_tmp10_);
		} else {
			_tmp5_ = FALSE;
		}
		if (_tmp5_) {
			char* _tmp11_;
			_tmp4_ = _vala_strcmp0 (_tmp11_ = g_utf8_strdown (args[0], -1), "quit") != 0;
			_g_free0 (_tmp11_);
		} else {
			_tmp4_ = FALSE;
		}
		if (_tmp4_) {
			char* _tmp12_;
			_tmp3_ = _vala_strcmp0 (_tmp12_ = g_utf8_strdown (args[0], -1), "list-pipes") != 0;
			_g_free0 (_tmp12_);
		} else {
			_tmp3_ = FALSE;
		}
		if (_tmp3_) {
			char* _tmp13_;
			_tmp2_ = _vala_strcmp0 (_tmp13_ = g_utf8_strdown (args[0], -1), "ping") != 0;
			_g_free0 (_tmp13_);
		} else {
			_tmp2_ = FALSE;
		}
		if (_tmp2_) {
			char* _tmp14_;
			_tmp1_ = _vala_strcmp0 (_tmp14_ = g_utf8_strdown (args[0], -1), "exit") != 0;
			_g_free0 (_tmp14_);
		} else {
			_tmp1_ = FALSE;
		}
		if (_tmp1_) {
			_tmp0_ = self->priv->active_pipe == NULL;
		} else {
			_tmp0_ = FALSE;
		}
		if (_tmp0_) {
			if (self->priv->cli_enable) {
				fprintf (stderr, "%s", "There is no active pipeline." "See \"active\" or \"create\" command\n");
			} else {
				fprintf (stderr, "Pipeline path was not specified\n");
			}
			result = FALSE;
			return result;
		}
	} else {
		if (gstd_cli__signals) {
			gboolean _tmp15_ = FALSE;
			char* _tmp16_;
			gboolean _tmp17_;
			fprintf (stdout, "Signals need to be fixed! \n");
			if ((_tmp17_ = _vala_strcmp0 (_tmp16_ = g_utf8_strdown (args[0], -1), "create") != 0, _g_free0 (_tmp16_), _tmp17_)) {
				char* _tmp18_;
				_tmp15_ = _vala_strcmp0 (_tmp18_ = g_utf8_strdown (args[0], -1), "help") != 0;
				_g_free0 (_tmp18_);
			} else {
				_tmp15_ = FALSE;
			}
			if (_tmp15_) {
				fprintf (stdout, "Signals, activated\n");
				_dynamic_Error1_connect (self->priv->pipeline, "Error", (GCallback) _gstd_cli_Error_cb_dynamic_Error0_, self);
				_dynamic_Eos3_connect (self->priv->pipeline, "Eos", (GCallback) _gstd_cli_Eos_cb_dynamic_Eos2_, self);
				_dynamic_StateChanged5_connect (self->priv->pipeline, "StateChanged", (GCallback) _gstd_cli_StateChanged_cb_dynamic_StateChanged4_, self);
			}
		}
	}
	_tmp23_ = g_utf8_strdown (args[0], -1);
	_tmp24_ = (NULL == _tmp23_) ? 0 : g_quark_from_string (_tmp23_);
	g_free (_tmp23_);
	if (_tmp24_ == ((0 != _tmp24__label0) ? _tmp24__label0 : (_tmp24__label0 = g_quark_from_static_string ("create"))))
	do {
		if (self->priv->cli_enable) {
			gint description_size;
			gint description_length1;
			char** description;
			char** _tmp21_;
			char** _tmp20_;
			char* _tmp19_;
			description = (description_length1 = 0, NULL);
			description = (_tmp21_ = _tmp20_ = g_strsplit (_tmp19_ = g_strjoinv (" ", args), "\"", -1), description = (_vala_array_free (description, description_length1, (GDestroyNotify) g_free), NULL), description_length1 = _vala_array_length (_tmp20_), description_size = description_length1, _tmp21_);
			_g_free0 (_tmp19_);
			result = gstd_cli_pipeline_create (self, description[1]);
			description = (_vala_array_free (description, description_length1, (GDestroyNotify) g_free), NULL);
			return result;
		}
		result = gstd_cli_pipeline_create (self, args[1]);
		return result;
	} while (0); else if (_tmp24_ == ((0 != _tmp24__label1) ? _tmp24__label1 : (_tmp24__label1 = g_quark_from_static_string ("destroy"))))
	do {
		if (self->priv->cli_enable) {
			gboolean ret;
			ret = gstd_cli_pipeline_destroy (self, self->priv->active_pipe);
			if (ret) {
				char* _tmp22_;
				self->priv->active_pipe = (_tmp22_ = NULL, _g_free0 (self->priv->active_pipe), _tmp22_);
				result = TRUE;
				return result;
			} else {
				result = FALSE;
				return result;
			}
		} else {
			result = gstd_cli_pipeline_destroy (self, gstd_cli_obj_path);
			return result;
		}
	} while (0); else if (_tmp24_ == ((0 != _tmp24__label2) ? _tmp24__label2 : (_tmp24__label2 = g_quark_from_static_string ("play"))))
	do {
		result = gstd_cli_pipeline_play (self, self->priv->pipeline, TRUE);
		return result;
	} while (0); else if (_tmp24_ == ((0 != _tmp24__label3) ? _tmp24__label3 : (_tmp24__label3 = g_quark_from_static_string ("pause"))))
	do {
		result = gstd_cli_pipeline_pause (self, self->priv->pipeline, TRUE);
		return result;
	} while (0); else if (_tmp24_ == ((0 != _tmp24__label4) ? _tmp24__label4 : (_tmp24__label4 = g_quark_from_static_string ("null"))))
	do {
		result = gstd_cli_pipeline_null (self, self->priv->pipeline, TRUE);
		return result;
	} while (0); else if (_tmp24_ == ((0 != _tmp24__label5) ? _tmp24__label5 : (_tmp24__label5 = g_quark_from_static_string ("aplay"))))
	do {
		result = gstd_cli_pipeline_play (self, self->priv->pipeline, FALSE);
		return result;
	} while (0); else if (_tmp24_ == ((0 != _tmp24__label6) ? _tmp24__label6 : (_tmp24__label6 = g_quark_from_static_string ("apause"))))
	do {
		result = gstd_cli_pipeline_pause (self, self->priv->pipeline, FALSE);
		return result;
	} while (0); else if (_tmp24_ == ((0 != _tmp24__label7) ? _tmp24__label7 : (_tmp24__label7 = g_quark_from_static_string ("anull"))))
	do {
		result = gstd_cli_pipeline_null (self, self->priv->pipeline, FALSE);
		return result;
	} while (0); else if (_tmp24_ == ((0 != _tmp24__label8) ? _tmp24__label8 : (_tmp24__label8 = g_quark_from_static_string ("set"))))
	do {
		result = gstd_cli_pipeline_set_property (self, self->priv->pipeline, args, args_length1);
		return result;
	} while (0); else if (_tmp24_ == ((0 != _tmp24__label9) ? _tmp24__label9 : (_tmp24__label9 = g_quark_from_static_string ("get"))))
	do {
		result = gstd_cli_pipeline_get_property (self, self->priv->pipeline, args, args_length1);
		return result;
	} while (0); else if (_tmp24_ == ((0 != _tmp24__label10) ? _tmp24__label10 : (_tmp24__label10 = g_quark_from_static_string ("get-duration"))))
	do {
		result = gstd_cli_pipeline_get_duration (self, self->priv->pipeline);
		return result;
	} while (0); else if (_tmp24_ == ((0 != _tmp24__label11) ? _tmp24__label11 : (_tmp24__label11 = g_quark_from_static_string ("get-position"))))
	do {
		result = gstd_cli_pipeline_get_position (self, self->priv->pipeline);
		return result;
	} while (0); else if (_tmp24_ == ((0 != _tmp24__label12) ? _tmp24__label12 : (_tmp24__label12 = g_quark_from_static_string ("get-state"))))
	do {
		result = gstd_cli_pipeline_get_state (self, self->priv->pipeline);
		return result;
	} while (0); else if (_tmp24_ == ((0 != _tmp24__label13) ? _tmp24__label13 : (_tmp24__label13 = g_quark_from_static_string ("seek"))))
	do {
		result = gstd_cli_pipeline_seek (self, self->priv->pipeline, args, args_length1);
		return result;
	} while (0); else if (_tmp24_ == ((0 != _tmp24__label14) ? _tmp24__label14 : (_tmp24__label14 = g_quark_from_static_string ("skip"))))
	do {
		result = gstd_cli_pipeline_skip (self, self->priv->pipeline, args, args_length1);
		return result;
	} while (0); else if (_tmp24_ == ((0 != _tmp24__label15) ? _tmp24__label15 : (_tmp24__label15 = g_quark_from_static_string ("speed"))))
	do {
		result = gstd_cli_pipeline_speed (self, self->priv->pipeline, args, args_length1);
		return result;
	} while (0); else if (_tmp24_ == ((0 != _tmp24__label16) ? _tmp24__label16 : (_tmp24__label16 = g_quark_from_static_string ("list-pipes"))))
	do {
		result = gstd_cli_pipeline_list (self);
		return result;
	} while (0); else if (_tmp24_ == ((0 != _tmp24__label17) ? _tmp24__label17 : (_tmp24__label17 = g_quark_from_static_string ("ping"))))
	do {
		result = gstd_cli_gstd_ping (self);
		return result;
	} while (0); else if (_tmp24_ == ((0 != _tmp24__label18) ? _tmp24__label18 : (_tmp24__label18 = g_quark_from_static_string ("active"))))
	do {
		if (args[1] == NULL) {
			result = gstd_cli_get_active (self);
			return result;
		} else {
			result = gstd_cli_set_active (self, args[1]);
			return result;
		}
	} while (0); else if (_tmp24_ == ((0 != _tmp24__label19) ? _tmp24__label19 : (_tmp24__label19 = g_quark_from_static_string ("quit"))))
	do {
		self->priv->cli_enable = FALSE;
		result = TRUE;
		return result;
	} while (0); else if (_tmp24_ == ((0 != _tmp24__label20) ? _tmp24__label20 : (_tmp24__label20 = g_quark_from_static_string ("exit"))))
	do {
		self->priv->cli_enable = FALSE;
		result = TRUE;
		return result;
	} while (0); else if (_tmp24_ == ((0 != _tmp24__label21) ? _tmp24__label21 : (_tmp24__label21 = g_quark_from_static_string ("help"))))
	do {
		gint id;
		id = 0;
		if (args_length1 > 1) {
			while (TRUE) {
				if (!(self->priv->cmds[(id * self->priv->cmds_length2) + 0] != NULL)) {
					break;
				}
				if (_vala_strcmp0 (self->priv->cmds[(id * self->priv->cmds_length2) + 0], args[1]) == 0) {
					fprintf (stdout, "Command: %s\n", args[1]);
					fprintf (stdout, "Description: %s\n", self->priv->cmds[(id * self->priv->cmds_length2) + 2]);
					fprintf (stdout, "Syntax: %s\n", self->priv->cmds[(id * self->priv->cmds_length2) + 1]);
					result = TRUE;
					return result;
				}
				id++;
			}
			fprintf (stdout, "Unknown command: %s\n", args[1]);
			result = FALSE;
			return result;
		} else {
			fprintf (stdout, "%s", "Request the syntax of an specific command with " "\"help <command>\".\n" "This is the list of supported commands:\n");
			while (TRUE) {
				if (!(self->priv->cmds[(id * self->priv->cmds_length2) + 0] != NULL)) {
					break;
				}
				fprintf (stdout, " %s:\t%s\n", self->priv->cmds[(id * self->priv->cmds_length2) + 0], self->priv->cmds[(id * self->priv->cmds_length2) + 2]);
				id++;
			}
			fprintf (stdout, "\n");
		}
		break;
	} while (0); else
	do {
		fprintf (stderr, "Unkown command:%s\n", args[0]);
		result = FALSE;
		return result;
	} while (0);
	result = TRUE;
	return result;
}


static char* __readline (const char* prompt) {
	char* result;
	void* cstr;
	char* str;
	cstr = readline (prompt);
	if (cstr == NULL) {
		result = NULL;
		return result;
	}
	str = g_strdup ((const char*) cstr);
	free (cstr);
	result = str;
	return result;
}


static char* string_strip (const char* self) {
	char* result;
	char* _result_;
	g_return_val_if_fail (self != NULL, NULL);
	_result_ = g_strdup (self);
	g_strstrip (_result_);
	result = _result_;
	return result;
}


gboolean gstd_cli_cli (GstdCli* self, GError** error) {
	gboolean result;
	GError * _inner_error_;
	gint args_size;
	gint args_length1;
	char** args;
	char* home;
	char* _tmp0_;
	char* _tmp5_;
	g_return_val_if_fail (self != NULL, FALSE);
	_inner_error_ = NULL;
	args = (args_length1 = 0, NULL);
	home = g_strdup (g_getenv ("HOME"));
	read_history (_tmp0_ = g_strconcat (home, "/.gst-client_history", NULL));
	_g_free0 (_tmp0_);
	while (TRUE) {
		char* cmd_line;
		if (!(!feof (stdin))) {
			break;
		}
		cmd_line = __readline ("gst-client$ ");
		if (cmd_line != NULL) {
			char* _tmp1_;
			char** _tmp3_;
			char** _tmp2_;
			gboolean _tmp4_ = FALSE;
			add_history (cmd_line);
			_tmp1_ = string_strip (cmd_line);
			_g_free0 (_tmp1_);
			args = (_tmp3_ = _tmp2_ = g_strsplit (cmd_line, " ", -1), args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL), args_length1 = _vala_array_length (_tmp2_), args_size = args_length1, _tmp3_);
			if (args[0] != NULL) {
				_tmp4_ = g_utf8_get_char (g_utf8_offset_to_pointer (cmd_line, 0)) != '#';
			} else {
				_tmp4_ = FALSE;
			}
			if (_tmp4_) {
				gstd_cli_parse_cmd (self, args, args_length1, &_inner_error_);
				if (_inner_error_ != NULL) {
					g_propagate_error (error, _inner_error_);
					_g_free0 (cmd_line);
					args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
					_g_free0 (home);
					return FALSE;
				}
			}
			if (!self->priv->cli_enable) {
				_g_free0 (cmd_line);
				break;
			}
		}
		_g_free0 (cmd_line);
	}
	write_history (_tmp5_ = g_strconcat (home, "/.gst-client_history", NULL));
	_g_free0 (_tmp5_);
	result = TRUE;
	args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (home);
	return result;
}


gboolean gstd_cli_parse (GstdCli* self, char** args, int args_length1, GError** error) {
	gboolean result;
	GError * _inner_error_;
	g_return_val_if_fail (self != NULL, FALSE);
	_inner_error_ = NULL;
	if (args_length1 > 0) {
		gboolean _tmp0_;
		_tmp0_ = gstd_cli_parse_cmd (self, args, args_length1, &_inner_error_);
		if (_inner_error_ != NULL) {
			g_propagate_error (error, _inner_error_);
			return FALSE;
		}
		result = _tmp0_;
		return result;
	} else {
		gboolean _tmp1_;
		self->priv->cli_enable = TRUE;
		_tmp1_ = gstd_cli_cli (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			g_propagate_error (error, _inner_error_);
			return FALSE;
		}
		result = _tmp1_;
		return result;
	}
}


static gint gstd_cli_main (char** args, int args_length1) {
	gint result;
	GError * _inner_error_;
	GstdCli* cli;
	_inner_error_ = NULL;
	cli = NULL;
	{
		char* _tmp0_;
		GstdCli* _tmp1_;
		GstdCli* _tmp2_;
		gboolean _tmp3_;
		gstd_cli_obj_path = (_tmp0_ = NULL, _g_free0 (gstd_cli_obj_path), _tmp0_);
		_tmp1_ = gstd_cli_new (&_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == DBUS_GERROR) {
				goto __catch7_dbus_gerror;
			}
			goto __catch7_g_error;
			goto __finally7;
		}
		cli = (_tmp2_ = _tmp1_, _g_object_unref0 (cli), _tmp2_);
		gstd_cli_parse_options (cli, args, args_length1);
		_tmp3_ = gstd_cli_parse (cli, gstd_cli__remaining_args, _vala_array_length (gstd_cli__remaining_args), &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == DBUS_GERROR) {
				goto __catch7_dbus_gerror;
			}
			goto __catch7_g_error;
			goto __finally7;
		}
		if (!_tmp3_) {
			result = -1;
			_g_object_unref0 (cli);
			return result;
		}
	}
	goto __finally7;
	__catch7_dbus_gerror:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			fprintf (stderr, "gst-client> DBus failure: %s\n", e->message);
			result = 1;
			_g_error_free0 (e);
			_g_object_unref0 (cli);
			return result;
		}
	}
	goto __finally7;
	__catch7_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			fprintf (stderr, "gst-client> Dynamic method failure\n");
			result = 1;
			_g_error_free0 (e);
			_g_object_unref0 (cli);
			return result;
		}
	}
	__finally7:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (cli);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	result = 0;
	_g_object_unref0 (cli);
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return gstd_cli_main (argv, argc);
}


static void gstd_cli_class_init (GstdCliClass * klass) {
	gstd_cli_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GstdCliPrivate));
	G_OBJECT_CLASS (klass)->finalize = gstd_cli_finalize;
}


static void gstd_cli_instance_init (GstdCli * self) {
	char** _tmp0_ = NULL;
	self->priv = GSTD_CLI_GET_PRIVATE (self);
	self->priv->active_pipe = NULL;
	self->priv->cli_enable = FALSE;
	self->priv->pipeline = NULL;
	self->priv->cmds = (_tmp0_ = g_new0 (char*, (21 * 3) + 1), _tmp0_[0] = g_strdup ("create"), _tmp0_[1] = g_strdup ("create <\"gst-launch like pipeline description in quotes\">"), _tmp0_[2] = g_strdup ("Creates a new pipeline and returns the dbus-path to access it"), _tmp0_[3] = g_strdup ("destroy"), _tmp0_[4] = g_strdup ("destroy"), _tmp0_[5] = g_strdup ("Destroys the pipeline specified by_path(-p) or the" " active pipeline"), _tmp0_[6] = g_strdup ("play"), _tmp0_[7] = g_strdup ("play"), _tmp0_[8] = g_strdup ("Sets the pipeline specified by_path(-p) or the active " "pipeline to play state"), _tmp0_[9] = g_strdup ("pause"), _tmp0_[10] = g_strdup ("pause"), _tmp0_[11] = g_strdup ("Sets the pipeline specified by_path(-p) or the active " "pipeline to pause state"), _tmp0_[12] = g_strdup ("null"), _tmp0_[13] = g_strdup ("null"), _tmp0_[14] = g_strdup ("Sets the pipeline specified by_path(-p) or active " "pipeline to null state"), _tmp0_[15] = g_strdup ("aplay"), _tmp0_[16] = g_strdup ("play-async"), _tmp0_[17] = g_strdup ("Sets the pipeline to play state, it does not " "wait the change to be done"), _tmp0_[18] = g_strdup ("apause"), _tmp0_[19] = g_strdup ("pause-async"), _tmp0_[20] = g_strdup ("Sets the pipeline to pause state, it does not " "wait the change to be done"), _tmp0_[21] = g_strdup ("anull"), _tmp0_[22] = g_strdup ("null-async"), _tmp0_[23] = g_strdup ("Sets the pipeline to null state, it does not wait " "the change to be done"), _tmp0_[24] = g_strdup ("set"), _tmp0_[25] = g_strdup ("set <element_name> <property_name> <data-type> <value>"), _tmp0_[26] = g_strdup ("Sets an element's property value of the pipeline"), _tmp0_[27] = g_strdup ("get"), _tmp0_[28] = g_strdup ("get <element_name> <property_name> <data_type>"), _tmp0_[29] = g_strdup ("Gets an element's property value of the pipeline"), _tmp0_[30] = g_strdup ("get-duration"), _tmp0_[31] = g_strdup ("get-duration"), _tmp0_[32] = g_strdup ("Gets the pipeline duration time"), _tmp0_[33] = g_strdup ("get-position"), _tmp0_[34] = g_strdup ("get-position"), _tmp0_[35] = g_strdup ("Gets the pipeline position"), _tmp0_[36] = g_strdup ("get-state"), _tmp0_[37] = g_strdup ("get-state"), _tmp0_[38] = g_strdup ("Get the state of a specific pipeline(-p flag)" " or the active pipeline"), _tmp0_[39] = g_strdup ("list-pipes"), _tmp0_[40] = g_strdup ("list-pipes"), _tmp0_[41] = g_strdup ("Returns a list of all the dbus-path of" "the existing pipelines"), _tmp0_[42] = g_strdup ("ping"), _tmp0_[43] = g_strdup ("ping"), _tmp0_[44] = g_strdup ("Shows if gstd is alive"), _tmp0_[45] = g_strdup ("active"), _tmp0_[46] = g_strdup ("active <path>"), _tmp0_[47] = g_strdup ("Sets the active pipeline,if no <path> is " "passed:it returns the actual active pipeline"), _tmp0_[48] = g_strdup ("seek"), _tmp0_[49] = g_strdup ("seek <position[ms]>"), _tmp0_[50] = g_strdup ("Moves current playing position to a new" " one"), _tmp0_[51] = g_strdup ("skip"), _tmp0_[52] = g_strdup ("skip <period[ms]>"), _tmp0_[53] = g_strdup ("Skips a period, if period is positive: it" " moves foward, if negative: it moves backward"), _tmp0_[54] = g_strdup ("speed"), _tmp0_[55] = g_strdup ("speed <rate>"), _tmp0_[56] = g_strdup ("Changes playback rate:\n\t*rate>1.0: " "fast-foward playback,\n\t*rate<1.0: slow-forward playback,\n\t" "*rate=1.0: normal speed.\n\tWhen rate is negative: it enables " "fast|slow-reverse playback "), _tmp0_[57] = g_strdup ("exit"), _tmp0_[58] = g_strdup ("exit"), _tmp0_[59] = g_strdup ("Exit active console"), _tmp0_[60] = g_strdup ("quit"), _tmp0_[61] = g_strdup ("quit"), _tmp0_[62] = g_strdup ("Quit active console"), _tmp0_);
	self->priv->cmds_length1 = 21;
	self->priv->cmds_length2 = 3;
}


static void gstd_cli_finalize (GObject* obj) {
	GstdCli * self;
	self = GSTD_CLI (obj);
	_dbus_g_connection_unref0 (self->priv->conn);
	_g_object_unref0 (self->priv->factory);
	_g_free0 (self->priv->active_pipe);
	_g_object_unref0 (self->priv->pipeline);
	self->priv->cmds = (_vala_array_free (self->priv->cmds, self->priv->cmds_length1 * self->priv->cmds_length2, (GDestroyNotify) g_free), NULL);
	G_OBJECT_CLASS (gstd_cli_parent_class)->finalize (obj);
}


GType gstd_cli_get_type (void) {
	static GType gstd_cli_type_id = 0;
	if (gstd_cli_type_id == 0) {
		static const GTypeInfo g_define_type_info = { sizeof (GstdCliClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gstd_cli_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GstdCli), 0, (GInstanceInitFunc) gstd_cli_instance_init, NULL };
		gstd_cli_type_id = g_type_register_static (G_TYPE_OBJECT, "GstdCli", &g_define_type_info, 0);
	}
	return gstd_cli_type_id;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}


static int _vala_strcmp0 (const char * str1, const char * str2) {
	if (str1 == NULL) {
		return -(str1 != str2);
	}
	if (str2 == NULL) {
		return str1 != str2;
	}
	return strcmp (str1, str2);
}




