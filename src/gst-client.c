/* gst-client.c generated by valac 0.11.3, the Vala compiler
 * generated from gst-client.vala, do not modify */

/*
 * gstd/src/gst-client.vala
 *
 * Command line utility for sending D-Bus messages to GStreamer daemon with 
*  interactive support.
 *
 * Copyright (c) 2010, RidgeRun
 * All rights reserved.
 *
 * GPL2 license - See http://www.opensource.org/licenses/gpl-2.0.php for 
*  complete text.
 */

#include <glib.h>
#include <glib-object.h>
#include <dbus/dbus-glib-lowlevel.h>
#include <dbus/dbus-glib.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <gst/gst.h>
#include <float.h>
#include <math.h>
#include <readline/history.h>
#include <readline/readline.h>


#define TYPE_GSTD_CLI (gstd_cli_get_type ())
#define GSTD_CLI(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GSTD_CLI, GstdCli))
#define GSTD_CLI_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GSTD_CLI, GstdCliClass))
#define IS_GSTD_CLI(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GSTD_CLI))
#define IS_GSTD_CLI_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GSTD_CLI))
#define GSTD_CLI_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GSTD_CLI, GstdCliClass))

typedef struct _GstdCli GstdCli;
typedef struct _GstdCliClass GstdCliClass;
typedef struct _GstdCliPrivate GstdCliPrivate;
#define _dbus_g_connection_unref0(var) ((var == NULL) ? NULL : (var = (dbus_g_connection_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_option_context_free0(var) ((var == NULL) ? NULL : (var = (g_option_context_free (var), NULL)))
#define _fclose0(var) ((var == NULL) ? NULL : (var = (fclose (var), NULL)))

struct _GstdCli {
	GObject parent_instance;
	GstdCliPrivate * priv;
};

struct _GstdCliClass {
	GObjectClass parent_class;
};

struct _GstdCliPrivate {
	DBusGConnection* conn;
	DBusGProxy* factory;
	gchar* active_pipe;
	gboolean cli_enable;
	DBusGProxy* pipeline;
	gchar** cmds;
	gint cmds_length1;
	gint cmds_length2;
};


static gpointer gstd_cli_parent_class = NULL;
static gchar* gstd_cli_obj_path;
static gchar* gstd_cli_obj_path = NULL;
static gboolean gstd_cli__signals;
static gboolean gstd_cli__signals = FALSE;
static gchar** gstd_cli__remaining_args;
static gchar** gstd_cli__remaining_args = NULL;
static gboolean gstd_cli_useSessionBus;
static gboolean gstd_cli_useSessionBus = FALSE;
static gboolean gstd_cli_isInteractive;
static gboolean gstd_cli_isInteractive = FALSE;
static gboolean gstd_cli_isStrict;
static gboolean gstd_cli_isStrict = FALSE;

GType gstd_cli_get_type (void) G_GNUC_CONST;
#define GSTD_CLI_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_GSTD_CLI, GstdCliPrivate))
enum  {
	GSTD_CLI_DUMMY_PROPERTY
};
GstdCli* gstd_cli_new (gchar** args, int args_length1, GError** error);
GstdCli* gstd_cli_construct (GType object_type, gchar** args, int args_length1, GError** error);
static void gstd_cli_parse_options (GstdCli* self, gchar** args, int args_length1);
void gstd_cli_Error_cb (GstdCli* self);
void gstd_cli_EoS_cb (GstdCli* self);
void gstd_cli_StateChanged_cb (GstdCli* self);
static gboolean gstd_cli_pipeline_create (GstdCli* self, const gchar* description);
static gchar* _dynamic_Create0 (DBusGProxy* self, const gchar* param1, GError** error);
gboolean gstd_cli_create_proxypipe (GstdCli* self, const gchar* object_path);
static gboolean gstd_cli_pipeline_destroy (GstdCli* self, const gchar* objpath);
static gboolean _dynamic_Destroy1 (DBusGProxy* self, const gchar* param1, GError** error);
static gboolean gstd_cli_pipeline_play (GstdCli* self, DBusGProxy* pipeline, gboolean sync);
static gboolean _dynamic_PipelineSetState2 (DBusGProxy* self, GstState param1, GError** error);
static void _dynamic_PipelineAsyncSetState3 (DBusGProxy* self, GstState param1, GError** error);
static gboolean gstd_cli_pipeline_ready (GstdCli* self, DBusGProxy* pipeline, gboolean sync);
static gboolean _dynamic_PipelineSetState4 (DBusGProxy* self, GstState param1, GError** error);
static void _dynamic_PipelineAsyncSetState5 (DBusGProxy* self, GstState param1, GError** error);
static gboolean gstd_cli_pipeline_pause (GstdCli* self, DBusGProxy* pipeline, gboolean sync);
static gboolean _dynamic_PipelineSetState6 (DBusGProxy* self, GstState param1, GError** error);
static void _dynamic_PipelineAsyncSetState7 (DBusGProxy* self, GstState param1, GError** error);
static gboolean gstd_cli_pipeline_null (GstdCli* self, DBusGProxy* pipeline, gboolean sync);
static gboolean _dynamic_PipelineSetState8 (DBusGProxy* self, GstState param1, GError** error);
static void _dynamic_PipelineAsyncSetState9 (DBusGProxy* self, GstState param1, GError** error);
static gboolean gstd_cli_gstd_ping (GstdCli* self);
static gboolean _dynamic_Ping10 (DBusGProxy* self, GError** error);
static gboolean gstd_cli_pipeline_ping (GstdCli* self);
static gboolean _dynamic_Ping11 (DBusGProxy* self, GError** error);
static gboolean gstd_cli_pipeline_get_property (GstdCli* self, DBusGProxy* pipeline, gchar** args, int args_length1);
static void _dynamic_ElementGetPropertyBoolean12 (DBusGProxy* self, const gchar* param1, const gchar* param2, gboolean* param3, gboolean* param4, GError** error);
static void _dynamic_ElementGetPropertyInt13 (DBusGProxy* self, const gchar* param1, const gchar* param2, gint* param3, gboolean* param4, GError** error);
static void _dynamic_ElementGetPropertyInt6414 (DBusGProxy* self, const gchar* param1, const gchar* param2, gint64* param3, gboolean* param4, GError** error);
static void _dynamic_ElementGetPropertyString15 (DBusGProxy* self, const gchar* param1, const gchar* param2, gchar** param3, gboolean* param4, GError** error);
static gboolean gstd_cli_pipeline_set_property (GstdCli* self, DBusGProxy* pipeline, gchar** args, int args_length1);
static gboolean _dynamic_ElementSetPropertyBoolean16 (DBusGProxy* self, const gchar* param1, const gchar* param2, gboolean param3, GError** error);
static gboolean _dynamic_ElementSetPropertyInt17 (DBusGProxy* self, const gchar* param1, const gchar* param2, gint param3, GError** error);
static gboolean _dynamic_ElementSetPropertyInt6418 (DBusGProxy* self, const gchar* param1, const gchar* param2, gint64 param3, GError** error);
static gboolean _dynamic_ElementSetPropertyString19 (DBusGProxy* self, const gchar* param1, const gchar* param2, const gchar* param3, GError** error);
static gboolean gstd_cli_pipeline_get_duration (GstdCli* self, DBusGProxy* pipeline);
static gint64 _dynamic_PipelineGetDuration20 (DBusGProxy* self, GError** error);
static gboolean gstd_cli_pipeline_get_position (GstdCli* self, DBusGProxy* pipeline);
static gint64 _dynamic_PipelineGetPosition21 (DBusGProxy* self, GError** error);
static gboolean gstd_cli_pipeline_get_state (GstdCli* self, DBusGProxy* pipeline);
static GstState _dynamic_PipelineGetState22 (DBusGProxy* self, GError** error);
static gboolean gstd_cli_element_get_state (GstdCli* self, DBusGProxy* pipeline, gchar** args, int args_length1);
static GstState _dynamic_ElementGetState23 (DBusGProxy* self, const gchar* param1, GError** error);
static gboolean gstd_cli_pipeline_seek (GstdCli* self, DBusGProxy* pipeline, gchar** args, int args_length1);
static gboolean _dynamic_PipelineSeek24 (DBusGProxy* self, gint64 param1, GError** error);
static gboolean gstd_cli_pipeline_skip (GstdCli* self, DBusGProxy* pipeline, gchar** args, int args_length1);
static gboolean _dynamic_PipelineSkip25 (DBusGProxy* self, gint64 param1, GError** error);
static gboolean gstd_cli_pipeline_speed (GstdCli* self, DBusGProxy* pipeline, gchar** args, int args_length1);
static gboolean _dynamic_PipelineSpeed26 (DBusGProxy* self, gdouble param1, GError** error);
static gboolean gstd_cli_pipeline_send_eos (GstdCli* self, DBusGProxy* pipeline, gchar** args, int args_length1);
static void _dynamic_PipelineSendEoS27 (DBusGProxy* self, GError** error);
static gint gstd_cli_string_to_state (GstdCli* self, const gchar* state);
static gboolean gstd_cli_element_set_state (GstdCli* self, DBusGProxy* pipeline, gchar** args, int args_length1);
static gboolean _dynamic_ElementSetState28 (DBusGProxy* self, const gchar* param1, gint param2, GError** error);
static gboolean gstd_cli_element_async_set_state (GstdCli* self, DBusGProxy* pipeline, gchar** args, int args_length1);
static gboolean _dynamic_ElementAsyncSetState29 (DBusGProxy* self, const gchar* param1, gint param2, GError** error);
static gboolean gstd_cli_set_active (GstdCli* self, const gchar* path);
static gboolean gstd_cli_get_active (GstdCli* self);
static gboolean gstd_cli_pipeline_list (GstdCli* self);
static gchar** _dynamic_List30 (DBusGProxy* self, int* result_length1, GError** error);
static gboolean gstd_cli_shell (GstdCli* self, const gchar* command);
static gboolean gstd_cli_set_strict (GstdCli* self, gchar** args, int args_length1);
static gboolean _dynamic_PipelineIsInitialized31 (DBusGProxy* self, GError** error);
gboolean gstd_cli_parse_cmd (GstdCli* self, gchar** args, int args_length1, GError** error);
static gboolean _dynamic_DestroyAll32 (DBusGProxy* self, GError** error);
gboolean gstd_cli_cli (GstdCli* self, GError** error);
gboolean gstd_cli_parse (GstdCli* self, gchar** remainingArgs, int remainingArgs_length1, GError** error);
static gint gstd_cli_main (gchar** args, int args_length1);
static void gstd_cli_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);

static const GOptionEntry GSTD_CLI_options[5] = {{"session", '\0', 0, G_OPTION_ARG_NONE, &gstd_cli_useSessionBus, "Use dbus session bus.", NULL}, {"path", 'p', 0, G_OPTION_ARG_STRING, &gstd_cli_obj_path, "Pipeline path or path_id.  Required for commands that " "effect a specific pipeline.  Usage: -p <path_id>", NULL}, {"enable_signals", 's', 0, G_OPTION_ARG_INT, &gstd_cli__signals, "Flag to enable reception of dbus signals from GStreamer " "Daemon.  Usage: -s 1", NULL}, {"", '\0', 0, G_OPTION_ARG_FILENAME_ARRAY, &gstd_cli__remaining_args, NULL, "[COMMANDS...]"}, {NULL}};

GstdCli* gstd_cli_construct (GType object_type, gchar** args, int args_length1, GError** error) {
	GstdCli * self = NULL;
	DBusBusType _tmp0_ = 0;
	DBusGConnection* _tmp1_ = NULL;
	DBusGConnection* _tmp2_;
	DBusGConnection* _tmp3_;
	DBusGProxy* _tmp4_ = NULL;
	DBusGProxy* _tmp5_;
	GError * _inner_error_ = NULL;
	self = (GstdCli*) g_object_new (object_type, NULL);
	gstd_cli_parse_options (self, args, args_length1);
	if (gstd_cli_useSessionBus) {
		_tmp0_ = DBUS_BUS_SESSION;
	} else {
		_tmp0_ = DBUS_BUS_SYSTEM;
	}
	_tmp1_ = dbus_g_bus_get (_tmp0_, &_inner_error_);
	_tmp2_ = _tmp1_;
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (self);
		return NULL;
	}
	_tmp3_ = _tmp2_;
	_dbus_g_connection_unref0 (self->priv->conn);
	self->priv->conn = _tmp3_;
	_tmp4_ = dbus_g_proxy_new_for_name (self->priv->conn, "com.ridgerun.gstreamer.gstd", "/com/ridgerun/gstreamer/gstd/factory", "com.ridgerun.gstreamer.gstd.FactoryInterface");
	_tmp5_ = _tmp4_;
	_g_object_unref0 (self->priv->factory);
	self->priv->factory = _tmp5_;
	return self;
}


GstdCli* gstd_cli_new (gchar** args, int args_length1, GError** error) {
	return gstd_cli_construct (TYPE_GSTD_CLI, args, args_length1, error);
}


/**
   *Callback functions for the receiving signals
 */
void gstd_cli_Error_cb (GstdCli* self) {
	g_return_if_fail (self != NULL);
	fprintf (stdout, "Error signal received\n");
}


void gstd_cli_EoS_cb (GstdCli* self) {
	g_return_if_fail (self != NULL);
	fprintf (stdout, "End of Stream signal received\n");
}


void gstd_cli_StateChanged_cb (GstdCli* self) {
	g_return_if_fail (self != NULL);
	fprintf (stdout, "StateChanged signal received\n");
}


/**
 * Console Commands Functions
 */
static gchar* _dynamic_Create0 (DBusGProxy* self, const gchar* param1, GError** error) {
	gchar* result;
	dbus_g_proxy_call (self, "Create", error, G_TYPE_STRING, param1, G_TYPE_INVALID, G_TYPE_STRING, &result, G_TYPE_INVALID);
	if (*error) {
		return NULL;
	}
	return result;
}


static gboolean gstd_cli_pipeline_create (GstdCli* self, const gchar* description) {
	gboolean result = FALSE;
	gchar* _tmp0_ = NULL;
	gchar* new_objpath;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	if (description == NULL) {
		fprintf (stderr, "Error:\nDescription between quotes(\"\") needed\n");
		result = FALSE;
		return result;
	}
	_tmp0_ = _dynamic_Create0 (self->priv->factory, description, &_inner_error_);
	new_objpath = _tmp0_;
	if (_inner_error_ != NULL) {
		goto __catch0_g_error;
	}
	if (g_strcmp0 (new_objpath, "") == 0) {
		fprintf (stderr, "Error:\nFailed to create pipeline\n");
		result = FALSE;
		_g_free0 (new_objpath);
		return result;
	}
	if (self->priv->cli_enable) {
		gchar* _tmp1_;
		gchar* _tmp2_;
		_tmp1_ = g_strdup (new_objpath);
		_tmp2_ = _tmp1_;
		_g_free0 (self->priv->active_pipe);
		self->priv->active_pipe = _tmp2_;
		gstd_cli_create_proxypipe (self, self->priv->active_pipe);
	}
	fprintf (stdout, "Pipeline path created: %s\n", new_objpath);
	fprintf (stdout, "Ok.\n");
	result = TRUE;
	_g_free0 (new_objpath);
	return result;
	_g_free0 (new_objpath);
	goto __finally0;
	__catch0_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stderr, "Error:\nCreating pipeline:%s\n", e->message);
		result = FALSE;
		_g_error_free0 (e);
		return result;
	}
	__finally0:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return FALSE;
}


static gboolean _dynamic_Destroy1 (DBusGProxy* self, const gchar* param1, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "Destroy", error, G_TYPE_STRING, param1, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


static gboolean gstd_cli_pipeline_destroy (GstdCli* self, const gchar* objpath) {
	gboolean result = FALSE;
	gboolean _tmp0_;
	gboolean ret;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (objpath != NULL, FALSE);
	_tmp0_ = _dynamic_Destroy1 (self->priv->factory, objpath, &_inner_error_);
	ret = _tmp0_;
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	if (!ret) {
		fprintf (stderr, "Error:\nFailed to put the pipeline to null\n");
		result = FALSE;
		return result;
	}
	fprintf (stdout, "Pipeline with path:%s, destroyed\n", objpath);
	fprintf (stdout, "Ok.\n");
	result = TRUE;
	return result;
}


static gboolean _dynamic_PipelineSetState2 (DBusGProxy* self, GstState param1, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "PipelineSetState", error, G_TYPE_INT, param1, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


static void _dynamic_PipelineAsyncSetState3 (DBusGProxy* self, GstState param1, GError** error) {
	dbus_g_proxy_call (self, "PipelineAsyncSetState", error, G_TYPE_INT, param1, G_TYPE_INVALID, G_TYPE_INVALID);
	if (*error) {
		return;
	}
}


static gboolean gstd_cli_pipeline_play (GstdCli* self, DBusGProxy* pipeline, gboolean sync) {
	gboolean result = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pipeline != NULL, FALSE);
	if (sync) {
		gboolean _tmp0_;
		gboolean ret;
		_tmp0_ = _dynamic_PipelineSetState2 (pipeline, GST_STATE_PLAYING, &_inner_error_);
		ret = _tmp0_;
		if (_inner_error_ != NULL) {
			goto __catch1_g_error;
		}
		if (!ret) {
			fprintf (stdout, "Error:\nFailed to put the pipeline to play\n");
			result = FALSE;
			return result;
		}
	} else {
		_dynamic_PipelineAsyncSetState3 (pipeline, GST_STATE_PLAYING, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch1_g_error;
		}
	}
	fprintf (stdout, "Ok.\n");
	result = TRUE;
	return result;
	goto __finally1;
	__catch1_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Error:\n%s\n", e->message);
		result = FALSE;
		_g_error_free0 (e);
		return result;
	}
	__finally1:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return FALSE;
}


static gboolean _dynamic_PipelineSetState4 (DBusGProxy* self, GstState param1, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "PipelineSetState", error, G_TYPE_INT, param1, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


static void _dynamic_PipelineAsyncSetState5 (DBusGProxy* self, GstState param1, GError** error) {
	dbus_g_proxy_call (self, "PipelineAsyncSetState", error, G_TYPE_INT, param1, G_TYPE_INVALID, G_TYPE_INVALID);
	if (*error) {
		return;
	}
}


static gboolean gstd_cli_pipeline_ready (GstdCli* self, DBusGProxy* pipeline, gboolean sync) {
	gboolean result = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pipeline != NULL, FALSE);
	if (sync) {
		gboolean _tmp0_;
		gboolean ret;
		_tmp0_ = _dynamic_PipelineSetState4 (pipeline, GST_STATE_READY, &_inner_error_);
		ret = _tmp0_;
		if (_inner_error_ != NULL) {
			goto __catch2_g_error;
		}
		if (!ret) {
			fprintf (stdout, "Error:\nFailed to put the pipeline to ready\n");
			result = FALSE;
			return result;
		}
	} else {
		_dynamic_PipelineAsyncSetState5 (pipeline, GST_STATE_READY, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch2_g_error;
		}
	}
	fprintf (stdout, "Ok.\n");
	result = TRUE;
	return result;
	goto __finally2;
	__catch2_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Error:\n%s\n", e->message);
		result = FALSE;
		_g_error_free0 (e);
		return result;
	}
	__finally2:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return FALSE;
}


static gboolean _dynamic_PipelineSetState6 (DBusGProxy* self, GstState param1, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "PipelineSetState", error, G_TYPE_INT, param1, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


static void _dynamic_PipelineAsyncSetState7 (DBusGProxy* self, GstState param1, GError** error) {
	dbus_g_proxy_call (self, "PipelineAsyncSetState", error, G_TYPE_INT, param1, G_TYPE_INVALID, G_TYPE_INVALID);
	if (*error) {
		return;
	}
}


static gboolean gstd_cli_pipeline_pause (GstdCli* self, DBusGProxy* pipeline, gboolean sync) {
	gboolean result = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pipeline != NULL, FALSE);
	if (sync) {
		gboolean _tmp0_;
		gboolean ret;
		_tmp0_ = _dynamic_PipelineSetState6 (pipeline, GST_STATE_PAUSED, &_inner_error_);
		ret = _tmp0_;
		if (_inner_error_ != NULL) {
			goto __catch3_g_error;
		}
		if (!ret) {
			fprintf (stdout, "Error:\nFailed to put the pipeline to pause\n");
			result = FALSE;
			return result;
		}
	} else {
		_dynamic_PipelineAsyncSetState7 (pipeline, GST_STATE_PAUSED, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch3_g_error;
		}
	}
	fprintf (stdout, "Ok.\n");
	result = TRUE;
	return result;
	goto __finally3;
	__catch3_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Error:\n%s\n", e->message);
		result = FALSE;
		_g_error_free0 (e);
		return result;
	}
	__finally3:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return FALSE;
}


static gboolean _dynamic_PipelineSetState8 (DBusGProxy* self, GstState param1, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "PipelineSetState", error, G_TYPE_INT, param1, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


static void _dynamic_PipelineAsyncSetState9 (DBusGProxy* self, GstState param1, GError** error) {
	dbus_g_proxy_call (self, "PipelineAsyncSetState", error, G_TYPE_INT, param1, G_TYPE_INVALID, G_TYPE_INVALID);
	if (*error) {
		return;
	}
}


static gboolean gstd_cli_pipeline_null (GstdCli* self, DBusGProxy* pipeline, gboolean sync) {
	gboolean result = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pipeline != NULL, FALSE);
	if (sync) {
		gboolean _tmp0_;
		gboolean ret;
		_tmp0_ = _dynamic_PipelineSetState8 (pipeline, GST_STATE_NULL, &_inner_error_);
		ret = _tmp0_;
		if (_inner_error_ != NULL) {
			goto __catch4_g_error;
		}
		if (!ret) {
			fprintf (stderr, "Error:\nFailed to put the pipeline to null\n");
			result = FALSE;
			return result;
		}
	} else {
		_dynamic_PipelineAsyncSetState9 (pipeline, GST_STATE_NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch4_g_error;
		}
	}
	fprintf (stdout, "Ok.\n");
	result = TRUE;
	return result;
	goto __finally4;
	__catch4_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Error:\n%s\n", e->message);
		result = FALSE;
		_g_error_free0 (e);
		return result;
	}
	__finally4:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return FALSE;
}


static gboolean _dynamic_Ping10 (DBusGProxy* self, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "Ping", error, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


static gboolean gstd_cli_gstd_ping (GstdCli* self) {
	gboolean result = FALSE;
	gboolean ret;
	gboolean _tmp0_;
	gboolean _tmp1_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	ret = FALSE;
	_tmp0_ = _dynamic_Ping10 (self->priv->factory, &_inner_error_);
	_tmp1_ = _tmp0_;
	if (_inner_error_ != NULL) {
		goto __catch5_g_error;
	}
	ret = _tmp1_;
	goto __finally5;
	__catch5_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stderr, "Error:\nFailed to reach gstd!\n");
		result = ret;
		_g_error_free0 (e);
		return result;
	}
	__finally5:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	fprintf (stdout, "pong\n");
	result = ret;
	return result;
}


static gboolean _dynamic_Ping11 (DBusGProxy* self, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "Ping", error, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


static gboolean gstd_cli_pipeline_ping (GstdCli* self) {
	gboolean result = FALSE;
	gboolean _tmp0_;
	gboolean _result_;
	const gchar* _tmp1_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	if (self->priv->pipeline == NULL) {
		result = FALSE;
		return result;
	}
	_tmp0_ = _dynamic_Ping11 (self->priv->pipeline, &_inner_error_);
	_result_ = _tmp0_;
	if (_inner_error_ != NULL) {
		goto __catch6_g_error;
	}
	_tmp1_ = NULL;
	if (_result_) {
		_tmp1_ = "Success";
	} else {
		_tmp1_ = "Failed";
	}
	fprintf (stdout, "Pipeline ping result = %s\n", _tmp1_);
	result = _result_;
	return result;
	goto __finally6;
	__catch6_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stderr, "Error:\nFailed to ping pipeline!\n");
		result = FALSE;
		_g_error_free0 (e);
		return result;
	}
	__finally6:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return FALSE;
}


static void _dynamic_ElementGetPropertyBoolean12 (DBusGProxy* self, const gchar* param1, const gchar* param2, gboolean* param3, gboolean* param4, GError** error) {
	dbus_g_proxy_call (self, "ElementGetPropertyBoolean", error, G_TYPE_STRING, param1, G_TYPE_STRING, param2, G_TYPE_INVALID, G_TYPE_BOOLEAN, param3, G_TYPE_BOOLEAN, param4, G_TYPE_INVALID);
	if (*error) {
		return;
	}
}


static void _dynamic_ElementGetPropertyInt13 (DBusGProxy* self, const gchar* param1, const gchar* param2, gint* param3, gboolean* param4, GError** error) {
	dbus_g_proxy_call (self, "ElementGetPropertyInt", error, G_TYPE_STRING, param1, G_TYPE_STRING, param2, G_TYPE_INVALID, G_TYPE_INT, param3, G_TYPE_BOOLEAN, param4, G_TYPE_INVALID);
	if (*error) {
		return;
	}
}


static void _dynamic_ElementGetPropertyInt6414 (DBusGProxy* self, const gchar* param1, const gchar* param2, gint64* param3, gboolean* param4, GError** error) {
	dbus_g_proxy_call (self, "ElementGetPropertyInt64", error, G_TYPE_STRING, param1, G_TYPE_STRING, param2, G_TYPE_INVALID, G_TYPE_INT64, param3, G_TYPE_BOOLEAN, param4, G_TYPE_INVALID);
	if (*error) {
		return;
	}
}


static void _dynamic_ElementGetPropertyString15 (DBusGProxy* self, const gchar* param1, const gchar* param2, gchar** param3, gboolean* param4, GError** error) {
	dbus_g_proxy_call (self, "ElementGetPropertyString", error, G_TYPE_STRING, param1, G_TYPE_STRING, param2, G_TYPE_INVALID, G_TYPE_STRING, param3, G_TYPE_BOOLEAN, param4, G_TYPE_INVALID);
	if (*error) {
		return;
	}
}


static gboolean gstd_cli_pipeline_get_property (GstdCli* self, DBusGProxy* pipeline, gchar** args, int args_length1) {
	gboolean result = FALSE;
	gboolean ret;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gchar* _tmp2_;
	gchar* element;
	gchar* _tmp3_;
	gchar* property;
	gboolean success = FALSE;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_;
	GQuark _tmp6_;
	static GQuark _tmp6__label0 = 0;
	static GQuark _tmp6__label1 = 0;
	static GQuark _tmp6__label2 = 0;
	static GQuark _tmp6__label3 = 0;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pipeline != NULL, FALSE);
	ret = TRUE;
	if (args[1] == NULL) {
		_tmp1_ = TRUE;
	} else {
		_tmp1_ = args[2] == NULL;
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = args[3] == NULL;
	}
	if (_tmp0_) {
		fprintf (stdout, "Error:\nMissing argument.Execute:'help get'\n");
		result = FALSE;
		return result;
	}
	_tmp2_ = g_strdup (args[1]);
	element = _tmp2_;
	_tmp3_ = g_strdup (args[2]);
	property = _tmp3_;
	_tmp4_ = g_utf8_strdown (args[3], (gssize) (-1));
	_tmp5_ = _tmp4_;
	_tmp6_ = (NULL == _tmp5_) ? 0 : g_quark_from_string (_tmp5_);
	g_free (_tmp5_);
	if (_tmp6_ == ((0 != _tmp6__label0) ? _tmp6__label0 : (_tmp6__label0 = g_quark_from_static_string ("boolean")))) {
		switch (0) {
			default:
			{
				gboolean boolean_v = FALSE;
				gboolean _tmp7_;
				gboolean _tmp8_;
				const gchar* _tmp9_;
				_dynamic_ElementGetPropertyBoolean12 (pipeline, element, property, &_tmp7_, &_tmp8_, &_inner_error_);
				boolean_v = _tmp7_;
				success = _tmp8_;
				if (_inner_error_ != NULL) {
					_g_free0 (property);
					_g_free0 (element);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return FALSE;
				}
				if (!success) {
					fprintf (stdout, "Failed to get property value");
					ret = FALSE;
					break;
				}
				_tmp9_ = NULL;
				if (boolean_v) {
					_tmp9_ = "true";
				} else {
					_tmp9_ = "false";
				}
				fprintf (stdout, "The '%s' value on element '%s' is: %s\n", property, element, _tmp9_);
				break;
			}
		}
	} else if (_tmp6_ == ((0 != _tmp6__label1) ? _tmp6__label1 : (_tmp6__label1 = g_quark_from_static_string ("integer")))) {
		switch (0) {
			default:
			{
				gint integer_v = 0;
				gint _tmp10_;
				gboolean _tmp11_;
				_dynamic_ElementGetPropertyInt13 (pipeline, element, property, &_tmp10_, &_tmp11_, &_inner_error_);
				integer_v = _tmp10_;
				success = _tmp11_;
				if (_inner_error_ != NULL) {
					_g_free0 (property);
					_g_free0 (element);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return FALSE;
				}
				if (!success) {
					fprintf (stdout, "Failed to get property value");
					ret = FALSE;
					break;
				}
				fprintf (stdout, "The '%s' value on element '%s' is: %d\n", property, element, integer_v);
				break;
			}
		}
	} else if (_tmp6_ == ((0 != _tmp6__label2) ? _tmp6__label2 : (_tmp6__label2 = g_quark_from_static_string ("int64")))) {
		switch (0) {
			default:
			{
				gint64 int64_v = 0LL;
				gint64 _tmp12_;
				gboolean _tmp13_;
				_dynamic_ElementGetPropertyInt6414 (pipeline, element, property, &_tmp12_, &_tmp13_, &_inner_error_);
				int64_v = _tmp12_;
				success = _tmp13_;
				if (_inner_error_ != NULL) {
					_g_free0 (property);
					_g_free0 (element);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return FALSE;
				}
				if (!success) {
					fprintf (stdout, "Failed to get property value");
					ret = FALSE;
					break;
				}
				fprintf (stdout, "The '%s' value on element '%s' is: %lld\n", property, element, int64_v);
				break;
			}
		}
	} else if (_tmp6_ == ((0 != _tmp6__label3) ? _tmp6__label3 : (_tmp6__label3 = g_quark_from_static_string ("string")))) {
		switch (0) {
			default:
			{
				gchar* string_v;
				gchar* _tmp14_ = NULL;
				gboolean _tmp15_;
				string_v = NULL;
				_dynamic_ElementGetPropertyString15 (pipeline, element, property, &_tmp14_, &_tmp15_, &_inner_error_);
				_g_free0 (string_v);
				string_v = _tmp14_;
				success = _tmp15_;
				if (_inner_error_ != NULL) {
					_g_free0 (string_v);
					_g_free0 (property);
					_g_free0 (element);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return FALSE;
				}
				if (!success) {
					fprintf (stdout, "Failed to get property value");
					ret = FALSE;
					_g_free0 (string_v);
					break;
				}
				fprintf (stdout, "The '%s' value on element '%s' is: %s\n", property, element, string_v);
				_g_free0 (string_v);
				break;
			}
		}
	} else {
		switch (0) {
			default:
			{
				fprintf (stderr, "Error:\nDatatype not supported: %s\n", args[3]);
				result = FALSE;
				_g_free0 (property);
				_g_free0 (element);
				return result;
			}
		}
	}
	if (!ret) {
		fprintf (stdout, "Error:\nFailed to get property:%s\n", property);
		result = FALSE;
		_g_free0 (property);
		_g_free0 (element);
		return result;
	}
	fprintf (stdout, "Ok.\n");
	result = ret;
	_g_free0 (property);
	_g_free0 (element);
	return result;
}


static gboolean string_to_bool (const gchar* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	if (g_strcmp0 (self, "true") == 0) {
		result = TRUE;
		return result;
	} else {
		result = FALSE;
		return result;
	}
}


static gboolean _dynamic_ElementSetPropertyBoolean16 (DBusGProxy* self, const gchar* param1, const gchar* param2, gboolean param3, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "ElementSetPropertyBoolean", error, G_TYPE_STRING, param1, G_TYPE_STRING, param2, G_TYPE_BOOLEAN, param3, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


static gboolean _dynamic_ElementSetPropertyInt17 (DBusGProxy* self, const gchar* param1, const gchar* param2, gint param3, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "ElementSetPropertyInt", error, G_TYPE_STRING, param1, G_TYPE_STRING, param2, G_TYPE_INT, param3, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


static gboolean _dynamic_ElementSetPropertyInt6418 (DBusGProxy* self, const gchar* param1, const gchar* param2, gint64 param3, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "ElementSetPropertyInt64", error, G_TYPE_STRING, param1, G_TYPE_STRING, param2, G_TYPE_INT64, param3, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


static gboolean _dynamic_ElementSetPropertyString19 (DBusGProxy* self, const gchar* param1, const gchar* param2, const gchar* param3, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "ElementSetPropertyString", error, G_TYPE_STRING, param1, G_TYPE_STRING, param2, G_TYPE_STRING, param3, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


static gboolean gstd_cli_pipeline_set_property (GstdCli* self, DBusGProxy* pipeline, gchar** args, int args_length1) {
	gboolean result = FALSE;
	gboolean ret = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gchar* _tmp3_;
	gchar* element;
	gchar* _tmp4_;
	gchar* property;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_;
	GQuark _tmp7_;
	static GQuark _tmp7__label0 = 0;
	static GQuark _tmp7__label1 = 0;
	static GQuark _tmp7__label2 = 0;
	static GQuark _tmp7__label3 = 0;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pipeline != NULL, FALSE);
	if (args[1] == NULL) {
		_tmp2_ = TRUE;
	} else {
		_tmp2_ = args[2] == NULL;
	}
	if (_tmp2_) {
		_tmp1_ = TRUE;
	} else {
		_tmp1_ = args[3] == NULL;
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = args[4] == NULL;
	}
	if (_tmp0_) {
		fprintf (stdout, "Error:\nMissing argument.Execute:'help set'\n");
		result = FALSE;
		return result;
	}
	_tmp3_ = g_strdup (args[1]);
	element = _tmp3_;
	_tmp4_ = g_strdup (args[2]);
	property = _tmp4_;
	_tmp5_ = g_utf8_strdown (args[3], (gssize) (-1));
	_tmp6_ = _tmp5_;
	_tmp7_ = (NULL == _tmp6_) ? 0 : g_quark_from_string (_tmp6_);
	g_free (_tmp6_);
	if (_tmp7_ == ((0 != _tmp7__label0) ? _tmp7__label0 : (_tmp7__label0 = g_quark_from_static_string ("boolean")))) {
		switch (0) {
			default:
			{
				gchar* _tmp8_ = NULL;
				gchar* _tmp9_;
				gboolean _tmp10_;
				gboolean _tmp11_;
				gboolean boolean_v;
				const gchar* _tmp12_;
				gboolean _tmp13_;
				gboolean _tmp14_;
				_tmp8_ = g_utf8_strdown (args[4], (gssize) (-1));
				_tmp9_ = _tmp8_;
				_tmp10_ = string_to_bool (_tmp9_);
				boolean_v = (_tmp11_ = _tmp10_, _g_free0 (_tmp9_), _tmp11_);
				_tmp12_ = NULL;
				if (boolean_v) {
					_tmp12_ = "true";
				} else {
					_tmp12_ = "false";
				}
				fprintf (stdout, "Trying to set '%s' on element '%s' to the value:%s\n", property, element, _tmp12_);
				_tmp13_ = _dynamic_ElementSetPropertyBoolean16 (pipeline, element, property, boolean_v, &_inner_error_);
				_tmp14_ = _tmp13_;
				if (_inner_error_ != NULL) {
					_g_free0 (property);
					_g_free0 (element);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return FALSE;
				}
				ret = _tmp14_;
				break;
			}
		}
	} else if (_tmp7_ == ((0 != _tmp7__label1) ? _tmp7__label1 : (_tmp7__label1 = g_quark_from_static_string ("integer")))) {
		switch (0) {
			default:
			{
				gint _tmp15_;
				gint integer_v;
				gboolean _tmp16_;
				gboolean _tmp17_;
				_tmp15_ = atoi (args[4]);
				integer_v = _tmp15_;
				fprintf (stdout, "Trying to set '%s' on element '%s' to the value:%d\n", property, element, integer_v);
				_tmp16_ = _dynamic_ElementSetPropertyInt17 (pipeline, element, property, integer_v, &_inner_error_);
				_tmp17_ = _tmp16_;
				if (_inner_error_ != NULL) {
					_g_free0 (property);
					_g_free0 (element);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return FALSE;
				}
				ret = _tmp17_;
				break;
			}
		}
	} else if (_tmp7_ == ((0 != _tmp7__label2) ? _tmp7__label2 : (_tmp7__label2 = g_quark_from_static_string ("int64")))) {
		switch (0) {
			default:
			{
				gint64 _tmp18_;
				gint64 int64_v;
				gboolean _tmp19_;
				gboolean _tmp20_;
				_tmp18_ = g_ascii_strtoll (args[4], NULL, 0);
				int64_v = _tmp18_;
				fprintf (stdout, "Trying to set '%s' on element '%s' to the value:%lld\n", property, element, int64_v);
				_tmp19_ = _dynamic_ElementSetPropertyInt6418 (pipeline, element, property, int64_v, &_inner_error_);
				_tmp20_ = _tmp19_;
				if (_inner_error_ != NULL) {
					_g_free0 (property);
					_g_free0 (element);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return FALSE;
				}
				ret = _tmp20_;
				break;
			}
		}
	} else if (_tmp7_ == ((0 != _tmp7__label3) ? _tmp7__label3 : (_tmp7__label3 = g_quark_from_static_string ("string")))) {
		switch (0) {
			default:
			{
				gchar* _tmp21_;
				gchar* string_v;
				gboolean _tmp22_;
				gboolean _tmp23_;
				_tmp21_ = g_strdup (args[4]);
				string_v = _tmp21_;
				fprintf (stdout, "Trying to set '%s' on element '%s' to the value:%s\n", property, element, string_v);
				_tmp22_ = _dynamic_ElementSetPropertyString19 (pipeline, element, property, string_v, &_inner_error_);
				_tmp23_ = _tmp22_;
				if (_inner_error_ != NULL) {
					_g_free0 (string_v);
					_g_free0 (property);
					_g_free0 (element);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return FALSE;
				}
				ret = _tmp23_;
				_g_free0 (string_v);
				break;
			}
		}
	} else {
		switch (0) {
			default:
			{
				fprintf (stderr, "Error:\nDatatype not supported: %s\n", args[3]);
				result = FALSE;
				_g_free0 (property);
				_g_free0 (element);
				return result;
			}
		}
	}
	if (!ret) {
		fprintf (stderr, "Error:\nFailed to set property:%s\n", property);
		result = FALSE;
		_g_free0 (property);
		_g_free0 (element);
		return result;
	}
	fprintf (stdout, "Ok.\n");
	result = ret;
	_g_free0 (property);
	_g_free0 (element);
	return result;
}


static gint64 _dynamic_PipelineGetDuration20 (DBusGProxy* self, GError** error) {
	gint64 result;
	dbus_g_proxy_call (self, "PipelineGetDuration", error, G_TYPE_INVALID, G_TYPE_INT64, &result, G_TYPE_INVALID);
	if (*error) {
		return 0LL;
	}
	return result;
}


static gboolean gstd_cli_pipeline_get_duration (GstdCli* self, DBusGProxy* pipeline) {
	gboolean result = FALSE;
	gint64 _tmp0_;
	gint64 time;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pipeline != NULL, FALSE);
	_tmp0_ = _dynamic_PipelineGetDuration20 (pipeline, &_inner_error_);
	time = _tmp0_;
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	if (time < 0) {
		fprintf (stderr, "Error:\nFailed to get pipeline duration\n");
		result = FALSE;
		return result;
	}
	time = time / ((gint64) 1000000);
	fprintf (stdout, "The duration on the pipeline is %u:%02u:%02u.%03u\n", (guint) (time / ((1000 * 60) * 60)), (guint) ((time / (1000 * 60)) % 60), (guint) ((time / 1000) % 60), (guint) (time % 1000));
	fprintf (stdout, "Ok.\n");
	result = TRUE;
	return result;
}


static gint64 _dynamic_PipelineGetPosition21 (DBusGProxy* self, GError** error) {
	gint64 result;
	dbus_g_proxy_call (self, "PipelineGetPosition", error, G_TYPE_INVALID, G_TYPE_INT64, &result, G_TYPE_INVALID);
	if (*error) {
		return 0LL;
	}
	return result;
}


static gboolean gstd_cli_pipeline_get_position (GstdCli* self, DBusGProxy* pipeline) {
	gboolean result = FALSE;
	gint64 _tmp0_;
	gint64 pos;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pipeline != NULL, FALSE);
	_tmp0_ = _dynamic_PipelineGetPosition21 (pipeline, &_inner_error_);
	pos = _tmp0_;
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	if (pos < 0) {
		fprintf (stderr, "Error:\nFailed to get position the pipeline to null\n");
		result = FALSE;
		return result;
	}
	pos = pos / ((gint64) 1000000);
	fprintf (stdout, "The position on the pipeline is %u:%02u:%02u.%03u\n", (guint) (pos / ((1000 * 60) * 60)), (guint) ((pos / (1000 * 60)) % 60), (guint) ((pos / 1000) % 60), (guint) (pos % 1000));
	fprintf (stdout, "Ok.\n");
	result = TRUE;
	return result;
}


static GstState _dynamic_PipelineGetState22 (DBusGProxy* self, GError** error) {
	GstState result;
	dbus_g_proxy_call (self, "PipelineGetState", error, G_TYPE_INVALID, G_TYPE_INT, &result, G_TYPE_INVALID);
	if (*error) {
		return 0;
	}
	return result;
}


static gboolean gstd_cli_pipeline_get_state (GstdCli* self, DBusGProxy* pipeline) {
	gboolean result = FALSE;
	GstState _tmp0_;
	GstState state;
	const gchar* _tmp1_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pipeline != NULL, FALSE);
	_tmp0_ = _dynamic_PipelineGetState22 (pipeline, &_inner_error_);
	state = _tmp0_;
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	_tmp1_ = gst_element_state_get_name (state);
	fprintf (stdout, "The pipeline state is: %s\n", _tmp1_);
	result = TRUE;
	return result;
}


static GstState _dynamic_ElementGetState23 (DBusGProxy* self, const gchar* param1, GError** error) {
	GstState result;
	dbus_g_proxy_call (self, "ElementGetState", error, G_TYPE_STRING, param1, G_TYPE_INVALID, G_TYPE_INT, &result, G_TYPE_INVALID);
	if (*error) {
		return 0;
	}
	return result;
}


static gboolean gstd_cli_element_get_state (GstdCli* self, DBusGProxy* pipeline, gchar** args, int args_length1) {
	gboolean result = FALSE;
	gchar* _tmp0_;
	gchar* element;
	GstState _tmp1_;
	GstState state;
	const gchar* _tmp2_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pipeline != NULL, FALSE);
	if (args[1] == NULL) {
		fprintf (stdout, "Error:\nMissing element argument. Execute:'help element_get_state'\n");
		result = FALSE;
		return result;
	}
	_tmp0_ = g_strdup (args[1]);
	element = _tmp0_;
	_tmp1_ = _dynamic_ElementGetState23 (pipeline, element, &_inner_error_);
	state = _tmp1_;
	if (_inner_error_ != NULL) {
		_g_free0 (element);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	_tmp2_ = gst_element_state_get_name (state);
	fprintf (stdout, "The state of %s is: %s\n", element, _tmp2_);
	result = TRUE;
	_g_free0 (element);
	return result;
}


static gboolean _dynamic_PipelineSeek24 (DBusGProxy* self, gint64 param1, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "PipelineSeek", error, G_TYPE_INT64, param1, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


static gboolean gstd_cli_pipeline_seek (GstdCli* self, DBusGProxy* pipeline, gchar** args, int args_length1) {
	gboolean result = FALSE;
	gint _tmp0_;
	gint64 pos_ms;
	gboolean _tmp1_;
	gboolean ret;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pipeline != NULL, FALSE);
	if (args[1] == NULL) {
		fprintf (stdout, "Error:\nMissing argument.Execute:'help seek'\n");
		result = FALSE;
		return result;
	}
	_tmp0_ = atoi (args[1]);
	pos_ms = (gint64) _tmp0_;
	pos_ms = pos_ms * ((gint64) 1000000);
	_tmp1_ = _dynamic_PipelineSeek24 (pipeline, pos_ms, &_inner_error_);
	ret = _tmp1_;
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	if (!ret) {
		fprintf (stderr, "Error:\nSeek fail: Media type not seekable\n");
		result = FALSE;
		return result;
	}
	fprintf (stdout, "Ok.\n");
	result = ret;
	return result;
}


static gboolean _dynamic_PipelineSkip25 (DBusGProxy* self, gint64 param1, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "PipelineSkip", error, G_TYPE_INT64, param1, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


static gboolean gstd_cli_pipeline_skip (GstdCli* self, DBusGProxy* pipeline, gchar** args, int args_length1) {
	gboolean result = FALSE;
	gint _tmp0_;
	gint64 period_ms;
	gboolean _tmp1_;
	gboolean ret;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pipeline != NULL, FALSE);
	if (args[1] == NULL) {
		fprintf (stdout, "Error:\nMissing argument.Execute:'help skip'\n");
		result = FALSE;
		return result;
	}
	_tmp0_ = atoi (args[1]);
	period_ms = (gint64) _tmp0_;
	period_ms = period_ms * ((gint64) 1000000);
	_tmp1_ = _dynamic_PipelineSkip25 (pipeline, period_ms, &_inner_error_);
	ret = _tmp1_;
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	if (!ret) {
		fprintf (stderr, "Error:\nSkip fail: Media type not seekable\n");
		result = FALSE;
		return result;
	}
	fprintf (stdout, "Ok.\n");
	result = ret;
	return result;
}


static gboolean _dynamic_PipelineSpeed26 (DBusGProxy* self, gdouble param1, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "PipelineSpeed", error, G_TYPE_DOUBLE, param1, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


static gboolean gstd_cli_pipeline_speed (GstdCli* self, DBusGProxy* pipeline, gchar** args, int args_length1) {
	gboolean result = FALSE;
	gdouble _tmp0_;
	gdouble rate;
	gboolean _tmp1_;
	gboolean ret;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pipeline != NULL, FALSE);
	if (args[1] == NULL) {
		fprintf (stdout, "Error:\nMissing argument.Execute:'help speed'\n");
		result = FALSE;
		return result;
	}
	_tmp0_ = g_ascii_strtod (args[1], NULL);
	rate = _tmp0_;
	_tmp1_ = _dynamic_PipelineSpeed26 (pipeline, rate, &_inner_error_);
	ret = _tmp1_;
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	if (!ret) {
		fprintf (stderr, "Error:\nSpeed could not be set\n");
		result = FALSE;
		return result;
	}
	fprintf (stdout, "Ok.\n");
	result = ret;
	return result;
}


static void _dynamic_PipelineSendEoS27 (DBusGProxy* self, GError** error) {
	dbus_g_proxy_call (self, "PipelineSendEoS", error, G_TYPE_INVALID, G_TYPE_INVALID);
	if (*error) {
		return;
	}
}


static gboolean gstd_cli_pipeline_send_eos (GstdCli* self, DBusGProxy* pipeline, gchar** args, int args_length1) {
	gboolean result = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pipeline != NULL, FALSE);
	_dynamic_PipelineSendEoS27 (pipeline, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	fprintf (stdout, "Ok.\n");
	result = TRUE;
	return result;
}


static gint gstd_cli_string_to_state (GstdCli* self, const gchar* state) {
	gint result = 0;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	GQuark _tmp2_;
	static GQuark _tmp2__label0 = 0;
	static GQuark _tmp2__label1 = 0;
	static GQuark _tmp2__label2 = 0;
	static GQuark _tmp2__label3 = 0;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (state != NULL, 0);
	_tmp0_ = g_utf8_strdown (state, (gssize) (-1));
	_tmp1_ = _tmp0_;
	_tmp2_ = (NULL == _tmp1_) ? 0 : g_quark_from_string (_tmp1_);
	g_free (_tmp1_);
	if (_tmp2_ == ((0 != _tmp2__label0) ? _tmp2__label0 : (_tmp2__label0 = g_quark_from_static_string ("null")))) {
		switch (0) {
			default:
			{
				result = 1;
				return result;
			}
		}
	} else if (_tmp2_ == ((0 != _tmp2__label1) ? _tmp2__label1 : (_tmp2__label1 = g_quark_from_static_string ("ready")))) {
		switch (0) {
			default:
			{
				result = 2;
				return result;
			}
		}
	} else if (_tmp2_ == ((0 != _tmp2__label2) ? _tmp2__label2 : (_tmp2__label2 = g_quark_from_static_string ("paused")))) {
		switch (0) {
			default:
			{
				result = 3;
				return result;
			}
		}
	} else if (_tmp2_ == ((0 != _tmp2__label3) ? _tmp2__label3 : (_tmp2__label3 = g_quark_from_static_string ("playing")))) {
		switch (0) {
			default:
			{
				result = 4;
				return result;
			}
		}
	} else {
		switch (0) {
			default:
			{
				fprintf (stderr, "Error:\nState not supported: %s\n", state);
				result = 0;
				return result;
			}
		}
	}
}


static gboolean _dynamic_ElementSetState28 (DBusGProxy* self, const gchar* param1, gint param2, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "ElementSetState", error, G_TYPE_STRING, param1, G_TYPE_INT, param2, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


static gboolean gstd_cli_element_set_state (GstdCli* self, DBusGProxy* pipeline, gchar** args, int args_length1) {
	gboolean result = FALSE;
	gboolean ret = FALSE;
	gint state = 0;
	gboolean _tmp0_ = FALSE;
	gchar* _tmp1_;
	gchar* element;
	gint _tmp2_;
	gboolean _tmp3_;
	gboolean _tmp4_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pipeline != NULL, FALSE);
	if (args[1] == NULL) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = args[2] == NULL;
	}
	if (_tmp0_) {
		fprintf (stdout, "Error:\nMissing argument.  Execute:'help element-set-state'\n");
		result = FALSE;
		return result;
	}
	_tmp1_ = g_strdup (args[1]);
	element = _tmp1_;
	_tmp2_ = gstd_cli_string_to_state (self, args[2]);
	state = _tmp2_;
	_tmp3_ = _dynamic_ElementSetState28 (pipeline, element, state, &_inner_error_);
	_tmp4_ = _tmp3_;
	if (_inner_error_ != NULL) {
		_g_free0 (element);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	ret = _tmp4_;
	if (!ret) {
		fprintf (stderr, "Error:\nFailed to set element state: %s\n", args[2]);
		result = FALSE;
		_g_free0 (element);
		return result;
	}
	fprintf (stdout, "Ok.\n");
	result = ret;
	_g_free0 (element);
	return result;
}


static gboolean _dynamic_ElementAsyncSetState29 (DBusGProxy* self, const gchar* param1, gint param2, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "ElementAsyncSetState", error, G_TYPE_STRING, param1, G_TYPE_INT, param2, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


static gboolean gstd_cli_element_async_set_state (GstdCli* self, DBusGProxy* pipeline, gchar** args, int args_length1) {
	gboolean result = FALSE;
	gboolean ret = FALSE;
	gint state = 0;
	gboolean _tmp0_ = FALSE;
	gchar* _tmp1_;
	gchar* element;
	gint _tmp2_;
	gboolean _tmp3_;
	gboolean _tmp4_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pipeline != NULL, FALSE);
	if (args[1] == NULL) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = args[2] == NULL;
	}
	if (_tmp0_) {
		fprintf (stdout, "Error:\nMissing argument.  Execute:'help element-set-state'\n");
		result = FALSE;
		return result;
	}
	_tmp1_ = g_strdup (args[1]);
	element = _tmp1_;
	_tmp2_ = gstd_cli_string_to_state (self, args[2]);
	state = _tmp2_;
	_tmp3_ = _dynamic_ElementAsyncSetState29 (pipeline, element, state, &_inner_error_);
	_tmp4_ = _tmp3_;
	if (_inner_error_ != NULL) {
		_g_free0 (element);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	ret = _tmp4_;
	if (!ret) {
		fprintf (stderr, "Error:\nFailed to set element async state: %s\n", args[2]);
		result = FALSE;
		_g_free0 (element);
		return result;
	}
	fprintf (stdout, "Ok.\n");
	result = ret;
	_g_free0 (element);
	return result;
}


static gchar string_get (const gchar* self, glong index) {
	gchar result = '\0';
	g_return_val_if_fail (self != NULL, '\0');
	result = ((gchar*) self)[index];
	return result;
}


static gboolean gstd_cli_set_active (GstdCli* self, const gchar* path) {
	gboolean result = FALSE;
	gchar* new_active;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (path != NULL, FALSE);
	new_active = NULL;
	if (self->priv->cli_enable) {
		gchar _tmp0_;
		gboolean _tmp4_;
		gchar* _tmp5_;
		gchar* _tmp6_;
		_tmp0_ = string_get (path, (glong) 0);
		if (_tmp0_ != '/') {
			gchar* _tmp1_;
			_tmp1_ = g_strconcat ("/com/ridgerun/gstreamer/gstd/pipe", path, NULL);
			_g_free0 (new_active);
			new_active = _tmp1_;
		} else {
			gchar* _tmp2_;
			gchar* _tmp3_;
			_tmp2_ = g_strdup (path);
			_tmp3_ = _tmp2_;
			_g_free0 (new_active);
			new_active = _tmp3_;
		}
		_tmp4_ = gstd_cli_create_proxypipe (self, new_active);
		if (!_tmp4_) {
			gstd_cli_create_proxypipe (self, self->priv->active_pipe);
			fprintf (stderr, "Error:\nInvalid path\n");
			result = FALSE;
			_g_free0 (new_active);
			return result;
		}
		_tmp5_ = g_strdup (new_active);
		_tmp6_ = _tmp5_;
		_g_free0 (self->priv->active_pipe);
		self->priv->active_pipe = _tmp6_;
		fprintf (stdout, "Ok.\n");
		result = TRUE;
		_g_free0 (new_active);
		return result;
	} else {
		fprintf (stderr, "%s", "Error:\nThis command is exclusive for" " interactive console mode\n");
		result = FALSE;
		_g_free0 (new_active);
		return result;
	}
	_g_free0 (new_active);
}


static gboolean gstd_cli_get_active (GstdCli* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	if (self->priv->cli_enable) {
		if (self->priv->active_pipe != NULL) {
			fprintf (stdout, "The active pipeline path is: %s\n", self->priv->active_pipe);
			fprintf (stdout, "Ok.\n");
			result = TRUE;
			return result;
		} else {
			fprintf (stderr, "Error:\nThere is no active pipeline\n");
			result = FALSE;
			return result;
		}
	} else {
		fprintf (stderr, "%s", "Error:\nCommand used only on the interactive" " console mode\n");
		result = FALSE;
		return result;
	}
}


static gchar** _dynamic_List30 (DBusGProxy* self, int* result_length1, GError** error) {
	gchar** result;
	dbus_g_proxy_call (self, "List", error, G_TYPE_INVALID, G_TYPE_STRV, &result, G_TYPE_INVALID);
	if (*error) {
		return NULL;
	}
	*result_length1 = g_strv_length (result);
	return result;
}


static gboolean gstd_cli_pipeline_list (GstdCli* self) {
	gboolean result = FALSE;
	gint _tmp0_;
	gchar** _tmp1_ = NULL;
	gint paths_length1;
	gint _paths_size_;
	gchar** _tmp2_;
	gchar** paths;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp1_ = _dynamic_List30 (self->priv->factory, &_tmp0_, &_inner_error_);
	_tmp2_ = _tmp1_;
	paths_length1 = _tmp0_;
	_paths_size_ = paths_length1;
	paths = _tmp2_;
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	if (paths_length1 == 0) {
		fprintf (stdout, "There are no pipelines on factory!\n");
		result = TRUE;
		paths = (_vala_array_free (paths, paths_length1, (GDestroyNotify) g_free), NULL);
		return result;
	}
	fprintf (stdout, "The actual pipelines are:\n");
	{
		gint index;
		index = 0;
		{
			gboolean _tmp3_;
			_tmp3_ = TRUE;
			while (TRUE) {
				if (!_tmp3_) {
					index = index + 1;
				}
				_tmp3_ = FALSE;
				if (!(index < paths_length1)) {
					break;
				}
				fprintf (stdout, "  %i. %s\n", index + 1, paths[index]);
			}
		}
	}
	fprintf (stdout, "Ok.\n");
	result = TRUE;
	paths = (_vala_array_free (paths, paths_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


static gboolean gstd_cli_shell (GstdCli* self, const gchar* command) {
	gboolean result = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (command != NULL, FALSE);
	g_spawn_command_line_sync (command, NULL, NULL, NULL, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_SPAWN_ERROR) {
			goto __catch7_g_spawn_error;
		}
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = TRUE;
	return result;
	goto __finally7;
	__catch7_g_spawn_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stderr, "Fail to execute command:%s", e->message);
		_g_error_free0 (e);
	}
	__finally7:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = FALSE;
	return result;
}


static gboolean gstd_cli_set_strict (GstdCli* self, gchar** args, int args_length1) {
	gboolean result = FALSE;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gboolean _tmp2_;
	g_return_val_if_fail (self != NULL, FALSE);
	if (args_length1 < 2) {
		fprintf (stdout, "Set strict failed because of missing argument\n");
		result = FALSE;
		return result;
	}
	_tmp0_ = g_utf8_strdown (args[1], (gssize) (-1));
	_tmp1_ = _tmp0_;
	if ((_tmp2_ = g_strcmp0 (_tmp1_, "on") == 0, _g_free0 (_tmp1_), _tmp2_)) {
		gstd_cli_isStrict = TRUE;
	} else {
		gchar* _tmp3_ = NULL;
		gchar* _tmp4_;
		gboolean _tmp5_;
		_tmp3_ = g_utf8_strdown (args[1], (gssize) (-1));
		_tmp4_ = _tmp3_;
		if ((_tmp5_ = g_strcmp0 (_tmp4_, "off") == 0, _g_free0 (_tmp4_), _tmp5_)) {
			gstd_cli_isStrict = FALSE;
		} else {
			fprintf (stdout, "Set strict failed because of unexpected argument '%s'\n", args[1]);
			result = FALSE;
			return result;
		}
	}
	fprintf (stdout, "Set strict = '%s'\n", args[1]);
	result = TRUE;
	return result;
}


static gboolean _dynamic_PipelineIsInitialized31 (DBusGProxy* self, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "PipelineIsInitialized", error, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


gboolean gstd_cli_create_proxypipe (GstdCli* self, const gchar* object_path) {
	gboolean result = FALSE;
	DBusGProxy* _tmp0_ = NULL;
	DBusGProxy* _tmp1_;
	gboolean _tmp2_;
	gboolean _tmp3_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	if (object_path == NULL) {
		result = FALSE;
		return result;
	}
	_tmp0_ = dbus_g_proxy_new_for_name (self->priv->conn, "com.ridgerun.gstreamer.gstd", object_path, "com.ridgerun.gstreamer.gstd.PipelineInterface");
	_tmp1_ = _tmp0_;
	_g_object_unref0 (self->priv->pipeline);
	self->priv->pipeline = _tmp1_;
	_tmp2_ = _dynamic_PipelineIsInitialized31 (self->priv->pipeline, &_inner_error_);
	_tmp3_ = _tmp2_;
	if (_inner_error_ != NULL) {
		goto __catch8_g_error;
	}
	result = _tmp3_;
	return result;
	goto __finally8;
	__catch8_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		result = FALSE;
		_g_error_free0 (e);
		return result;
	}
	__finally8:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return FALSE;
}


static void gstd_cli_parse_options (GstdCli* self, gchar** args, int args_length1) {
	gchar** _tmp0_;
	gchar* _tmp1_;
	GOptionContext* _tmp2_ = NULL;
	GOptionContext* opt;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp8_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	gstd_cli__signals = FALSE;
	_tmp0_ = NULL;
	gstd_cli__remaining_args = (_vala_array_free (gstd_cli__remaining_args, _vala_array_length (gstd_cli__remaining_args), (GDestroyNotify) g_free), NULL);
	gstd_cli__remaining_args = _tmp0_;
	_tmp1_ = NULL;
	_g_free0 (gstd_cli_obj_path);
	gstd_cli_obj_path = _tmp1_;
	_tmp2_ = g_option_context_new ("\n  For a list of [COMMANDS...], type: gst-client help");
	opt = _tmp2_;
	g_option_context_set_help_enabled (opt, TRUE);
	g_option_context_add_main_entries (opt, GSTD_CLI_options, NULL);
	g_option_context_parse (opt, &args_length1, &args, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_OPTION_ERROR) {
			goto __catch9_g_option_error;
		}
		_g_option_context_free0 (opt);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	if (gstd_cli_obj_path != NULL) {
		gint _tmp5_;
		_tmp5_ = strlen (gstd_cli_obj_path);
		_tmp4_ = _tmp5_ >= 1;
	} else {
		_tmp4_ = FALSE;
	}
	if (_tmp4_) {
		gchar _tmp6_;
		_tmp6_ = string_get (gstd_cli_obj_path, (glong) 0);
		_tmp3_ = _tmp6_ != '/';
	} else {
		_tmp3_ = FALSE;
	}
	if (_tmp3_) {
		gchar* _tmp7_;
		_tmp7_ = g_strconcat ("/com/ridgerun/gstreamer/gstd/pipe", gstd_cli_obj_path, NULL);
		_g_free0 (gstd_cli_obj_path);
		gstd_cli_obj_path = _tmp7_;
	}
	goto __finally9;
	__catch9_g_option_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stderr, "OptionError failure: %s\n", e->message);
		_g_error_free0 (e);
	}
	__finally9:
	if (_inner_error_ != NULL) {
		_g_option_context_free0 (opt);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	if (self->priv->cli_enable) {
		_tmp8_ = gstd_cli_obj_path != NULL;
	} else {
		_tmp8_ = FALSE;
	}
	if (_tmp8_) {
		gchar* _tmp9_;
		gchar* _tmp10_;
		_tmp9_ = g_strdup (gstd_cli_obj_path);
		_tmp10_ = _tmp9_;
		_g_free0 (self->priv->active_pipe);
		self->priv->active_pipe = _tmp10_;
	}
	_g_option_context_free0 (opt);
}


static gboolean _dynamic_DestroyAll32 (DBusGProxy* self, GError** error) {
	gboolean result;
	dbus_g_proxy_call (self, "DestroyAll", error, G_TYPE_INVALID, G_TYPE_BOOLEAN, &result, G_TYPE_INVALID);
	if (*error) {
		return FALSE;
	}
	return result;
}


gboolean gstd_cli_parse_cmd (GstdCli* self, gchar** args, int args_length1, GError** error) {
	gboolean result = FALSE;
	gboolean _tmp0_;
	gboolean success;
	gchar* _tmp35_ = NULL;
	gchar* _tmp36_;
	GQuark _tmp37_;
	static GQuark _tmp37__label0 = 0;
	static GQuark _tmp37__label1 = 0;
	static GQuark _tmp37__label2 = 0;
	static GQuark _tmp37__label3 = 0;
	static GQuark _tmp37__label4 = 0;
	static GQuark _tmp37__label5 = 0;
	static GQuark _tmp37__label6 = 0;
	static GQuark _tmp37__label7 = 0;
	static GQuark _tmp37__label8 = 0;
	static GQuark _tmp37__label9 = 0;
	static GQuark _tmp37__label10 = 0;
	static GQuark _tmp37__label11 = 0;
	static GQuark _tmp37__label12 = 0;
	static GQuark _tmp37__label13 = 0;
	static GQuark _tmp37__label14 = 0;
	static GQuark _tmp37__label15 = 0;
	static GQuark _tmp37__label16 = 0;
	static GQuark _tmp37__label17 = 0;
	static GQuark _tmp37__label18 = 0;
	static GQuark _tmp37__label19 = 0;
	static GQuark _tmp37__label20 = 0;
	static GQuark _tmp37__label21 = 0;
	static GQuark _tmp37__label22 = 0;
	static GQuark _tmp37__label23 = 0;
	static GQuark _tmp37__label24 = 0;
	static GQuark _tmp37__label25 = 0;
	static GQuark _tmp37__label26 = 0;
	static GQuark _tmp37__label27 = 0;
	static GQuark _tmp37__label28 = 0;
	static GQuark _tmp37__label29 = 0;
	static GQuark _tmp37__label30 = 0;
	static GQuark _tmp37__label31 = 0;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = gstd_cli_create_proxypipe (self, gstd_cli_obj_path);
	success = _tmp0_;
	if (!success) {
		gboolean _tmp1_ = FALSE;
		gboolean _tmp2_ = FALSE;
		gboolean _tmp3_ = FALSE;
		gboolean _tmp4_ = FALSE;
		gboolean _tmp5_ = FALSE;
		gboolean _tmp6_ = FALSE;
		gboolean _tmp7_ = FALSE;
		gboolean _tmp8_ = FALSE;
		gboolean _tmp9_ = FALSE;
		gboolean _tmp10_ = FALSE;
		gboolean _tmp11_ = FALSE;
		gchar* _tmp12_ = NULL;
		gchar* _tmp13_;
		gboolean _tmp14_;
		_tmp12_ = g_utf8_strdown (args[0], (gssize) (-1));
		_tmp13_ = _tmp12_;
		if ((_tmp14_ = g_strcmp0 (_tmp13_, "create") != 0, _g_free0 (_tmp13_), _tmp14_)) {
			gchar* _tmp15_ = NULL;
			gchar* _tmp16_;
			_tmp15_ = g_utf8_strdown (args[0], (gssize) (-1));
			_tmp16_ = _tmp15_;
			_tmp11_ = g_strcmp0 (_tmp16_, "help") != 0;
			_g_free0 (_tmp16_);
		} else {
			_tmp11_ = FALSE;
		}
		if (_tmp11_) {
			gchar* _tmp17_ = NULL;
			gchar* _tmp18_;
			_tmp17_ = g_utf8_strdown (args[0], (gssize) (-1));
			_tmp18_ = _tmp17_;
			_tmp10_ = g_strcmp0 (_tmp18_, "active") != 0;
			_g_free0 (_tmp18_);
		} else {
			_tmp10_ = FALSE;
		}
		if (_tmp10_) {
			gchar* _tmp19_ = NULL;
			gchar* _tmp20_;
			_tmp19_ = g_utf8_strdown (args[0], (gssize) (-1));
			_tmp20_ = _tmp19_;
			_tmp9_ = g_strcmp0 (_tmp20_, "quit") != 0;
			_g_free0 (_tmp20_);
		} else {
			_tmp9_ = FALSE;
		}
		if (_tmp9_) {
			gchar* _tmp21_ = NULL;
			gchar* _tmp22_;
			_tmp21_ = g_utf8_strdown (args[0], (gssize) (-1));
			_tmp22_ = _tmp21_;
			_tmp8_ = g_strcmp0 (_tmp22_, "list-pipes") != 0;
			_g_free0 (_tmp22_);
		} else {
			_tmp8_ = FALSE;
		}
		if (_tmp8_) {
			gchar* _tmp23_ = NULL;
			gchar* _tmp24_;
			_tmp23_ = g_utf8_strdown (args[0], (gssize) (-1));
			_tmp24_ = _tmp23_;
			_tmp7_ = g_strcmp0 (_tmp24_, "ping") != 0;
			_g_free0 (_tmp24_);
		} else {
			_tmp7_ = FALSE;
		}
		if (_tmp7_) {
			gchar* _tmp25_ = NULL;
			gchar* _tmp26_;
			_tmp25_ = g_utf8_strdown (args[0], (gssize) (-1));
			_tmp26_ = _tmp25_;
			_tmp6_ = g_strcmp0 (_tmp26_, "ping-pipe") != 0;
			_g_free0 (_tmp26_);
		} else {
			_tmp6_ = FALSE;
		}
		if (_tmp6_) {
			gchar* _tmp27_ = NULL;
			gchar* _tmp28_;
			_tmp27_ = g_utf8_strdown (args[0], (gssize) (-1));
			_tmp28_ = _tmp27_;
			_tmp5_ = g_strcmp0 (_tmp28_, "exit") != 0;
			_g_free0 (_tmp28_);
		} else {
			_tmp5_ = FALSE;
		}
		if (_tmp5_) {
			gchar* _tmp29_ = NULL;
			gchar* _tmp30_;
			_tmp29_ = g_utf8_strdown (args[0], (gssize) (-1));
			_tmp30_ = _tmp29_;
			_tmp4_ = g_strcmp0 (_tmp30_, "sh") != 0;
			_g_free0 (_tmp30_);
		} else {
			_tmp4_ = FALSE;
		}
		if (_tmp4_) {
			gchar* _tmp31_ = NULL;
			gchar* _tmp32_;
			_tmp31_ = g_utf8_strdown (args[0], (gssize) (-1));
			_tmp32_ = _tmp31_;
			_tmp3_ = g_strcmp0 (_tmp32_, "strict") != 0;
			_g_free0 (_tmp32_);
		} else {
			_tmp3_ = FALSE;
		}
		if (_tmp3_) {
			gchar* _tmp33_ = NULL;
			gchar* _tmp34_;
			_tmp33_ = g_utf8_strdown (args[0], (gssize) (-1));
			_tmp34_ = _tmp33_;
			_tmp2_ = g_strcmp0 (_tmp34_, "destroy-all") != 0;
			_g_free0 (_tmp34_);
		} else {
			_tmp2_ = FALSE;
		}
		if (_tmp2_) {
			_tmp1_ = self->priv->active_pipe == NULL;
		} else {
			_tmp1_ = FALSE;
		}
		if (_tmp1_) {
			if (self->priv->cli_enable) {
				fprintf (stderr, "%s", "There is no active pipeline." "See \"active\" or \"create\" command\n");
			} else {
				fprintf (stderr, "Pipeline path was not specified\n");
			}
			result = FALSE;
			return result;
		}
	}
	_tmp35_ = g_utf8_strdown (args[0], (gssize) (-1));
	_tmp36_ = _tmp35_;
	_tmp37_ = (NULL == _tmp36_) ? 0 : g_quark_from_string (_tmp36_);
	g_free (_tmp36_);
	if (_tmp37_ == ((0 != _tmp37__label0) ? _tmp37__label0 : (_tmp37__label0 = g_quark_from_static_string ("create")))) {
		switch (0) {
			default:
			{
				gboolean _tmp44_;
				if (self->priv->cli_enable) {
					gint description_length1;
					gint _description_size_;
					gchar** description;
					gchar* _tmp38_ = NULL;
					gchar* _tmp39_;
					gchar** _tmp40_;
					gchar** _tmp41_ = NULL;
					gchar** _tmp42_;
					gboolean _tmp43_;
					description_length1 = 0;
					description = NULL;
					_tmp38_ = g_strjoinv (" ", args);
					_tmp39_ = _tmp38_;
					_tmp41_ = _tmp40_ = g_strsplit (_tmp39_, "\"", -1);
					_tmp42_ = _tmp41_;
					description = (_vala_array_free (description, description_length1, (GDestroyNotify) g_free), NULL);
					description_length1 = _vala_array_length (_tmp40_);
					_description_size_ = description_length1;
					description = _tmp42_;
					_g_free0 (_tmp39_);
					_tmp43_ = gstd_cli_pipeline_create (self, description[1]);
					result = _tmp43_;
					description = (_vala_array_free (description, description_length1, (GDestroyNotify) g_free), NULL);
					return result;
				}
				_tmp44_ = gstd_cli_pipeline_create (self, args[1]);
				result = _tmp44_;
				return result;
			}
		}
	} else if (_tmp37_ == ((0 != _tmp37__label1) ? _tmp37__label1 : (_tmp37__label1 = g_quark_from_static_string ("destroy")))) {
		switch (0) {
			default:
			{
				if (self->priv->cli_enable) {
					gboolean _tmp45_;
					gboolean ret;
					_tmp45_ = gstd_cli_pipeline_destroy (self, self->priv->active_pipe);
					ret = _tmp45_;
					if (ret) {
						gchar* _tmp46_;
						_tmp46_ = NULL;
						_g_free0 (self->priv->active_pipe);
						self->priv->active_pipe = _tmp46_;
						result = TRUE;
						return result;
					} else {
						result = FALSE;
						return result;
					}
				} else {
					gboolean _tmp47_;
					_tmp47_ = gstd_cli_pipeline_destroy (self, gstd_cli_obj_path);
					result = _tmp47_;
					return result;
				}
			}
		}
	} else if (_tmp37_ == ((0 != _tmp37__label2) ? _tmp37__label2 : (_tmp37__label2 = g_quark_from_static_string ("destroy-all")))) {
		switch (0) {
			default:
			{
				gchar* _tmp48_;
				gboolean _tmp49_;
				gboolean _tmp50_;
				if (self->priv->factory == NULL) {
					result = FALSE;
					return result;
				}
				_tmp48_ = NULL;
				_g_free0 (self->priv->active_pipe);
				self->priv->active_pipe = _tmp48_;
				_tmp49_ = _dynamic_DestroyAll32 (self->priv->factory, &_inner_error_);
				_tmp50_ = _tmp49_;
				if (_inner_error_ != NULL) {
					g_propagate_error (error, _inner_error_);
					return FALSE;
				}
				result = _tmp50_;
				return result;
			}
		}
	} else if (_tmp37_ == ((0 != _tmp37__label3) ? _tmp37__label3 : (_tmp37__label3 = g_quark_from_static_string ("play")))) {
		switch (0) {
			default:
			{
				gboolean _tmp51_;
				_tmp51_ = gstd_cli_pipeline_play (self, self->priv->pipeline, TRUE);
				result = _tmp51_;
				return result;
			}
		}
	} else if (_tmp37_ == ((0 != _tmp37__label4) ? _tmp37__label4 : (_tmp37__label4 = g_quark_from_static_string ("ready")))) {
		switch (0) {
			default:
			{
				gboolean _tmp52_;
				_tmp52_ = gstd_cli_pipeline_ready (self, self->priv->pipeline, TRUE);
				result = _tmp52_;
				return result;
			}
		}
	} else if (_tmp37_ == ((0 != _tmp37__label5) ? _tmp37__label5 : (_tmp37__label5 = g_quark_from_static_string ("pause")))) {
		switch (0) {
			default:
			{
				gboolean _tmp53_;
				_tmp53_ = gstd_cli_pipeline_pause (self, self->priv->pipeline, TRUE);
				result = _tmp53_;
				return result;
			}
		}
	} else if (_tmp37_ == ((0 != _tmp37__label6) ? _tmp37__label6 : (_tmp37__label6 = g_quark_from_static_string ("null")))) {
		switch (0) {
			default:
			{
				gboolean _tmp54_;
				_tmp54_ = gstd_cli_pipeline_null (self, self->priv->pipeline, TRUE);
				result = _tmp54_;
				return result;
			}
		}
	} else if (_tmp37_ == ((0 != _tmp37__label7) ? _tmp37__label7 : (_tmp37__label7 = g_quark_from_static_string ("aplay")))) {
		switch (0) {
			default:
			{
				gboolean _tmp55_;
				_tmp55_ = gstd_cli_pipeline_play (self, self->priv->pipeline, FALSE);
				result = _tmp55_;
				return result;
			}
		}
	} else if (_tmp37_ == ((0 != _tmp37__label8) ? _tmp37__label8 : (_tmp37__label8 = g_quark_from_static_string ("aready")))) {
		switch (0) {
			default:
			{
				gboolean _tmp56_;
				_tmp56_ = gstd_cli_pipeline_ready (self, self->priv->pipeline, FALSE);
				result = _tmp56_;
				return result;
			}
		}
	} else if (_tmp37_ == ((0 != _tmp37__label9) ? _tmp37__label9 : (_tmp37__label9 = g_quark_from_static_string ("apause")))) {
		switch (0) {
			default:
			{
				gboolean _tmp57_;
				_tmp57_ = gstd_cli_pipeline_pause (self, self->priv->pipeline, FALSE);
				result = _tmp57_;
				return result;
			}
		}
	} else if (_tmp37_ == ((0 != _tmp37__label10) ? _tmp37__label10 : (_tmp37__label10 = g_quark_from_static_string ("anull")))) {
		switch (0) {
			default:
			{
				gboolean _tmp58_;
				_tmp58_ = gstd_cli_pipeline_null (self, self->priv->pipeline, FALSE);
				result = _tmp58_;
				return result;
			}
		}
	} else if (_tmp37_ == ((0 != _tmp37__label11) ? _tmp37__label11 : (_tmp37__label11 = g_quark_from_static_string ("set")))) {
		switch (0) {
			default:
			{
				gboolean _tmp59_;
				_tmp59_ = gstd_cli_pipeline_set_property (self, self->priv->pipeline, args, args_length1);
				result = _tmp59_;
				return result;
			}
		}
	} else if (_tmp37_ == ((0 != _tmp37__label12) ? _tmp37__label12 : (_tmp37__label12 = g_quark_from_static_string ("get")))) {
		switch (0) {
			default:
			{
				gboolean _tmp60_;
				_tmp60_ = gstd_cli_pipeline_get_property (self, self->priv->pipeline, args, args_length1);
				result = _tmp60_;
				return result;
			}
		}
	} else if (_tmp37_ == ((0 != _tmp37__label13) ? _tmp37__label13 : (_tmp37__label13 = g_quark_from_static_string ("get-duration")))) {
		switch (0) {
			default:
			{
				gboolean _tmp61_;
				_tmp61_ = gstd_cli_pipeline_get_duration (self, self->priv->pipeline);
				result = _tmp61_;
				return result;
			}
		}
	} else if (_tmp37_ == ((0 != _tmp37__label14) ? _tmp37__label14 : (_tmp37__label14 = g_quark_from_static_string ("get-position")))) {
		switch (0) {
			default:
			{
				gboolean _tmp62_;
				_tmp62_ = gstd_cli_pipeline_get_position (self, self->priv->pipeline);
				result = _tmp62_;
				return result;
			}
		}
	} else if (_tmp37_ == ((0 != _tmp37__label15) ? _tmp37__label15 : (_tmp37__label15 = g_quark_from_static_string ("get-state")))) {
		switch (0) {
			default:
			{
				gboolean _tmp63_;
				_tmp63_ = gstd_cli_pipeline_get_state (self, self->priv->pipeline);
				result = _tmp63_;
				return result;
			}
		}
	} else if (_tmp37_ == ((0 != _tmp37__label16) ? _tmp37__label16 : (_tmp37__label16 = g_quark_from_static_string ("get-elem-state")))) {
		switch (0) {
			default:
			{
				gboolean _tmp64_;
				_tmp64_ = gstd_cli_element_get_state (self, self->priv->pipeline, args, args_length1);
				result = _tmp64_;
				return result;
			}
		}
	} else if (_tmp37_ == ((0 != _tmp37__label17) ? _tmp37__label17 : (_tmp37__label17 = g_quark_from_static_string ("sh")))) {
		switch (0) {
			default:
			{
				gint command_length1;
				gint _command_size_;
				gchar** command;
				gchar* _tmp65_ = NULL;
				gchar* _tmp66_;
				gchar** _tmp67_;
				gchar** _tmp68_ = NULL;
				gchar** _tmp69_;
				gboolean _tmp70_;
				command_length1 = 0;
				command = NULL;
				_tmp65_ = g_strjoinv (" ", args);
				_tmp66_ = _tmp65_;
				_tmp68_ = _tmp67_ = g_strsplit (_tmp66_, "\"", -1);
				_tmp69_ = _tmp68_;
				command = (_vala_array_free (command, command_length1, (GDestroyNotify) g_free), NULL);
				command_length1 = _vala_array_length (_tmp67_);
				_command_size_ = command_length1;
				command = _tmp69_;
				_g_free0 (_tmp66_);
				_tmp70_ = gstd_cli_shell (self, command[1]);
				result = _tmp70_;
				command = (_vala_array_free (command, command_length1, (GDestroyNotify) g_free), NULL);
				return result;
			}
		}
	} else if (_tmp37_ == ((0 != _tmp37__label18) ? _tmp37__label18 : (_tmp37__label18 = g_quark_from_static_string ("seek")))) {
		switch (0) {
			default:
			{
				gboolean _tmp71_;
				_tmp71_ = gstd_cli_pipeline_seek (self, self->priv->pipeline, args, args_length1);
				result = _tmp71_;
				return result;
			}
		}
	} else if (_tmp37_ == ((0 != _tmp37__label19) ? _tmp37__label19 : (_tmp37__label19 = g_quark_from_static_string ("skip")))) {
		switch (0) {
			default:
			{
				gboolean _tmp72_;
				_tmp72_ = gstd_cli_pipeline_skip (self, self->priv->pipeline, args, args_length1);
				result = _tmp72_;
				return result;
			}
		}
	} else if (_tmp37_ == ((0 != _tmp37__label20) ? _tmp37__label20 : (_tmp37__label20 = g_quark_from_static_string ("speed")))) {
		switch (0) {
			default:
			{
				gboolean _tmp73_;
				_tmp73_ = gstd_cli_pipeline_speed (self, self->priv->pipeline, args, args_length1);
				result = _tmp73_;
				return result;
			}
		}
	} else if (_tmp37_ == ((0 != _tmp37__label21) ? _tmp37__label21 : (_tmp37__label21 = g_quark_from_static_string ("send-eos")))) {
		switch (0) {
			default:
			{
				gboolean _tmp74_;
				_tmp74_ = gstd_cli_pipeline_send_eos (self, self->priv->pipeline, args, args_length1);
				result = _tmp74_;
				return result;
			}
		}
	} else if (_tmp37_ == ((0 != _tmp37__label22) ? _tmp37__label22 : (_tmp37__label22 = g_quark_from_static_string ("list-pipes")))) {
		switch (0) {
			default:
			{
				gboolean _tmp75_;
				_tmp75_ = gstd_cli_pipeline_list (self);
				result = _tmp75_;
				return result;
			}
		}
	} else if (_tmp37_ == ((0 != _tmp37__label23) ? _tmp37__label23 : (_tmp37__label23 = g_quark_from_static_string ("ping")))) {
		switch (0) {
			default:
			{
				gboolean _tmp76_;
				_tmp76_ = gstd_cli_gstd_ping (self);
				result = _tmp76_;
				return result;
			}
		}
	} else if (_tmp37_ == ((0 != _tmp37__label24) ? _tmp37__label24 : (_tmp37__label24 = g_quark_from_static_string ("ping-pipe")))) {
		switch (0) {
			default:
			{
				gboolean _tmp77_;
				_tmp77_ = gstd_cli_pipeline_ping (self);
				result = _tmp77_;
				return result;
			}
		}
	} else if (_tmp37_ == ((0 != _tmp37__label25) ? _tmp37__label25 : (_tmp37__label25 = g_quark_from_static_string ("active")))) {
		switch (0) {
			default:
			{
				if (args[1] == NULL) {
					gboolean _tmp78_;
					_tmp78_ = gstd_cli_get_active (self);
					result = _tmp78_;
					return result;
				} else {
					gboolean _tmp79_;
					_tmp79_ = gstd_cli_set_active (self, args[1]);
					result = _tmp79_;
					return result;
				}
			}
		}
	} else if (_tmp37_ == ((0 != _tmp37__label26) ? _tmp37__label26 : (_tmp37__label26 = g_quark_from_static_string ("element-set-state")))) {
		switch (0) {
			default:
			{
				gboolean _tmp80_;
				_tmp80_ = gstd_cli_element_set_state (self, self->priv->pipeline, args, args_length1);
				result = _tmp80_;
				return result;
			}
		}
	} else if (_tmp37_ == ((0 != _tmp37__label27) ? _tmp37__label27 : (_tmp37__label27 = g_quark_from_static_string ("element-async-set-state")))) {
		switch (0) {
			default:
			{
				gboolean _tmp81_;
				_tmp81_ = gstd_cli_element_async_set_state (self, self->priv->pipeline, args, args_length1);
				result = _tmp81_;
				return result;
			}
		}
	} else if (_tmp37_ == ((0 != _tmp37__label28) ? _tmp37__label28 : (_tmp37__label28 = g_quark_from_static_string ("quit")))) {
		switch (0) {
			default:
			{
				self->priv->cli_enable = FALSE;
				result = TRUE;
				return result;
			}
		}
	} else if (_tmp37_ == ((0 != _tmp37__label29) ? _tmp37__label29 : (_tmp37__label29 = g_quark_from_static_string ("exit")))) {
		switch (0) {
			default:
			{
				self->priv->cli_enable = FALSE;
				result = TRUE;
				return result;
			}
		}
	} else if (_tmp37_ == ((0 != _tmp37__label30) ? _tmp37__label30 : (_tmp37__label30 = g_quark_from_static_string ("strict")))) {
		switch (0) {
			default:
			{
				gboolean _tmp82_;
				_tmp82_ = gstd_cli_set_strict (self, args, args_length1);
				result = _tmp82_;
				return result;
			}
		}
	} else if (_tmp37_ == ((0 != _tmp37__label31) ? _tmp37__label31 : (_tmp37__label31 = g_quark_from_static_string ("help")))) {
		switch (0) {
			default:
			{
				gint id;
				id = 0;
				if (args_length1 > 1) {
					while (TRUE) {
						if (!(self->priv->cmds[(id * self->priv->cmds_length2) + 0] != NULL)) {
							break;
						}
						if (g_strcmp0 (self->priv->cmds[(id * self->priv->cmds_length2) + 0], args[1]) == 0) {
							fprintf (stdout, "Command: %s\n", args[1]);
							fprintf (stdout, "Description:\t%s\n", self->priv->cmds[(id * self->priv->cmds_length2) + 2]);
							fprintf (stdout, "Syntax: %s\n", self->priv->cmds[(id * self->priv->cmds_length2) + 1]);
							result = TRUE;
							return result;
						}
						id++;
					}
					fprintf (stdout, "Unknown command: %s\n", args[1]);
					result = FALSE;
					return result;
				} else {
					fprintf (stdout, "%s", "Request the syntax of an specific command with " "\"help <command>\".\n" "This is the list of supported commands:\n");
					while (TRUE) {
						const gchar* _tmp83_;
						gint _tmp84_;
						if (!(self->priv->cmds[(id * self->priv->cmds_length2) + 0] != NULL)) {
							break;
						}
						_tmp83_ = NULL;
						_tmp84_ = strlen (self->priv->cmds[(id * self->priv->cmds_length2) + 0]);
						if (_tmp84_ < 6) {
							_tmp83_ = "\t\t";
						} else {
							_tmp83_ = "\t";
						}
						fprintf (stdout, " %s:%s%s\n", self->priv->cmds[(id * self->priv->cmds_length2) + 0], _tmp83_, self->priv->cmds[(id * self->priv->cmds_length2) + 2]);
						id++;
					}
					fprintf (stdout, "\n");
				}
				break;
			}
		}
	} else {
		switch (0) {
			default:
			{
				fprintf (stderr, "Unkown command:%s\n", args[0]);
				result = FALSE;
				return result;
			}
		}
	}
	result = TRUE;
	return result;
}


static gchar* __readline (const gchar* prompt) {
	gchar* result = NULL;
	void* _tmp0_ = NULL;
	void* cstr;
	gchar* _tmp1_ = NULL;
	gchar* str;
	_tmp0_ = readline (prompt);
	cstr = _tmp0_;
	if (cstr == NULL) {
		result = NULL;
		return result;
	}
	_tmp1_ = g_strdup ((const gchar*) cstr);
	str = _tmp1_;
	free (cstr);
	result = str;
	return result;
}


static gchar* string_strip (const gchar* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _result_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	g_strstrip (_result_);
	result = _result_;
	return result;
}


gboolean gstd_cli_cli (GstdCli* self, GError** error) {
	gboolean result = FALSE;
	gint args_length1;
	gint _args_size_;
	gchar** args;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gchar* home;
	gchar* _tmp2_;
	gchar* _tmp16_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	args_length1 = 0;
	args = NULL;
	_tmp0_ = g_getenv ("HOME");
	_tmp1_ = g_strdup (_tmp0_);
	home = _tmp1_;
	_tmp2_ = g_strconcat (home, "/.gst-client_history", NULL);
	read_history (_tmp2_);
	_g_free0 (_tmp2_);
	while (TRUE) {
		const gchar* _tmp3_;
		gchar* _tmp4_ = NULL;
		gchar* cmd_line;
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_;
		gchar** _tmp7_;
		gchar** _tmp8_ = NULL;
		gchar** _tmp9_;
		gboolean _tmp10_ = FALSE;
		_tmp3_ = NULL;
		if (gstd_cli_isInteractive) {
			_tmp3_ = "gst-client$ ";
		} else {
			_tmp3_ = "";
		}
		_tmp4_ = __readline (_tmp3_);
		cmd_line = _tmp4_;
		if (cmd_line == NULL) {
			_g_free0 (cmd_line);
			break;
		}
		add_history (cmd_line);
		_tmp5_ = string_strip (cmd_line);
		_tmp6_ = _tmp5_;
		_g_free0 (_tmp6_);
		_tmp8_ = _tmp7_ = g_strsplit (cmd_line, " ", -1);
		_tmp9_ = _tmp8_;
		args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
		args_length1 = _vala_array_length (_tmp7_);
		_args_size_ = args_length1;
		args = _tmp9_;
		if (args[0] != NULL) {
			gboolean _tmp11_ = FALSE;
			gint _tmp12_;
			_tmp12_ = strlen (cmd_line);
			if (_tmp12_ >= 1) {
				gchar _tmp13_;
				_tmp13_ = string_get (cmd_line, (glong) 0);
				_tmp11_ = _tmp13_ == '#';
			} else {
				_tmp11_ = FALSE;
			}
			_tmp10_ = !_tmp11_;
		} else {
			_tmp10_ = FALSE;
		}
		if (_tmp10_) {
			gboolean _tmp14_;
			gboolean _result_;
			gboolean _tmp15_ = FALSE;
			_tmp14_ = gstd_cli_parse_cmd (self, args, args_length1, &_inner_error_);
			_result_ = _tmp14_;
			if (_inner_error_ != NULL) {
				g_propagate_error (error, _inner_error_);
				_g_free0 (cmd_line);
				_g_free0 (home);
				args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
				return FALSE;
			}
			if (!_result_) {
				_tmp15_ = gstd_cli_isStrict;
			} else {
				_tmp15_ = FALSE;
			}
			if (_tmp15_) {
				result = FALSE;
				_g_free0 (cmd_line);
				_g_free0 (home);
				args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
				return result;
			}
		}
		if (!self->priv->cli_enable) {
			_g_free0 (cmd_line);
			break;
		}
		_g_free0 (cmd_line);
	}
	_tmp16_ = g_strconcat (home, "/.gst-client_history", NULL);
	write_history (_tmp16_);
	_g_free0 (_tmp16_);
	result = TRUE;
	_g_free0 (home);
	args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


gboolean gstd_cli_parse (GstdCli* self, gchar** remainingArgs, int remainingArgs_length1, GError** error) {
	gboolean result = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	if (gstd_cli_isInteractive) {
		if (remainingArgs_length1 > 0) {
			gboolean _tmp0_;
			gboolean _tmp1_;
			fprintf (stdout, "Parse single command interactive:\n");
			_tmp0_ = gstd_cli_parse_cmd (self, remainingArgs, remainingArgs_length1, &_inner_error_);
			_tmp1_ = _tmp0_;
			if (_inner_error_ != NULL) {
				g_propagate_error (error, _inner_error_);
				return FALSE;
			}
			result = _tmp1_;
			return result;
		} else {
			gboolean _tmp2_;
			gboolean _tmp3_;
			fprintf (stdout, "Interactive console execution:\n");
			self->priv->cli_enable = TRUE;
			_tmp2_ = gstd_cli_cli (self, &_inner_error_);
			_tmp3_ = _tmp2_;
			if (_inner_error_ != NULL) {
				g_propagate_error (error, _inner_error_);
				return FALSE;
			}
			result = _tmp3_;
			return result;
		}
	} else {
		FILE* _tmp4_ = NULL;
		FILE* _tmp5_;
		FILE* _tmp6_ = NULL;
		FILE* _tmp7_;
		gboolean _tmp8_;
		gboolean _tmp9_;
		g_print ("Interpret script:\n");
		if (remainingArgs_length1 != 1) {
			fprintf (stdout, "Please define the script file name.\n");
			fprintf (stdout, "Furthermore you may use the standard options (signal, ...).\n");
		}
		_tmp4_ = fopen (remainingArgs[0], "r");
		_tmp5_ = _tmp4_;
		_fclose0 (rl_instream);
		rl_instream = _tmp5_;
		_tmp6_ = fopen ("/dev/null", "w");
		_tmp7_ = _tmp6_;
		_fclose0 (rl_outstream);
		rl_outstream = _tmp7_;
		self->priv->cli_enable = TRUE;
		_tmp8_ = gstd_cli_cli (self, &_inner_error_);
		_tmp9_ = _tmp8_;
		if (_inner_error_ != NULL) {
			g_propagate_error (error, _inner_error_);
			return FALSE;
		}
		result = _tmp9_;
		return result;
	}
}


static gboolean string_contains (const gchar* self, const gchar* needle) {
	gboolean result = FALSE;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = strstr (self, needle);
	result = _tmp0_ != NULL;
	return result;
}


static gint gstd_cli_main (gchar** args, int args_length1) {
	gint result = 0;
	gboolean _tmp0_;
	gchar* _tmp1_;
	GstdCli* _tmp2_ = NULL;
	GstdCli* cli;
	gboolean _tmp3_;
	gboolean _tmp4_;
	GError * _inner_error_ = NULL;
	if (args_length1 == 0) {
		result = 1;
		return result;
	}
	_tmp0_ = string_contains (args[0], "interpreter");
	gstd_cli_isInteractive = !_tmp0_;
	_tmp1_ = NULL;
	_g_free0 (gstd_cli_obj_path);
	gstd_cli_obj_path = _tmp1_;
	_tmp2_ = gstd_cli_new (args, args_length1, &_inner_error_);
	cli = _tmp2_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == DBUS_GERROR) {
			goto __catch10_dbus_gerror;
		}
		goto __catch10_g_error;
	}
	_tmp3_ = gstd_cli_parse (cli, gstd_cli__remaining_args, _vala_array_length (gstd_cli__remaining_args), &_inner_error_);
	_tmp4_ = _tmp3_;
	if (_inner_error_ != NULL) {
		_g_object_unref0 (cli);
		if (_inner_error_->domain == DBUS_GERROR) {
			goto __catch10_dbus_gerror;
		}
		goto __catch10_g_error;
	}
	if (!_tmp4_) {
		result = 1;
		_g_object_unref0 (cli);
		return result;
	}
	_g_object_unref0 (cli);
	goto __finally10;
	__catch10_dbus_gerror:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stderr, "gst-client> DBus failure: %s\n", e->message);
		result = 1;
		_g_error_free0 (e);
		return result;
	}
	goto __finally10;
	__catch10_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stderr, "gst-client> Dynamic method failure\n");
		result = 1;
		_g_error_free0 (e);
		return result;
	}
	__finally10:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	result = 0;
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return gstd_cli_main (argv, argc);
}


static void gstd_cli_class_init (GstdCliClass * klass) {
	gstd_cli_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GstdCliPrivate));
	G_OBJECT_CLASS (klass)->finalize = gstd_cli_finalize;
}


static void gstd_cli_instance_init (GstdCli * self) {
	gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* _tmp8_;
	gchar* _tmp9_;
	gchar* _tmp10_;
	gchar* _tmp11_;
	gchar* _tmp12_;
	gchar* _tmp13_;
	gchar* _tmp14_;
	gchar* _tmp15_;
	gchar* _tmp16_;
	gchar* _tmp17_;
	gchar* _tmp18_;
	gchar* _tmp19_;
	gchar* _tmp20_;
	gchar* _tmp21_;
	gchar* _tmp22_;
	gchar* _tmp23_;
	gchar* _tmp24_;
	gchar* _tmp25_;
	gchar* _tmp26_;
	gchar* _tmp27_;
	gchar* _tmp28_;
	gchar* _tmp29_;
	gchar* _tmp30_;
	gchar* _tmp31_;
	gchar* _tmp32_;
	gchar* _tmp33_;
	gchar* _tmp34_;
	gchar* _tmp35_;
	gchar* _tmp36_;
	gchar* _tmp37_;
	gchar* _tmp38_;
	gchar* _tmp39_;
	gchar* _tmp40_;
	gchar* _tmp41_;
	gchar* _tmp42_;
	gchar* _tmp43_;
	gchar* _tmp44_;
	gchar* _tmp45_;
	gchar* _tmp46_;
	gchar* _tmp47_;
	gchar* _tmp48_;
	gchar* _tmp49_;
	gchar* _tmp50_;
	gchar* _tmp51_;
	gchar* _tmp52_;
	gchar* _tmp53_;
	gchar* _tmp54_;
	gchar* _tmp55_;
	gchar* _tmp56_;
	gchar* _tmp57_;
	gchar* _tmp58_;
	gchar* _tmp59_;
	gchar* _tmp60_;
	gchar* _tmp61_;
	gchar* _tmp62_;
	gchar* _tmp63_;
	gchar* _tmp64_;
	gchar* _tmp65_;
	gchar* _tmp66_;
	gchar* _tmp67_;
	gchar* _tmp68_;
	gchar* _tmp69_;
	gchar* _tmp70_;
	gchar* _tmp71_;
	gchar* _tmp72_;
	gchar* _tmp73_;
	gchar* _tmp74_;
	gchar* _tmp75_;
	gchar* _tmp76_;
	gchar* _tmp77_;
	gchar* _tmp78_;
	gchar* _tmp79_;
	gchar* _tmp80_;
	gchar* _tmp81_;
	gchar* _tmp82_;
	gchar* _tmp83_;
	gchar* _tmp84_;
	gchar* _tmp85_;
	gchar* _tmp86_;
	gchar* _tmp87_;
	gchar* _tmp88_;
	gchar* _tmp89_;
	gchar* _tmp90_;
	gchar* _tmp91_;
	gchar* _tmp92_;
	gchar** _tmp93_ = NULL;
	self->priv = GSTD_CLI_GET_PRIVATE (self);
	self->priv->active_pipe = NULL;
	self->priv->cli_enable = FALSE;
	self->priv->pipeline = NULL;
	_tmp0_ = g_strdup ("create");
	_tmp1_ = g_strdup ("create <\"gst-launch like pipeline description in quotes\">");
	_tmp2_ = g_strdup ("Creates a new pipeline and returns the dbus-path to access it");
	_tmp3_ = g_strdup ("destroy");
	_tmp4_ = g_strdup ("destroy");
	_tmp5_ = g_strdup ("Destroys the pipeline specified by_path(-p) or the" " active pipeline");
	_tmp6_ = g_strdup ("destroy-all");
	_tmp7_ = g_strdup ("destroy-all");
	_tmp8_ = g_strdup ("Destroys all pipelines on the factory.");
	_tmp9_ = g_strdup ("play");
	_tmp10_ = g_strdup ("play");
	_tmp11_ = g_strdup ("Sets the pipeline specified by_path(-p) or the active " "pipeline to play state");
	_tmp12_ = g_strdup ("ready");
	_tmp13_ = g_strdup ("ready");
	_tmp14_ = g_strdup ("Sets the pipeline specified by_path(-p) or the active " "pipeline to ready state");
	_tmp15_ = g_strdup ("pause");
	_tmp16_ = g_strdup ("pause");
	_tmp17_ = g_strdup ("Sets the pipeline specified by_path(-p) or the active " "pipeline to pause state");
	_tmp18_ = g_strdup ("null");
	_tmp19_ = g_strdup ("null");
	_tmp20_ = g_strdup ("Sets the pipeline specified by_path(-p) or active " "pipeline to null state");
	_tmp21_ = g_strdup ("aplay");
	_tmp22_ = g_strdup ("play-async");
	_tmp23_ = g_strdup ("Sets the pipeline to play state, it does not " "wait the change to be done");
	_tmp24_ = g_strdup ("aready");
	_tmp25_ = g_strdup ("ready-async");
	_tmp26_ = g_strdup ("Sets the pipeline to ready state, it does not " "wait the change to be done");
	_tmp27_ = g_strdup ("apause");
	_tmp28_ = g_strdup ("pause-async");
	_tmp29_ = g_strdup ("Sets the pipeline to pause state, it does not " "wait the change to be done");
	_tmp30_ = g_strdup ("anull");
	_tmp31_ = g_strdup ("null-async");
	_tmp32_ = g_strdup ("Sets the pipeline to null state, it does not wait " "the change to be done");
	_tmp33_ = g_strdup ("set");
	_tmp34_ = g_strdup ("set <element_name> <property_name> <data-type> <value>");
	_tmp35_ = g_strdup ("Sets an element's property value of the pipeline\n" "\t\tSupported <data-type>s include: boolean, integer, int64, and " "string");
	_tmp36_ = g_strdup ("get");
	_tmp37_ = g_strdup ("get <element_name> <property_name> <data_type>");
	_tmp38_ = g_strdup ("Gets an element's property value of the pipeline");
	_tmp39_ = g_strdup ("get-duration");
	_tmp40_ = g_strdup ("get-duration");
	_tmp41_ = g_strdup ("Gets the pipeline duration time");
	_tmp42_ = g_strdup ("get-position");
	_tmp43_ = g_strdup ("get-position");
	_tmp44_ = g_strdup ("Gets the pipeline position");
	_tmp45_ = g_strdup ("sh");
	_tmp46_ = g_strdup ("sh \"<shell command with optional parameters>\"");
	_tmp47_ = g_strdup ("Execute a shell command using interactive console");
	_tmp48_ = g_strdup ("get-state");
	_tmp49_ = g_strdup ("get-state");
	_tmp50_ = g_strdup ("Get the state of a specific pipeline(-p flag)" " or the active pipeline");
	_tmp51_ = g_strdup ("get-elem-state");
	_tmp52_ = g_strdup ("get-elem-state");
	_tmp53_ = g_strdup ("Get the state of a specific element of" "the active pipeline");
	_tmp54_ = g_strdup ("list-pipes");
	_tmp55_ = g_strdup ("list-pipes");
	_tmp56_ = g_strdup ("Returns a list of all the dbus-path of" "the existing pipelines");
	_tmp57_ = g_strdup ("ping");
	_tmp58_ = g_strdup ("ping");
	_tmp59_ = g_strdup ("Shows if gstd is alive");
	_tmp60_ = g_strdup ("ping-pipe");
	_tmp61_ = g_strdup ("ping-pipe");
	_tmp62_ = g_strdup ("Test if the active pipeline is alive");
	_tmp63_ = g_strdup ("active");
	_tmp64_ = g_strdup ("active <path>");
	_tmp65_ = g_strdup ("Sets the active pipeline,if no <path> is " "passed:it returns the actual active pipeline");
	_tmp66_ = g_strdup ("seek");
	_tmp67_ = g_strdup ("seek <position[ms]>");
	_tmp68_ = g_strdup ("Moves current playing position to a new" " one");
	_tmp69_ = g_strdup ("skip");
	_tmp70_ = g_strdup ("skip <period[ms]>");
	_tmp71_ = g_strdup ("Skips a period, if period is positive: it" " moves forward, if negative: it moves backward");
	_tmp72_ = g_strdup ("speed");
	_tmp73_ = g_strdup ("speed <rate>");
	_tmp74_ = g_strdup ("Changes playback rate:\n" "\t\t* rate>1.0: fast-forward playback,\n" "\t\t* rate<1.0: slow-forward playback,\n" "\t\t* rate=1.0: normal speed.\n" "\t\tNegative rate causes reverse playback.");
	_tmp75_ = g_strdup ("send-eos");
	_tmp76_ = g_strdup ("send-eos");
	_tmp77_ = g_strdup ("Send an EOS event on the pipeline");
	_tmp78_ = g_strdup ("element-set-state");
	_tmp79_ = g_strdup ("element-set-state <element_name> <state>");
	_tmp80_ = g_strdup ("Sets the element state" "\t\tSupported <state>s include: null, ready, paused, playing");
	_tmp81_ = g_strdup ("element-async-set-state");
	_tmp82_ = g_strdup ("element-async-set-state <element_name> <state>");
	_tmp83_ = g_strdup ("Sets the element state, it does not wait the change to be done");
	_tmp84_ = g_strdup ("exit");
	_tmp85_ = g_strdup ("exit");
	_tmp86_ = g_strdup ("Exit/quit active console");
	_tmp87_ = g_strdup ("quit");
	_tmp88_ = g_strdup ("quit");
	_tmp89_ = g_strdup ("Exit/quit active console");
	_tmp90_ = g_strdup ("strict");
	_tmp91_ = g_strdup ("strict");
	_tmp92_ = g_strdup ("Enable/disable strict execution mode.");
	_tmp93_ = g_new0 (gchar*, (31 * 3) + 1);
	_tmp93_[0] = _tmp0_;
	_tmp93_[1] = _tmp1_;
	_tmp93_[2] = _tmp2_;
	_tmp93_[3] = _tmp3_;
	_tmp93_[4] = _tmp4_;
	_tmp93_[5] = _tmp5_;
	_tmp93_[6] = _tmp6_;
	_tmp93_[7] = _tmp7_;
	_tmp93_[8] = _tmp8_;
	_tmp93_[9] = _tmp9_;
	_tmp93_[10] = _tmp10_;
	_tmp93_[11] = _tmp11_;
	_tmp93_[12] = _tmp12_;
	_tmp93_[13] = _tmp13_;
	_tmp93_[14] = _tmp14_;
	_tmp93_[15] = _tmp15_;
	_tmp93_[16] = _tmp16_;
	_tmp93_[17] = _tmp17_;
	_tmp93_[18] = _tmp18_;
	_tmp93_[19] = _tmp19_;
	_tmp93_[20] = _tmp20_;
	_tmp93_[21] = _tmp21_;
	_tmp93_[22] = _tmp22_;
	_tmp93_[23] = _tmp23_;
	_tmp93_[24] = _tmp24_;
	_tmp93_[25] = _tmp25_;
	_tmp93_[26] = _tmp26_;
	_tmp93_[27] = _tmp27_;
	_tmp93_[28] = _tmp28_;
	_tmp93_[29] = _tmp29_;
	_tmp93_[30] = _tmp30_;
	_tmp93_[31] = _tmp31_;
	_tmp93_[32] = _tmp32_;
	_tmp93_[33] = _tmp33_;
	_tmp93_[34] = _tmp34_;
	_tmp93_[35] = _tmp35_;
	_tmp93_[36] = _tmp36_;
	_tmp93_[37] = _tmp37_;
	_tmp93_[38] = _tmp38_;
	_tmp93_[39] = _tmp39_;
	_tmp93_[40] = _tmp40_;
	_tmp93_[41] = _tmp41_;
	_tmp93_[42] = _tmp42_;
	_tmp93_[43] = _tmp43_;
	_tmp93_[44] = _tmp44_;
	_tmp93_[45] = _tmp45_;
	_tmp93_[46] = _tmp46_;
	_tmp93_[47] = _tmp47_;
	_tmp93_[48] = _tmp48_;
	_tmp93_[49] = _tmp49_;
	_tmp93_[50] = _tmp50_;
	_tmp93_[51] = _tmp51_;
	_tmp93_[52] = _tmp52_;
	_tmp93_[53] = _tmp53_;
	_tmp93_[54] = _tmp54_;
	_tmp93_[55] = _tmp55_;
	_tmp93_[56] = _tmp56_;
	_tmp93_[57] = _tmp57_;
	_tmp93_[58] = _tmp58_;
	_tmp93_[59] = _tmp59_;
	_tmp93_[60] = _tmp60_;
	_tmp93_[61] = _tmp61_;
	_tmp93_[62] = _tmp62_;
	_tmp93_[63] = _tmp63_;
	_tmp93_[64] = _tmp64_;
	_tmp93_[65] = _tmp65_;
	_tmp93_[66] = _tmp66_;
	_tmp93_[67] = _tmp67_;
	_tmp93_[68] = _tmp68_;
	_tmp93_[69] = _tmp69_;
	_tmp93_[70] = _tmp70_;
	_tmp93_[71] = _tmp71_;
	_tmp93_[72] = _tmp72_;
	_tmp93_[73] = _tmp73_;
	_tmp93_[74] = _tmp74_;
	_tmp93_[75] = _tmp75_;
	_tmp93_[76] = _tmp76_;
	_tmp93_[77] = _tmp77_;
	_tmp93_[78] = _tmp78_;
	_tmp93_[79] = _tmp79_;
	_tmp93_[80] = _tmp80_;
	_tmp93_[81] = _tmp81_;
	_tmp93_[82] = _tmp82_;
	_tmp93_[83] = _tmp83_;
	_tmp93_[84] = _tmp84_;
	_tmp93_[85] = _tmp85_;
	_tmp93_[86] = _tmp86_;
	_tmp93_[87] = _tmp87_;
	_tmp93_[88] = _tmp88_;
	_tmp93_[89] = _tmp89_;
	_tmp93_[90] = _tmp90_;
	_tmp93_[91] = _tmp91_;
	_tmp93_[92] = _tmp92_;
	self->priv->cmds = _tmp93_;
	self->priv->cmds_length1 = 31;
	self->priv->cmds_length2 = 3;
}


static void gstd_cli_finalize (GObject* obj) {
	GstdCli * self;
	self = GSTD_CLI (obj);
	_dbus_g_connection_unref0 (self->priv->conn);
	_g_object_unref0 (self->priv->factory);
	_g_free0 (self->priv->active_pipe);
	_g_object_unref0 (self->priv->pipeline);
	self->priv->cmds = (_vala_array_free (self->priv->cmds, self->priv->cmds_length1 * self->priv->cmds_length2, (GDestroyNotify) g_free), NULL);
	G_OBJECT_CLASS (gstd_cli_parent_class)->finalize (obj);
}


GType gstd_cli_get_type (void) {
	static volatile gsize gstd_cli_type_id__volatile = 0;
	if (g_once_init_enter (&gstd_cli_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GstdCliClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gstd_cli_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GstdCli), 0, (GInstanceInitFunc) gstd_cli_instance_init, NULL };
		GType gstd_cli_type_id;
		gstd_cli_type_id = g_type_register_static (G_TYPE_OBJECT, "GstdCli", &g_define_type_info, 0);
		g_once_init_leave (&gstd_cli_type_id__volatile, gstd_cli_type_id);
	}
	return gstd_cli_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



