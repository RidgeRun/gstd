/* gstd-pipeline.c generated by valac, the Vala compiler
 * generated from gstd-pipeline.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gst/gst.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dbus/dbus.h>
#include <dbus/dbus-glib.h>
#include <dbus/dbus-glib-lowlevel.h>


#define TYPE_PIPELINE (pipeline_get_type ())
#define PIPELINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PIPELINE, Pipeline))
#define PIPELINE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PIPELINE, PipelineClass))
#define IS_PIPELINE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PIPELINE))
#define IS_PIPELINE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PIPELINE))
#define PIPELINE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PIPELINE, PipelineClass))

typedef struct _Pipeline Pipeline;
typedef struct _PipelineClass PipelineClass;
typedef struct _PipelinePrivate PipelinePrivate;
#define _gst_object_unref0(var) ((var == NULL) ? NULL : (var = (gst_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _DBusObjectVTable _DBusObjectVTable;

struct _Pipeline {
	GObject parent_instance;
	PipelinePrivate * priv;
};

struct _PipelineClass {
	GObjectClass parent_class;
};

struct _PipelinePrivate {
	GstElement* pipeline;
	gboolean debug;
	gboolean initialized;
	gint id;
};

struct _DBusObjectVTable {
	void (*register_object) (DBusConnection*, const char*, void*);
};


static gpointer pipeline_parent_class = NULL;

GType pipeline_get_type (void);
#define PIPELINE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_PIPELINE, PipelinePrivate))
enum  {
	PIPELINE_DUMMY_PROPERTY
};
static gboolean pipeline_bus_callback (Pipeline* self, GstBus* bus, GstMessage* message);
static gboolean _pipeline_bus_callback_gst_bus_func (GstBus* bus, GstMessage* message, gpointer self);
Pipeline* pipeline_new (const char* description, gint ids);
Pipeline* pipeline_construct (GType object_type, const char* description, gint ids);
gboolean pipeline_PipelineIsInitialized (Pipeline* self);
Pipeline* pipeline_new_withDebug (const char* description, gint ids, gboolean _debug);
Pipeline* pipeline_construct_withDebug (GType object_type, const char* description, gint ids, gboolean _debug);
static gboolean pipeline_PipelineSetState (Pipeline* self, GstState state);
gint pipeline_PipelineId (Pipeline* self);
gboolean pipeline_PipelinePlay (Pipeline* self);
gboolean pipeline_PipelinePause (Pipeline* self);
gboolean pipeline_PipelineNull (Pipeline* self);
gboolean pipeline_ElementSetPropertyBoolean (Pipeline* self, const char* element, const char* property, gboolean val);
gboolean pipeline_ElementSetPropertyInt (Pipeline* self, const char* element, const char* property, gint val);
gboolean pipeline_ElementSetPropertyLong (Pipeline* self, const char* element, const char* property, glong val);
gboolean pipeline_ElementSetPropertyString (Pipeline* self, const char* element, const char* property, const char* val);
gboolean pipeline_ElementGetPropertyBoolean (Pipeline* self, const char* element, const char* property);
gint pipeline_ElementGetPropertyInt (Pipeline* self, const char* element, const char* property);
glong pipeline_ElementGetPropertyLong (Pipeline* self, const char* element, const char* property);
char* pipeline_ElementGetPropertyString (Pipeline* self, const char* element, const char* property);
gint pipeline_PipelineGetDuration (Pipeline* self);
gint pipeline_PipelineGetPosition (Pipeline* self);
void pipeline_dbus_register_object (DBusConnection* connection, const char* path, void* object);
void _pipeline_dbus_unregister (DBusConnection* connection, void* _user_data_);
DBusHandlerResult pipeline_dbus_message (DBusConnection* connection, DBusMessage* message, void* object);
static DBusHandlerResult _dbus_pipeline_introspect (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_property_get_all (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_PipelineIsInitialized (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_PipelineId (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_PipelinePlay (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_PipelinePause (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_PipelineNull (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_ElementSetPropertyBoolean (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_ElementSetPropertyInt (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_ElementSetPropertyLong (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_ElementSetPropertyString (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_ElementGetPropertyBoolean (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_ElementGetPropertyInt (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_ElementGetPropertyLong (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_ElementGetPropertyString (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_PipelineGetDuration (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_PipelineGetPosition (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static void _dbus_pipeline_eos (GObject* _sender, DBusConnection* _connection);
static void _dbus_pipeline_state_changed (GObject* _sender, const char* old_state, const char* new_state, DBusConnection* _connection);
static void _dbus_pipeline_error (GObject* _sender, const char* err_message, DBusConnection* _connection);
static void pipeline_finalize (GObject* obj);
static void _vala_dbus_register_object (DBusConnection* connection, const char* path, void* object);
static void _vala_dbus_unregister_object (gpointer connection, GObject* object);

static const DBusObjectPathVTable _pipeline_dbus_path_vtable = {_pipeline_dbus_unregister, pipeline_dbus_message};
static const _DBusObjectVTable _pipeline_dbus_vtable = {pipeline_dbus_register_object};

static void g_cclosure_user_marshal_VOID__STRING_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);

static gboolean _pipeline_bus_callback_gst_bus_func (GstBus* bus, GstMessage* message, gpointer self) {
	return pipeline_bus_callback (self, bus, message);
}


Pipeline* pipeline_construct (GType object_type, const char* description, gint ids) {
	GError * _inner_error_;
	Pipeline * self;
	g_return_val_if_fail (description != NULL, NULL);
	_inner_error_ = NULL;
	self = (Pipeline*) g_object_new (object_type, NULL);
	{
		GstElement* _tmp0_;
		GstElement* _tmp2_;
		GstElement* _tmp1_;
		GstBus* bus;
		_tmp0_ = gst_parse_launch (description, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch1_g_error;
			goto __finally1;
		}
		self->priv->pipeline = (_tmp2_ = (_tmp1_ = _tmp0_, GST_IS_ELEMENT (_tmp1_) ? ((GstElement*) _tmp1_) : NULL), _gst_object_unref0 (self->priv->pipeline), _tmp2_);
		g_assert (self->priv->pipeline != NULL);
		self->priv->id = ids;
		self->priv->initialized = TRUE;
		bus = gst_element_get_bus (self->priv->pipeline);
		gst_bus_add_watch (bus, _pipeline_bus_callback_gst_bus_func, self);
		_gst_object_unref0 (bus);
	}
	goto __finally1;
	__catch1_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			fprintf (stderr, "Gstd>Failed to create pipeline with description: %s.\n" "Gstd>Error: %s\n", description, e->message);
			_g_error_free0 (e);
		}
	}
	__finally1:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	return self;
}


Pipeline* pipeline_new (const char* description, gint ids) {
	return pipeline_construct (TYPE_PIPELINE, description, ids);
}


Pipeline* pipeline_construct_withDebug (GType object_type, const char* description, gint ids, gboolean _debug) {
	Pipeline * self;
	g_return_val_if_fail (description != NULL, NULL);
	self = (Pipeline*) pipeline_construct (object_type, description, ids);
	self->priv->debug = _debug;
	if (_debug) {
		if (pipeline_PipelineIsInitialized (self)) {
			fprintf (stdout, "Gstd>Pipeline created: %s\n", description);
		} else {
			fprintf (stderr, "Pipeline could not be initialized\n");
		}
	}
	return self;
}


Pipeline* pipeline_new_withDebug (const char* description, gint ids, gboolean _debug) {
	return pipeline_construct_withDebug (TYPE_PIPELINE, description, ids, _debug);
}


static gboolean pipeline_bus_callback (Pipeline* self, GstBus* bus, GstMessage* message) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (bus != NULL, FALSE);
	g_return_val_if_fail (message != NULL, FALSE);
	switch (message->type) {
		case GST_MESSAGE_ERROR:
		{
			GError* err;
			char* dbg;
			char* _tmp3_;
			char* _tmp2_ = NULL;
			GError* _tmp1_;
			GError* _tmp0_ = NULL;
			err = NULL;
			dbg = NULL;
			(gst_message_parse_error (message, &_tmp0_, &_tmp2_), err = (_tmp1_ = _tmp0_, _g_error_free0 (err), _tmp1_));
			dbg = (_tmp3_ = _tmp2_, _g_free0 (dbg), _tmp3_);
			g_signal_emit_by_name (self, "error", err->message);
			if (self->priv->debug) {
				fprintf (stderr, "Error on pipeline: %s\n", err->message);
			}
			_g_error_free0 (err);
			_g_free0 (dbg);
			break;
		}
		case GST_MESSAGE_EOS:
		{
			g_signal_emit_by_name (self, "eos");
			break;
		}
		case GST_MESSAGE_STATE_CHANGED:
		{
			GstState oldstate = 0;
			GstState newstate = 0;
			GstState pending = 0;
			gst_message_parse_state_changed (message, &oldstate, &newstate, &pending);
			g_signal_emit_by_name (self, "state-changed", gst_element_state_get_name (oldstate), gst_element_state_get_name (newstate));
			break;
		}
		default:
		{
			break;
		}
	}
	result = TRUE;
	return result;
}


static gboolean pipeline_PipelineSetState (Pipeline* self, GstState state) {
	gboolean result;
	GstState current = 0;
	GstState pending = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	gst_element_set_state (self->priv->pipeline, state);
	gst_element_get_state (self->priv->pipeline, &current, &pending, (GstClockTime) 4000000000u);
	gst_element_get_state (self->priv->pipeline, &current, &pending, (GstClockTime) 4000000000u);
	if (current != state) {
		if (self->priv->debug) {
			fprintf (stderr, "Gstd>Element, failed to change state %s\n", gst_element_state_get_name (state));
		}
		result = FALSE;
		return result;
	}
	result = TRUE;
	return result;
}


gboolean pipeline_PipelineIsInitialized (Pipeline* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->initialized;
	return result;
}


gint pipeline_PipelineId (Pipeline* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->id;
	return result;
}


gboolean pipeline_PipelinePlay (Pipeline* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = pipeline_PipelineSetState (self, GST_STATE_PLAYING);
	return result;
}


gboolean pipeline_PipelinePause (Pipeline* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = pipeline_PipelineSetState (self, GST_STATE_PAUSED);
	return result;
}


gboolean pipeline_PipelineNull (Pipeline* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = pipeline_PipelineSetState (self, GST_STATE_NULL);
	return result;
}


static gpointer _gst_object_ref0 (gpointer self) {
	return self ? gst_object_ref (self) : NULL;
}


gboolean pipeline_ElementSetPropertyBoolean (Pipeline* self, const char* element, const char* property, gboolean val) {
	gboolean result;
	GstElement* e;
	GstPipeline* pipe;
	GstPipeline* _tmp1_;
	GstElement* _tmp0_;
	GstElement* _tmp3_;
	GstObject* _tmp2_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (element != NULL, FALSE);
	g_return_val_if_fail (property != NULL, FALSE);
	e = NULL;
	pipe = NULL;
	pipe = (_tmp1_ = _gst_object_ref0 ((_tmp0_ = self->priv->pipeline, GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL)), _gst_object_unref0 (pipe), _tmp1_);
	e = (_tmp3_ = _gst_object_ref0 ((_tmp2_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) pipe, element), GST_IS_ELEMENT (_tmp2_) ? ((GstElement*) _tmp2_) : NULL)), _gst_object_unref0 (e), _tmp3_);
	if (e == NULL) {
		if (self->priv->debug) {
			fprintf (stderr, "Gstd>Element %s not found on pipeline", element);
		}
		result = FALSE;
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		return result;
	}
	g_object_set ((GObject*) e, property, val, NULL, NULL);
	result = TRUE;
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	return result;
}


gboolean pipeline_ElementSetPropertyInt (Pipeline* self, const char* element, const char* property, gint val) {
	gboolean result;
	GstElement* e;
	GstPipeline* pipe;
	GstPipeline* _tmp1_;
	GstElement* _tmp0_;
	GstElement* _tmp3_;
	GstObject* _tmp2_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (element != NULL, FALSE);
	g_return_val_if_fail (property != NULL, FALSE);
	e = NULL;
	pipe = NULL;
	pipe = (_tmp1_ = _gst_object_ref0 ((_tmp0_ = self->priv->pipeline, GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL)), _gst_object_unref0 (pipe), _tmp1_);
	e = (_tmp3_ = _gst_object_ref0 ((_tmp2_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) pipe, element), GST_IS_ELEMENT (_tmp2_) ? ((GstElement*) _tmp2_) : NULL)), _gst_object_unref0 (e), _tmp3_);
	if (e == NULL) {
		if (self->priv->debug) {
			fprintf (stderr, "Gstd>Element %s not found on pipeline\n", element);
		}
		result = FALSE;
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		return result;
	}
	g_object_set ((GObject*) e, property, val, NULL, NULL);
	result = TRUE;
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	return result;
}


gboolean pipeline_ElementSetPropertyLong (Pipeline* self, const char* element, const char* property, glong val) {
	gboolean result;
	GstElement* e;
	GstPipeline* pipe;
	GstPipeline* _tmp1_;
	GstElement* _tmp0_;
	GstElement* _tmp3_;
	GstObject* _tmp2_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (element != NULL, FALSE);
	g_return_val_if_fail (property != NULL, FALSE);
	e = NULL;
	pipe = NULL;
	pipe = (_tmp1_ = _gst_object_ref0 ((_tmp0_ = self->priv->pipeline, GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL)), _gst_object_unref0 (pipe), _tmp1_);
	e = (_tmp3_ = _gst_object_ref0 ((_tmp2_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) pipe, element), GST_IS_ELEMENT (_tmp2_) ? ((GstElement*) _tmp2_) : NULL)), _gst_object_unref0 (e), _tmp3_);
	if (e == NULL) {
		if (self->priv->debug) {
			fprintf (stderr, "Gstd>Element %s not found on pipeline", element);
		}
		result = FALSE;
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		return result;
	}
	g_object_set ((GObject*) e, property, val, NULL, NULL);
	result = TRUE;
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	return result;
}


gboolean pipeline_ElementSetPropertyString (Pipeline* self, const char* element, const char* property, const char* val) {
	gboolean result;
	GstElement* e;
	GstPipeline* pipe;
	GstPipeline* _tmp1_;
	GstElement* _tmp0_;
	GstElement* _tmp3_;
	GstObject* _tmp2_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (element != NULL, FALSE);
	g_return_val_if_fail (property != NULL, FALSE);
	g_return_val_if_fail (val != NULL, FALSE);
	e = NULL;
	pipe = NULL;
	pipe = (_tmp1_ = _gst_object_ref0 ((_tmp0_ = self->priv->pipeline, GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL)), _gst_object_unref0 (pipe), _tmp1_);
	e = (_tmp3_ = _gst_object_ref0 ((_tmp2_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) pipe, element), GST_IS_ELEMENT (_tmp2_) ? ((GstElement*) _tmp2_) : NULL)), _gst_object_unref0 (e), _tmp3_);
	if (e == NULL) {
		if (self->priv->debug) {
			fprintf (stderr, "Gstd>Element %s not found on pipeline", element);
		}
		result = FALSE;
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		return result;
	}
	g_object_set ((GObject*) e, property, val, NULL, NULL);
	result = TRUE;
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	return result;
}


gboolean pipeline_ElementGetPropertyBoolean (Pipeline* self, const char* element, const char* property) {
	gboolean result;
	GstElement* e;
	GstPipeline* pipe;
	gboolean bool_v;
	GstPipeline* _tmp1_;
	GstElement* _tmp0_;
	GstElement* _tmp3_;
	GstObject* _tmp2_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (element != NULL, FALSE);
	g_return_val_if_fail (property != NULL, FALSE);
	e = NULL;
	pipe = NULL;
	bool_v = FALSE;
	pipe = (_tmp1_ = _gst_object_ref0 ((_tmp0_ = self->priv->pipeline, GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL)), _gst_object_unref0 (pipe), _tmp1_);
	e = (_tmp3_ = _gst_object_ref0 ((_tmp2_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) pipe, element), GST_IS_ELEMENT (_tmp2_) ? ((GstElement*) _tmp2_) : NULL)), _gst_object_unref0 (e), _tmp3_);
	if (e == NULL) {
		if (self->priv->debug) {
			fprintf (stderr, "Gstd>Element %s not found on pipeline", element);
		}
	}
	g_object_get ((GObject*) e, property, &bool_v, NULL, NULL);
	result = bool_v;
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	return result;
}


gint pipeline_ElementGetPropertyInt (Pipeline* self, const char* element, const char* property) {
	gint result;
	GstElement* e;
	GstPipeline* pipe;
	gint integer_v;
	GstPipeline* _tmp1_;
	GstElement* _tmp0_;
	GstElement* _tmp3_;
	GstObject* _tmp2_;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (element != NULL, 0);
	g_return_val_if_fail (property != NULL, 0);
	e = NULL;
	pipe = NULL;
	integer_v = -1;
	pipe = (_tmp1_ = _gst_object_ref0 ((_tmp0_ = self->priv->pipeline, GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL)), _gst_object_unref0 (pipe), _tmp1_);
	e = (_tmp3_ = _gst_object_ref0 ((_tmp2_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) pipe, element), GST_IS_ELEMENT (_tmp2_) ? ((GstElement*) _tmp2_) : NULL)), _gst_object_unref0 (e), _tmp3_);
	if (e == NULL) {
		if (self->priv->debug) {
			fprintf (stderr, "Gstd>Element %s not found on pipeline", element);
		}
	}
	g_object_get ((GObject*) e, property, &integer_v, NULL, NULL);
	result = integer_v;
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	return result;
}


glong pipeline_ElementGetPropertyLong (Pipeline* self, const char* element, const char* property) {
	glong result;
	GstElement* e;
	GstPipeline* pipe;
	glong long_v;
	GstPipeline* _tmp1_;
	GstElement* _tmp0_;
	GstElement* _tmp3_;
	GstObject* _tmp2_;
	g_return_val_if_fail (self != NULL, 0L);
	g_return_val_if_fail (element != NULL, 0L);
	g_return_val_if_fail (property != NULL, 0L);
	e = NULL;
	pipe = NULL;
	long_v = (glong) (-1);
	pipe = (_tmp1_ = _gst_object_ref0 ((_tmp0_ = self->priv->pipeline, GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL)), _gst_object_unref0 (pipe), _tmp1_);
	e = (_tmp3_ = _gst_object_ref0 ((_tmp2_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) pipe, element), GST_IS_ELEMENT (_tmp2_) ? ((GstElement*) _tmp2_) : NULL)), _gst_object_unref0 (e), _tmp3_);
	if (e == NULL) {
		if (self->priv->debug) {
			fprintf (stderr, "Gstd>Element %s not found on pipeline", element);
		}
	}
	g_object_get ((GObject*) e, property, &long_v, NULL, NULL);
	result = long_v;
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	return result;
}


char* pipeline_ElementGetPropertyString (Pipeline* self, const char* element, const char* property) {
	char* result;
	GstElement* e;
	GstPipeline* pipe;
	char* string_v;
	GstPipeline* _tmp1_;
	GstElement* _tmp0_;
	GstElement* _tmp3_;
	GstObject* _tmp2_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (element != NULL, NULL);
	g_return_val_if_fail (property != NULL, NULL);
	e = NULL;
	pipe = NULL;
	string_v = g_strdup ("");
	pipe = (_tmp1_ = _gst_object_ref0 ((_tmp0_ = self->priv->pipeline, GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL)), _gst_object_unref0 (pipe), _tmp1_);
	e = (_tmp3_ = _gst_object_ref0 ((_tmp2_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) pipe, element), GST_IS_ELEMENT (_tmp2_) ? ((GstElement*) _tmp2_) : NULL)), _gst_object_unref0 (e), _tmp3_);
	if (e == NULL) {
		if (self->priv->debug) {
			fprintf (stderr, "Gstd>Element %s not found on pipeline", element);
		}
	}
	g_object_get ((GObject*) e, property, &string_v, NULL, NULL);
	result = string_v;
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	return result;
}


gint pipeline_PipelineGetDuration (Pipeline* self) {
	gint result;
	GstFormat format;
	gint64 duration;
	gint idur;
	g_return_val_if_fail (self != NULL, 0);
	format = GST_FORMAT_TIME;
	duration = (gint64) 0;
	idur = 0;
	if (!gst_element_query_duration (self->priv->pipeline, &format, &duration)) {
		result = -1;
		return result;
	}
	if (duration == GST_CLOCK_TIME_NONE) {
		result = -1;
		return result;
	}
	idur = (gint) (duration / 1000000);
	if (self->priv->debug) {
		fprintf (stdout, "Gstd>Duration at server is %d\n", idur);
	}
	result = idur;
	return result;
}


gint pipeline_PipelineGetPosition (Pipeline* self) {
	gint result;
	GstFormat format;
	gint64 position;
	gint ipos;
	g_return_val_if_fail (self != NULL, 0);
	format = GST_FORMAT_TIME;
	position = (gint64) 0;
	ipos = 0;
	if (!gst_element_query_position (self->priv->pipeline, &format, &position)) {
		result = -1;
		return result;
	}
	if (position == GST_CLOCK_TIME_NONE) {
		result = -1;
		return result;
	}
	ipos = (gint) (position / 1000000);
	if (self->priv->debug) {
		fprintf (stdout, "Gstd>Position at server is %d\n", ipos);
	}
	result = ipos;
	return result;
}


void _pipeline_dbus_unregister (DBusConnection* connection, void* _user_data_) {
}


static DBusHandlerResult _dbus_pipeline_introspect (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter;
	GString* xml_data;
	char** children;
	int i;
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	xml_data = g_string_new ("<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\" \"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n");
	g_string_append (xml_data, "<node>\n<interface name=\"org.freedesktop.DBus.Introspectable\">\n  <method name=\"Introspect\">\n    <arg name=\"data\" direction=\"out\" type=\"s\"/>\n  </method>\n</interface>\n<interface name=\"org.freedesktop.DBus.Properties\">\n  <method name=\"Get\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"out\" type=\"v\"/>\n  </method>\n  <method name=\"Set\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"in\" type=\"v\"/>\n  </method>\n  <method name=\"GetAll\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"props\" direction=\"out\" type=\"a{sv}\"/>\n  </method>\n</interface>\n<interface name=\"com.ridgerun.gstreamer.gstd.PipelineInterface\">\n  <method name=\"PipelineIsInitialized\">\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"PipelineId\">\n    <arg name=\"result\" type=\"i\" direction=\"out\"/>\n  </method>\n  <method name=\"PipelinePlay\">\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"PipelinePause\">\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"PipelineNull\">\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"ElementSetPropertyBoolean\">\n    <arg name=\"element\" type=\"s\" direction=\"in\"/>\n    <arg name=\"property\" type=\"s\" direction=\"in\"/>\n    <arg name=\"val\" type=\"b\" direction=\"in\"/>\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"ElementSetPropertyInt\">\n    <arg name=\"element\" type=\"s\" direction=\"in\"/>\n    <arg name=\"property\" type=\"s\" direction=\"in\"/>\n    <arg name=\"val\" type=\"i\" direction=\"in\"/>\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"ElementSetPropertyLong\">\n    <arg name=\"element\" type=\"s\" direction=\"in\"/>\n    <arg name=\"property\" type=\"s\" direction=\"in\"/>\n    <arg name=\"val\" type=\"()\" direction=\"in\"/>\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"ElementSetPropertyString\">\n    <arg name=\"element\" type=\"s\" direction=\"in\"/>\n    <arg name=\"property\" type=\"s\" direction=\"in\"/>\n    <arg name=\"val\" type=\"s\" direction=\"in\"/>\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"ElementGetPropertyBoolean\">\n    <arg name=\"element\" type=\"s\" direction=\"in\"/>\n    <arg name=\"property\" type=\"s\" direction=\"in\"/>\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"ElementGetPropertyInt\">\n    <arg name=\"element\" type=\"s\" direction=\"in\"/>\n    <arg name=\"property\" type=\"s\" direction=\"in\"/>\n    <arg name=\"result\" type=\"i\" direction=\"out\"/>\n  </method>\n  <method name=\"ElementGetPropertyLong\">\n    <arg name=\"element\" type=\"s\" direction=\"in\"/>\n    <arg name=\"property\" type=\"s\" direction=\"in\"/>\n    <arg name=\"result\" type=\"()\" direction=\"out\"/>\n  </method>\n  <method name=\"ElementGetPropertyString\">\n    <arg name=\"element\" type=\"s\" direction=\"in\"/>\n    <arg name=\"property\" type=\"s\" direction=\"in\"/>\n    <arg name=\"result\" type=\"s\" direction=\"out\"/>\n  </method>\n  <method name=\"PipelineGetDuration\">\n    <arg name=\"result\" type=\"i\" direction=\"out\"/>\n  </method>\n  <method name=\"PipelineGetPosition\">\n    <arg name=\"result\" type=\"i\" direction=\"out\"/>\n  </method>\n  <signal name=\"Eos\">\n  </signal>\n  <signal name=\"StateChanged\">\n    <arg name=\"old_state\" type=\"s\"/>\n    <arg name=\"new_state\" type=\"s\"/>\n  </signal>\n  <signal name=\"Error\">\n    <arg name=\"err_message\" type=\"s\"/>\n  </signal>\n</interface>\n");
	dbus_connection_list_registered (connection, g_object_get_data ((GObject *) self, "dbus_object_path"), &children);
	for (i = 0; children[i]; i++) {
		g_string_append_printf (xml_data, "<node name=\"%s\"/>\n", children[i]);
	}
	dbus_free_string_array (children);
	g_string_append (xml_data, "</node>\n");
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &xml_data->str);
	g_string_free (xml_data, TRUE);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_property_get_all (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter, reply_iter, subiter;
	char* interface_name;
	const char* _tmp0_;
	if (strcmp (dbus_message_get_signature (message), "s")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &reply_iter);
	dbus_message_iter_get_basic (&iter, &_tmp0_);
	dbus_message_iter_next (&iter);
	interface_name = g_strdup (_tmp0_);
	if (strcmp (interface_name, "com.ridgerun.gstreamer.gstd.PipelineInterface") == 0) {
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_ARRAY, "{sv}", &subiter);
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else {
		dbus_message_unref (reply);
		reply = NULL;
	}
	g_free (interface_name);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_PipelineIsInitialized (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gboolean result;
	DBusMessage* reply;
	dbus_bool_t _tmp1_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	result = pipeline_PipelineIsInitialized (self);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_tmp1_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp1_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_PipelineId (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gint result;
	DBusMessage* reply;
	dbus_int32_t _tmp2_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	result = pipeline_PipelineId (self);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_tmp2_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_INT32, &_tmp2_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_PipelinePlay (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gboolean result;
	DBusMessage* reply;
	dbus_bool_t _tmp3_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	result = pipeline_PipelinePlay (self);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_tmp3_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp3_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_PipelinePause (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gboolean result;
	DBusMessage* reply;
	dbus_bool_t _tmp4_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	result = pipeline_PipelinePause (self);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_tmp4_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp4_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_PipelineNull (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gboolean result;
	DBusMessage* reply;
	dbus_bool_t _tmp5_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	result = pipeline_PipelineNull (self);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_tmp5_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp5_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_ElementSetPropertyBoolean (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	char* element = NULL;
	const char* _tmp6_;
	char* property = NULL;
	const char* _tmp7_;
	gboolean val = FALSE;
	dbus_bool_t _tmp8_;
	gboolean result;
	DBusMessage* reply;
	dbus_bool_t _tmp9_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "ssb")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp6_);
	dbus_message_iter_next (&iter);
	element = g_strdup (_tmp6_);
	dbus_message_iter_get_basic (&iter, &_tmp7_);
	dbus_message_iter_next (&iter);
	property = g_strdup (_tmp7_);
	dbus_message_iter_get_basic (&iter, &_tmp8_);
	dbus_message_iter_next (&iter);
	val = _tmp8_;
	result = pipeline_ElementSetPropertyBoolean (self, element, property, val);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (element);
	_g_free0 (property);
	_tmp9_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp9_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_ElementSetPropertyInt (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	char* element = NULL;
	const char* _tmp10_;
	char* property = NULL;
	const char* _tmp11_;
	gint val = 0;
	dbus_int32_t _tmp12_;
	gboolean result;
	DBusMessage* reply;
	dbus_bool_t _tmp13_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "ssi")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp10_);
	dbus_message_iter_next (&iter);
	element = g_strdup (_tmp10_);
	dbus_message_iter_get_basic (&iter, &_tmp11_);
	dbus_message_iter_next (&iter);
	property = g_strdup (_tmp11_);
	dbus_message_iter_get_basic (&iter, &_tmp12_);
	dbus_message_iter_next (&iter);
	val = _tmp12_;
	result = pipeline_ElementSetPropertyInt (self, element, property, val);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (element);
	_g_free0 (property);
	_tmp13_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp13_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_ElementSetPropertyLong (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	char* element = NULL;
	const char* _tmp14_;
	char* property = NULL;
	const char* _tmp15_;
	glong val = 0L;
	glong _tmp16_;
	DBusMessageIter _tmp17_;
	gboolean result;
	DBusMessage* reply;
	dbus_bool_t _tmp18_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "ss()")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp14_);
	dbus_message_iter_next (&iter);
	element = g_strdup (_tmp14_);
	dbus_message_iter_get_basic (&iter, &_tmp15_);
	dbus_message_iter_next (&iter);
	property = g_strdup (_tmp15_);
	dbus_message_iter_recurse (&iter, &_tmp17_);
	dbus_message_iter_next (&iter);
	val = _tmp16_;
	result = pipeline_ElementSetPropertyLong (self, element, property, val);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (element);
	_g_free0 (property);
	_tmp18_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp18_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_ElementSetPropertyString (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	char* element = NULL;
	const char* _tmp19_;
	char* property = NULL;
	const char* _tmp20_;
	char* val = NULL;
	const char* _tmp21_;
	gboolean result;
	DBusMessage* reply;
	dbus_bool_t _tmp22_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "sss")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp19_);
	dbus_message_iter_next (&iter);
	element = g_strdup (_tmp19_);
	dbus_message_iter_get_basic (&iter, &_tmp20_);
	dbus_message_iter_next (&iter);
	property = g_strdup (_tmp20_);
	dbus_message_iter_get_basic (&iter, &_tmp21_);
	dbus_message_iter_next (&iter);
	val = g_strdup (_tmp21_);
	result = pipeline_ElementSetPropertyString (self, element, property, val);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (element);
	_g_free0 (property);
	_g_free0 (val);
	_tmp22_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp22_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_ElementGetPropertyBoolean (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	char* element = NULL;
	const char* _tmp23_;
	char* property = NULL;
	const char* _tmp24_;
	gboolean result;
	DBusMessage* reply;
	dbus_bool_t _tmp25_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "ss")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp23_);
	dbus_message_iter_next (&iter);
	element = g_strdup (_tmp23_);
	dbus_message_iter_get_basic (&iter, &_tmp24_);
	dbus_message_iter_next (&iter);
	property = g_strdup (_tmp24_);
	result = pipeline_ElementGetPropertyBoolean (self, element, property);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (element);
	_g_free0 (property);
	_tmp25_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp25_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_ElementGetPropertyInt (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	char* element = NULL;
	const char* _tmp26_;
	char* property = NULL;
	const char* _tmp27_;
	gint result;
	DBusMessage* reply;
	dbus_int32_t _tmp28_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "ss")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp26_);
	dbus_message_iter_next (&iter);
	element = g_strdup (_tmp26_);
	dbus_message_iter_get_basic (&iter, &_tmp27_);
	dbus_message_iter_next (&iter);
	property = g_strdup (_tmp27_);
	result = pipeline_ElementGetPropertyInt (self, element, property);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (element);
	_g_free0 (property);
	_tmp28_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_INT32, &_tmp28_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_ElementGetPropertyLong (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	char* element = NULL;
	const char* _tmp29_;
	char* property = NULL;
	const char* _tmp30_;
	glong result;
	DBusMessage* reply;
	DBusMessageIter _tmp31_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "ss")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp29_);
	dbus_message_iter_next (&iter);
	element = g_strdup (_tmp29_);
	dbus_message_iter_get_basic (&iter, &_tmp30_);
	dbus_message_iter_next (&iter);
	property = g_strdup (_tmp30_);
	result = pipeline_ElementGetPropertyLong (self, element, property);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (element);
	_g_free0 (property);
	dbus_message_iter_open_container (&iter, DBUS_TYPE_STRUCT, NULL, &_tmp31_);
	dbus_message_iter_close_container (&iter, &_tmp31_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_ElementGetPropertyString (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	char* element = NULL;
	const char* _tmp32_;
	char* property = NULL;
	const char* _tmp33_;
	char* result;
	DBusMessage* reply;
	const char* _tmp34_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "ss")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp32_);
	dbus_message_iter_next (&iter);
	element = g_strdup (_tmp32_);
	dbus_message_iter_get_basic (&iter, &_tmp33_);
	dbus_message_iter_next (&iter);
	property = g_strdup (_tmp33_);
	result = pipeline_ElementGetPropertyString (self, element, property);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (element);
	_g_free0 (property);
	_tmp34_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &_tmp34_);
	_g_free0 (result);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_PipelineGetDuration (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gint result;
	DBusMessage* reply;
	dbus_int32_t _tmp35_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	result = pipeline_PipelineGetDuration (self);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_tmp35_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_INT32, &_tmp35_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_PipelineGetPosition (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gint result;
	DBusMessage* reply;
	dbus_int32_t _tmp36_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	result = pipeline_PipelineGetPosition (self);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_tmp36_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_INT32, &_tmp36_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


DBusHandlerResult pipeline_dbus_message (DBusConnection* connection, DBusMessage* message, void* object) {
	DBusHandlerResult result;
	result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Introspectable", "Introspect")) {
		result = _dbus_pipeline_introspect (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Properties", "GetAll")) {
		result = _dbus_pipeline_property_get_all (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "PipelineIsInitialized")) {
		result = _dbus_pipeline_PipelineIsInitialized (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "PipelineId")) {
		result = _dbus_pipeline_PipelineId (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "PipelinePlay")) {
		result = _dbus_pipeline_PipelinePlay (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "PipelinePause")) {
		result = _dbus_pipeline_PipelinePause (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "PipelineNull")) {
		result = _dbus_pipeline_PipelineNull (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "ElementSetPropertyBoolean")) {
		result = _dbus_pipeline_ElementSetPropertyBoolean (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "ElementSetPropertyInt")) {
		result = _dbus_pipeline_ElementSetPropertyInt (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "ElementSetPropertyLong")) {
		result = _dbus_pipeline_ElementSetPropertyLong (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "ElementSetPropertyString")) {
		result = _dbus_pipeline_ElementSetPropertyString (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "ElementGetPropertyBoolean")) {
		result = _dbus_pipeline_ElementGetPropertyBoolean (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "ElementGetPropertyInt")) {
		result = _dbus_pipeline_ElementGetPropertyInt (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "ElementGetPropertyLong")) {
		result = _dbus_pipeline_ElementGetPropertyLong (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "ElementGetPropertyString")) {
		result = _dbus_pipeline_ElementGetPropertyString (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "PipelineGetDuration")) {
		result = _dbus_pipeline_PipelineGetDuration (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "PipelineGetPosition")) {
		result = _dbus_pipeline_PipelineGetPosition (object, connection, message);
	}
	if (result == DBUS_HANDLER_RESULT_HANDLED) {
		return result;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static void _dbus_pipeline_eos (GObject* _sender, DBusConnection* _connection) {
	const char * _path;
	DBusMessage *_message;
	DBusMessageIter _iter;
	_path = g_object_get_data (_sender, "dbus_object_path");
	_message = dbus_message_new_signal (_path, "com.ridgerun.gstreamer.gstd.PipelineInterface", "Eos");
	dbus_message_iter_init_append (_message, &_iter);
	dbus_connection_send (_connection, _message, NULL);
	dbus_message_unref (_message);
}


static void _dbus_pipeline_state_changed (GObject* _sender, const char* old_state, const char* new_state, DBusConnection* _connection) {
	const char * _path;
	DBusMessage *_message;
	DBusMessageIter _iter;
	const char* _tmp37_;
	const char* _tmp38_;
	_path = g_object_get_data (_sender, "dbus_object_path");
	_message = dbus_message_new_signal (_path, "com.ridgerun.gstreamer.gstd.PipelineInterface", "StateChanged");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp37_ = old_state;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp37_);
	_tmp38_ = new_state;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp38_);
	dbus_connection_send (_connection, _message, NULL);
	dbus_message_unref (_message);
}


static void _dbus_pipeline_error (GObject* _sender, const char* err_message, DBusConnection* _connection) {
	const char * _path;
	DBusMessage *_message;
	DBusMessageIter _iter;
	const char* _tmp39_;
	_path = g_object_get_data (_sender, "dbus_object_path");
	_message = dbus_message_new_signal (_path, "com.ridgerun.gstreamer.gstd.PipelineInterface", "Error");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp39_ = err_message;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp39_);
	dbus_connection_send (_connection, _message, NULL);
	dbus_message_unref (_message);
}


void pipeline_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
	if (!g_object_get_data (object, "dbus_object_path")) {
		g_object_set_data (object, "dbus_object_path", g_strdup (path));
		dbus_connection_register_object_path (connection, path, &_pipeline_dbus_path_vtable, object);
		g_object_weak_ref (object, _vala_dbus_unregister_object, connection);
	}
	g_signal_connect (object, "eos", (GCallback) _dbus_pipeline_eos, connection);
	g_signal_connect (object, "state-changed", (GCallback) _dbus_pipeline_state_changed, connection);
	g_signal_connect (object, "error", (GCallback) _dbus_pipeline_error, connection);
}


static void pipeline_class_init (PipelineClass * klass) {
	pipeline_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (PipelinePrivate));
	G_OBJECT_CLASS (klass)->finalize = pipeline_finalize;
	g_signal_new ("eos", TYPE_PIPELINE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("state_changed", TYPE_PIPELINE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_STRING, G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_STRING);
	g_signal_new ("error", TYPE_PIPELINE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
	g_type_set_qdata (TYPE_PIPELINE, g_quark_from_static_string ("DBusObjectVTable"), (void*) (&_pipeline_dbus_vtable));
}


static void pipeline_instance_init (Pipeline * self) {
	self->priv = PIPELINE_GET_PRIVATE (self);
	self->priv->debug = FALSE;
	self->priv->initialized = FALSE;
	self->priv->id = -1;
}


static void pipeline_finalize (GObject* obj) {
	Pipeline * self;
	self = PIPELINE (obj);
	{
		if (!pipeline_PipelineSetState (self, GST_STATE_NULL)) {
			fprintf (stderr, "Gstd>Failed to destroy pipeline\n");
		}
	}
	_gst_object_unref0 (self->priv->pipeline);
	G_OBJECT_CLASS (pipeline_parent_class)->finalize (obj);
}


GType pipeline_get_type (void) {
	static GType pipeline_type_id = 0;
	if (pipeline_type_id == 0) {
		static const GTypeInfo g_define_type_info = { sizeof (PipelineClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) pipeline_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Pipeline), 0, (GInstanceInitFunc) pipeline_instance_init, NULL };
		pipeline_type_id = g_type_register_static (G_TYPE_OBJECT, "Pipeline", &g_define_type_info, 0);
	}
	return pipeline_type_id;
}


static void _vala_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
	const _DBusObjectVTable * vtable;
	vtable = g_type_get_qdata (G_TYPE_FROM_INSTANCE (object), g_quark_from_static_string ("DBusObjectVTable"));
	if (vtable) {
		vtable->register_object (connection, path, object);
	} else {
		g_warning ("Object does not implement any D-Bus interface");
	}
}


static void _vala_dbus_unregister_object (gpointer connection, GObject* object) {
	char* path;
	path = g_object_steal_data ((GObject*) object, "dbus_object_path");
	dbus_connection_unregister_object_path (connection, path);
	g_free (path);
}



static void g_cclosure_user_marshal_VOID__STRING_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__STRING_STRING) (gpointer data1, const char* arg_1, const char* arg_2, gpointer data2);
	register GMarshalFunc_VOID__STRING_STRING callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_STRING) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_string (param_values + 2), data2);
}



