/* gstd-pipeline.c generated by valac 0.11.3, the Vala compiler
 * generated from gstd-pipeline.vala, do not modify */

/*
 * gstd/src/gstd-pipeline.vala
 *
 * GStreamer daemon Pipeline class - framework for controlling audio and video streaming using D-Bus messages
 *
 * Copyright (c) 2010, RidgeRun
 * All rights reserved.
 *
 * GPL2 license - See http://www.opensource.org/licenses/gpl-2.0.php for complete text.
 */

#include <glib.h>
#include <glib-object.h>
#include <gst/gst.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <dbus/dbus.h>
#include <dbus/dbus-glib.h>
#include <dbus/dbus-glib-lowlevel.h>
#include <syslog.h>
#include <gst/interfaces/xoverlay.h>


#define TYPE_PIPELINE (pipeline_get_type ())
#define PIPELINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PIPELINE, Pipeline))
#define PIPELINE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PIPELINE, PipelineClass))
#define IS_PIPELINE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PIPELINE))
#define IS_PIPELINE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PIPELINE))
#define PIPELINE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PIPELINE, PipelineClass))

typedef struct _Pipeline Pipeline;
typedef struct _PipelineClass PipelineClass;
typedef struct _PipelinePrivate PipelinePrivate;
typedef struct _DBusObjectVTable _DBusObjectVTable;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _gst_object_unref0(var) ((var == NULL) ? NULL : (var = (gst_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_param_spec_unref0(var) ((var == NULL) ? NULL : (var = (g_param_spec_unref (var), NULL)))
#define _gst_buffer_unref0(var) ((var == NULL) ? NULL : (var = (gst_buffer_unref (var), NULL)))

struct _Pipeline {
	GObject parent_instance;
	PipelinePrivate * priv;
};

struct _PipelineClass {
	GObjectClass parent_class;
};

struct _PipelinePrivate {
	GstElement* pipeline;
	guint64 id;
	gboolean initialized;
	gchar* path;
	gdouble rate;
	gulong windowId;
};

struct _DBusObjectVTable {
	void (*register_object) (DBusConnection*, const char*, void*);
};


static gpointer pipeline_parent_class = NULL;

GType pipeline_get_type (void) G_GNUC_CONST;
#define PIPELINE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_PIPELINE, PipelinePrivate))
enum  {
	PIPELINE_DUMMY_PROPERTY
};
static void _vala_dbus_register_object (DBusConnection* connection, const char* path, void* object);
static void _vala_dbus_unregister_object (gpointer connection, GObject* object);
void pipeline_dbus_register_object (DBusConnection* connection, const char* path, void* object);
void _pipeline_dbus_unregister (DBusConnection* connection, void* _user_data_);
DBusHandlerResult pipeline_dbus_message (DBusConnection* connection, DBusMessage* message, void* object);
static DBusHandlerResult _dbus_pipeline_introspect (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_property_get_all (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_PipelineSetState (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_PipelineAsyncSetState (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_PipelineIsInitialized (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_PipelineGetId (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_PipelineSetId (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_PipelineGetPath (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_PipelineSetPath (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_PipelineGetState (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_ElementSetPropertyBoolean (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_ElementSetPropertyInt (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_ElementSetPropertyInt64 (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_ElementSetPropertyString (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_ElementGetPropertyBoolean (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_ElementGetPropertyInt (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_ElementGetPropertyInt64 (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_ElementGetPropertyString (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_ElementGetState (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_ElementGetPropertyBuffer (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_PipelineGetDuration (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_PipelineGetPosition (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_PipelineSeek (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_PipelineAsyncSeek (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_PipelineSkip (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_PipelineSpeed (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_PipelineSendEoS (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_ElementSetState (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_ElementAsyncSetState (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_SetWindowId (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_pipeline_Ping (Pipeline* self, DBusConnection* connection, DBusMessage* message);
static void _dbus_pipeline_eo_s (GObject* _sender, guint64 pipe_id, DBusConnection* _connection);
static void _dbus_pipeline_state_changed (GObject* _sender, guint64 pipe_id, GstState old_state, GstState new_state, const gchar* src, DBusConnection* _connection);
static void _dbus_pipeline_error (GObject* _sender, guint64 pipe_id, const gchar* err_message, DBusConnection* _connection);
static void _dbus_pipeline_qo_s (GObject* _sender, guint64 pipe_id, gboolean live, guint64 running_time, guint64 stream_time, guint64 timestamp, guint64 duration, gint64 jitter, gdouble proportion, gint quality, gint format, guint64 processed, guint64 dropped, DBusConnection* _connection);
gboolean pipeline_PipelineIsInitialized (Pipeline* self);
static gboolean pipeline_PipelineSetStateImpl (Pipeline* self, GstState state);
Pipeline* pipeline_new (const gchar* description);
Pipeline* pipeline_construct (GType object_type, const gchar* description);
static GstBusSyncReply pipeline_bus_sync_callback (Pipeline* self, GstBus* bus, GstMessage* message);
static GstBusSyncReply _pipeline_bus_sync_callback_gst_bus_sync_handler (GstBus* bus, GstMessage* message, gpointer self);
static gboolean pipeline_bus_callback (Pipeline* self, GstBus* bus, GstMessage* message);
static gboolean _pipeline_bus_callback_gst_bus_func (GstBus* bus, GstMessage* message, gpointer self);
guint64 pipeline_PipelineGetId (Pipeline* self);
gboolean pipeline_PipelineSetState (Pipeline* self, gint state);
static void pipeline_PipelineAsyncSetStateImpl (Pipeline* self, GstState state);
void pipeline_PipelineAsyncSetState (Pipeline* self, gint state);
void pipeline_PipelineSetId (Pipeline* self, guint64 id);
gchar* pipeline_PipelineGetPath (Pipeline* self);
gboolean pipeline_PipelineSetPath (Pipeline* self, const gchar* dbuspath);
gint pipeline_PipelineGetState (Pipeline* self);
gboolean pipeline_ElementSetPropertyBoolean (Pipeline* self, const gchar* element, const gchar* property, gboolean val);
gboolean pipeline_ElementSetPropertyInt (Pipeline* self, const gchar* element, const gchar* property, gint val);
gboolean pipeline_ElementSetPropertyInt64 (Pipeline* self, const gchar* element, const gchar* property, gint64 val);
gboolean pipeline_ElementSetPropertyString (Pipeline* self, const gchar* element, const gchar* property, const gchar* val);
gboolean pipeline_ElementGetPropertyBoolean (Pipeline* self, const gchar* element, const gchar* property, gboolean* val);
gboolean pipeline_ElementGetPropertyInt (Pipeline* self, const gchar* element, const gchar* property, gint* val);
gboolean pipeline_ElementGetPropertyInt64 (Pipeline* self, const gchar* element, const gchar* property, gint64* val);
gboolean pipeline_ElementGetPropertyString (Pipeline* self, const gchar* element, const gchar* property, gchar** val);
gint pipeline_ElementGetState (Pipeline* self, const gchar* element);
gboolean pipeline_ElementGetPropertyBuffer (Pipeline* self, const gchar* element, const gchar* property, gchar** caps, guint8** data, int* data_length1);
static guint8* _vala_array_dup1 (guint8* self, int length);
gint64 pipeline_PipelineGetDuration (Pipeline* self);
gint64 pipeline_PipelineGetPosition (Pipeline* self);
gboolean pipeline_PipelineSeek (Pipeline* self, gint64 ipos_ns);
void pipeline_PipelineAsyncSeek (Pipeline* self, gint64 ipos_ms);
gboolean pipeline_PipelineSkip (Pipeline* self, gint64 period_ns);
gboolean pipeline_PipelineSpeed (Pipeline* self, gdouble new_rate);
void pipeline_PipelineSendEoS (Pipeline* self);
gboolean pipeline_ElementSetState (Pipeline* self, const gchar* element, gint state);
void pipeline_ElementAsyncSetState (Pipeline* self, const gchar* element, gint state);
void pipeline_SetWindowId (Pipeline* self, guint64 winId);
gboolean pipeline_Ping (Pipeline* self);
static void g_cclosure_user_marshal_VOID__UINT64 (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void g_cclosure_user_marshal_VOID__UINT64_ENUM_ENUM_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void g_cclosure_user_marshal_VOID__UINT64_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void g_cclosure_user_marshal_VOID__UINT64_BOOLEAN_UINT64_UINT64_UINT64_UINT64_INT64_DOUBLE_INT_INT_UINT64_UINT64 (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void pipeline_finalize (GObject* obj);

static const DBusObjectPathVTable _pipeline_dbus_path_vtable = {_pipeline_dbus_unregister, pipeline_dbus_message};
static const _DBusObjectVTable _pipeline_dbus_vtable = {pipeline_dbus_register_object};

static void _vala_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
	const _DBusObjectVTable * vtable;
	vtable = g_type_get_qdata (G_TYPE_FROM_INSTANCE (object), g_quark_from_static_string ("DBusObjectVTable"));
	if (vtable) {
		vtable->register_object (connection, path, object);
	} else {
		g_warning ("Object does not implement any D-Bus interface");
	}
}


static void _vala_dbus_unregister_object (gpointer connection, GObject* object) {
	char* path;
	path = g_object_steal_data ((GObject*) object, "dbus_object_path");
	dbus_connection_unregister_object_path (connection, path);
	g_free (path);
}


void _pipeline_dbus_unregister (DBusConnection* connection, void* _user_data_) {
}


static DBusHandlerResult _dbus_pipeline_introspect (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter;
	GString* xml_data;
	char** children;
	int i;
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	xml_data = g_string_new ("<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\" \"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n");
	g_string_append (xml_data, "<node>\n<interface name=\"org.freedesktop.DBus.Introspectable\">\n  <method name=\"Introspect\">\n    <arg name=\"data\" direction=\"out\" type=\"s\"/>\n  </method>\n</interface>\n<interface name=\"org.freedesktop.DBus.Properties\">\n  <method name=\"Get\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"out\" type=\"v\"/>\n  </method>\n  <method name=\"Set\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"in\" type=\"v\"/>\n  </method>\n  <method name=\"GetAll\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"props\" direction=\"out\" type=\"a{sv}\"/>\n  </method>\n</interface>\n<interface name=\"com.ridgerun.gstreamer.gstd.PipelineInterface\">\n  <method name=\"PipelineSetState\">\n    <arg name=\"state\" type=\"i\" direction=\"in\"/>\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"PipelineAsyncSetState\">\n    <arg name=\"state\" type=\"i\" direction=\"in\"/>\n  </method>\n  <method name=\"PipelineIsInitialized\">\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"PipelineGetId\">\n    <arg name=\"result\" type=\"t\" direction=\"out\"/>\n  </method>\n  <method name=\"PipelineSetId\">\n    <arg name=\"id\" type=\"t\" direction=\"in\"/>\n  </method>\n  <method name=\"PipelineGetPath\">\n    <arg name=\"result\" type=\"s\" direction=\"out\"/>\n  </method>\n  <method name=\"PipelineSetPath\">\n    <arg name=\"dbuspath\" type=\"s\" direction=\"in\"/>\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"PipelineGetState\">\n    <arg name=\"result\" type=\"i\" direction=\"out\"/>\n  </method>\n  <method name=\"ElementSetPropertyBoolean\">\n    <arg name=\"element\" type=\"s\" direction=\"in\"/>\n    <arg name=\"property\" type=\"s\" direction=\"in\"/>\n    <arg name=\"val\" type=\"b\" direction=\"in\"/>\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"ElementSetPropertyInt\">\n    <arg name=\"element\" type=\"s\" direction=\"in\"/>\n    <arg name=\"property\" type=\"s\" direction=\"in\"/>\n    <arg name=\"val\" type=\"i\" direction=\"in\"/>\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"ElementSetPropertyInt64\">\n    <arg name=\"element\" type=\"s\" direction=\"in\"/>\n    <arg name=\"property\" type=\"s\" direction=\"in\"/>\n    <arg name=\"val\" type=\"x\" direction=\"in\"/>\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"ElementSetPropertyString\">\n    <arg name=\"element\" type=\"s\" direction=\"in\"/>\n    <arg name=\"property\" type=\"s\" direction=\"in\"/>\n    <arg name=\"val\" type=\"s\" direction=\"in\"/>\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"ElementGetPropertyBoolean\">\n    <arg name=\"element\" type=\"s\" direction=\"in\"/>\n    <arg name=\"property\" type=\"s\" direction=\"in\"/>\n    <arg name=\"val\" type=\"b\" direction=\"out\"/>\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"ElementGetPropertyInt\">\n    <arg name=\"element\" type=\"s\" direction=\"in\"/>\n    <arg name=\"property\" type=\"s\" direction=\"in\"/>\n    <arg name=\"val\" type=\"i\" direction=\"out\"/>\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"ElementGetPropertyInt64\">\n    <arg name=\"element\" type=\"s\" direction=\"in\"/>\n    <arg name=\"property\" type=\"s\" direction=\"in\"/>\n    <arg name=\"val\" type=\"x\" direction=\"out\"/>\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"ElementGetPropertyString\">\n    <arg name=\"element\" type=\"s\" direction=\"in\"/>\n    <arg name=\"property\" type=\"s\" direction=\"in\"/>\n    <arg name=\"val\" type=\"s\" direction=\"out\"/>\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"ElementGetState\">\n    <arg name=\"element\" type=\"s\" direction=\"in\"/>\n    <arg name=\"result\" type=\"i\" direction=\"out\"/>\n  </method>\n  <method name=\"ElementGetPropertyBuffer\">\n    <arg name=\"element\" type=\"s\" direction=\"in\"/>\n    <arg name=\"property\" type=\"s\" direction=\"in\"/>\n    <arg name=\"caps\" type=\"s\" direction=\"out\"/>\n    <arg name=\"data\" type=\"ay\" direction=\"out\"/>\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"PipelineGetDuration\">\n    <arg name=\"result\" type=\"x\" direction=\"out\"/>\n  </method>\n  <method name=\"PipelineGetPosition\">\n    <arg name=\"result\" type=\"x\" direction=\"out\"/>\n  </method>\n  <method name=\"PipelineSeek\">\n    <arg name=\"ipos_ns\" type=\"x\" direction=\"in\"/>\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"PipelineAsyncSeek\">\n    <arg name=\"ipos_ms\" type=\"x\" direction=\"in\"/>\n  </method>\n  <method name=\"PipelineSkip\">\n    <arg name=\"period_ns\" type=\"x\" direction=\"in\"/>\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"PipelineSpeed\">\n    <arg name=\"new_rate\" type=\"d\" direction=\"in\"/>\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"PipelineSendEoS\">\n  </method>\n  <method name=\"ElementSetState\">\n    <arg name=\"element\" type=\"s\" direction=\"in\"/>\n    <arg name=\"state\" type=\"i\" direction=\"in\"/>\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"ElementAsyncSetState\">\n    <arg name=\"element\" type=\"s\" direction=\"in\"/>\n    <arg name=\"state\" type=\"i\" direction=\"in\"/>\n  </method>\n  <method name=\"SetWindowId\">\n    <arg name=\"winId\" type=\"t\" direction=\"in\"/>\n  </method>\n  <method name=\"Ping\">\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <signal name=\"EoS\">\n    <arg name=\"pipe_id\" type=\"t\"/>\n  </signal>\n  <signal name=\"StateChanged\">\n    <arg name=\"pipe_id\" type=\"t\"/>\n    <arg name=\"old_state\" type=\"i\"/>\n    <arg name=\"new_state\" type=\"i\"/>\n    <arg name=\"src\" type=\"s\"/>\n  </signal>\n  <signal name=\"Error\">\n    <arg name=\"pipe_id\" type=\"t\"/>\n    <arg name=\"err_message\" type=\"s\"/>\n  </signal>\n  <signal name=\"QoS\">\n    <arg name=\"pipe_id\" type=\"t\"/>\n    <arg name=\"live\" type=\"b\"/>\n    <arg name=\"running_time\" type=\"t\"/>\n    <arg name=\"stream_time\" type=\"t\"/>\n    <arg name=\"timestamp\" type=\"t\"/>\n    <arg name=\"duration\" type=\"t\"/>\n    <arg name=\"jitter\" type=\"x\"/>\n    <arg name=\"proportion\" type=\"d\"/>\n    <arg name=\"quality\" type=\"i\"/>\n    <arg name=\"format\" type=\"i\"/>\n    <arg name=\"processed\" type=\"t\"/>\n    <arg name=\"dropped\" type=\"t\"/>\n  </signal>\n</interface>\n");
	dbus_connection_list_registered (connection, g_object_get_data ((GObject *) self, "dbus_object_path"), &children);
	for (i = 0; children[i]; i++) {
		g_string_append_printf (xml_data, "<node name=\"%s\"/>\n", children[i]);
	}
	dbus_free_string_array (children);
	g_string_append (xml_data, "</node>\n");
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &xml_data->str);
	g_string_free (xml_data, TRUE);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_property_get_all (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter, reply_iter, subiter;
	char* interface_name;
	const char* _tmp0_;
	if (strcmp (dbus_message_get_signature (message), "s")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &reply_iter);
	dbus_message_iter_get_basic (&iter, &_tmp0_);
	dbus_message_iter_next (&iter);
	interface_name = g_strdup (_tmp0_);
	if (strcmp (interface_name, "com.ridgerun.gstreamer.gstd.PipelineInterface") == 0) {
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_ARRAY, "{sv}", &subiter);
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else {
		dbus_message_unref (reply);
		reply = NULL;
	}
	g_free (interface_name);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_PipelineSetState (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gint state = 0;
	dbus_int32_t _tmp1_;
	gboolean result;
	DBusMessage* reply;
	dbus_bool_t _tmp2_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "i")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp1_);
	dbus_message_iter_next (&iter);
	state = _tmp1_;
	result = pipeline_PipelineSetState (self, state);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_tmp2_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp2_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_PipelineAsyncSetState (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gint state = 0;
	dbus_int32_t _tmp3_;
	DBusMessage* reply;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "i")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp3_);
	dbus_message_iter_next (&iter);
	state = _tmp3_;
	pipeline_PipelineAsyncSetState (self, state);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_PipelineIsInitialized (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gboolean result;
	DBusMessage* reply;
	dbus_bool_t _tmp4_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	result = pipeline_PipelineIsInitialized (self);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_tmp4_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp4_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_PipelineGetId (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	guint64 result;
	DBusMessage* reply;
	dbus_uint64_t _tmp5_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	result = pipeline_PipelineGetId (self);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_tmp5_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT64, &_tmp5_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_PipelineSetId (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	guint64 id = 0ULL;
	dbus_uint64_t _tmp6_;
	DBusMessage* reply;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "t")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp6_);
	dbus_message_iter_next (&iter);
	id = _tmp6_;
	pipeline_PipelineSetId (self, id);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_PipelineGetPath (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gchar* result;
	DBusMessage* reply;
	const char* _tmp7_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	result = pipeline_PipelineGetPath (self);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_tmp7_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &_tmp7_);
	_g_free0 (result);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_PipelineSetPath (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gchar* dbuspath = NULL;
	const char* _tmp8_;
	gboolean result;
	DBusMessage* reply;
	dbus_bool_t _tmp9_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "s")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp8_);
	dbus_message_iter_next (&iter);
	dbuspath = g_strdup (_tmp8_);
	result = pipeline_PipelineSetPath (self, dbuspath);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (dbuspath);
	_tmp9_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp9_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_PipelineGetState (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gint result;
	DBusMessage* reply;
	dbus_int32_t _tmp10_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	result = pipeline_PipelineGetState (self);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_tmp10_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_INT32, &_tmp10_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_ElementSetPropertyBoolean (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gchar* element = NULL;
	const char* _tmp11_;
	gchar* property = NULL;
	const char* _tmp12_;
	gboolean val = FALSE;
	dbus_bool_t _tmp13_;
	gboolean result;
	DBusMessage* reply;
	dbus_bool_t _tmp14_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "ssb")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp11_);
	dbus_message_iter_next (&iter);
	element = g_strdup (_tmp11_);
	dbus_message_iter_get_basic (&iter, &_tmp12_);
	dbus_message_iter_next (&iter);
	property = g_strdup (_tmp12_);
	dbus_message_iter_get_basic (&iter, &_tmp13_);
	dbus_message_iter_next (&iter);
	val = _tmp13_;
	result = pipeline_ElementSetPropertyBoolean (self, element, property, val);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (element);
	_g_free0 (property);
	_tmp14_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp14_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_ElementSetPropertyInt (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gchar* element = NULL;
	const char* _tmp15_;
	gchar* property = NULL;
	const char* _tmp16_;
	gint val = 0;
	dbus_int32_t _tmp17_;
	gboolean result;
	DBusMessage* reply;
	dbus_bool_t _tmp18_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "ssi")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp15_);
	dbus_message_iter_next (&iter);
	element = g_strdup (_tmp15_);
	dbus_message_iter_get_basic (&iter, &_tmp16_);
	dbus_message_iter_next (&iter);
	property = g_strdup (_tmp16_);
	dbus_message_iter_get_basic (&iter, &_tmp17_);
	dbus_message_iter_next (&iter);
	val = _tmp17_;
	result = pipeline_ElementSetPropertyInt (self, element, property, val);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (element);
	_g_free0 (property);
	_tmp18_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp18_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_ElementSetPropertyInt64 (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gchar* element = NULL;
	const char* _tmp19_;
	gchar* property = NULL;
	const char* _tmp20_;
	gint64 val = 0LL;
	dbus_int64_t _tmp21_;
	gboolean result;
	DBusMessage* reply;
	dbus_bool_t _tmp22_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "ssx")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp19_);
	dbus_message_iter_next (&iter);
	element = g_strdup (_tmp19_);
	dbus_message_iter_get_basic (&iter, &_tmp20_);
	dbus_message_iter_next (&iter);
	property = g_strdup (_tmp20_);
	dbus_message_iter_get_basic (&iter, &_tmp21_);
	dbus_message_iter_next (&iter);
	val = _tmp21_;
	result = pipeline_ElementSetPropertyInt64 (self, element, property, val);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (element);
	_g_free0 (property);
	_tmp22_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp22_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_ElementSetPropertyString (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gchar* element = NULL;
	const char* _tmp23_;
	gchar* property = NULL;
	const char* _tmp24_;
	gchar* val = NULL;
	const char* _tmp25_;
	gboolean result;
	DBusMessage* reply;
	dbus_bool_t _tmp26_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "sss")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp23_);
	dbus_message_iter_next (&iter);
	element = g_strdup (_tmp23_);
	dbus_message_iter_get_basic (&iter, &_tmp24_);
	dbus_message_iter_next (&iter);
	property = g_strdup (_tmp24_);
	dbus_message_iter_get_basic (&iter, &_tmp25_);
	dbus_message_iter_next (&iter);
	val = g_strdup (_tmp25_);
	result = pipeline_ElementSetPropertyString (self, element, property, val);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (element);
	_g_free0 (property);
	_g_free0 (val);
	_tmp26_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp26_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_ElementGetPropertyBoolean (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gchar* element = NULL;
	const char* _tmp27_;
	gchar* property = NULL;
	const char* _tmp28_;
	gboolean val = FALSE;
	gboolean result;
	DBusMessage* reply;
	dbus_bool_t _tmp29_;
	dbus_bool_t _tmp30_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "ss")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp27_);
	dbus_message_iter_next (&iter);
	element = g_strdup (_tmp27_);
	dbus_message_iter_get_basic (&iter, &_tmp28_);
	dbus_message_iter_next (&iter);
	property = g_strdup (_tmp28_);
	result = pipeline_ElementGetPropertyBoolean (self, element, property, &val);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (element);
	_g_free0 (property);
	_tmp29_ = val;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp29_);
	_tmp30_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp30_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_ElementGetPropertyInt (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gchar* element = NULL;
	const char* _tmp31_;
	gchar* property = NULL;
	const char* _tmp32_;
	gint val = 0;
	gboolean result;
	DBusMessage* reply;
	dbus_int32_t _tmp33_;
	dbus_bool_t _tmp34_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "ss")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp31_);
	dbus_message_iter_next (&iter);
	element = g_strdup (_tmp31_);
	dbus_message_iter_get_basic (&iter, &_tmp32_);
	dbus_message_iter_next (&iter);
	property = g_strdup (_tmp32_);
	result = pipeline_ElementGetPropertyInt (self, element, property, &val);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (element);
	_g_free0 (property);
	_tmp33_ = val;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_INT32, &_tmp33_);
	_tmp34_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp34_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_ElementGetPropertyInt64 (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gchar* element = NULL;
	const char* _tmp35_;
	gchar* property = NULL;
	const char* _tmp36_;
	gint64 val = 0LL;
	gboolean result;
	DBusMessage* reply;
	dbus_int64_t _tmp37_;
	dbus_bool_t _tmp38_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "ss")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp35_);
	dbus_message_iter_next (&iter);
	element = g_strdup (_tmp35_);
	dbus_message_iter_get_basic (&iter, &_tmp36_);
	dbus_message_iter_next (&iter);
	property = g_strdup (_tmp36_);
	result = pipeline_ElementGetPropertyInt64 (self, element, property, &val);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (element);
	_g_free0 (property);
	_tmp37_ = val;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_INT64, &_tmp37_);
	_tmp38_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp38_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_ElementGetPropertyString (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gchar* element = NULL;
	const char* _tmp39_;
	gchar* property = NULL;
	const char* _tmp40_;
	gchar* val = NULL;
	gboolean result;
	DBusMessage* reply;
	const char* _tmp41_;
	dbus_bool_t _tmp42_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "ss")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp39_);
	dbus_message_iter_next (&iter);
	element = g_strdup (_tmp39_);
	dbus_message_iter_get_basic (&iter, &_tmp40_);
	dbus_message_iter_next (&iter);
	property = g_strdup (_tmp40_);
	result = pipeline_ElementGetPropertyString (self, element, property, &val);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (element);
	_g_free0 (property);
	_tmp41_ = val;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &_tmp41_);
	_g_free0 (val);
	_tmp42_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp42_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_ElementGetState (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gchar* element = NULL;
	const char* _tmp43_;
	gint result;
	DBusMessage* reply;
	dbus_int32_t _tmp44_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "s")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp43_);
	dbus_message_iter_next (&iter);
	element = g_strdup (_tmp43_);
	result = pipeline_ElementGetState (self, element);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (element);
	_tmp44_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_INT32, &_tmp44_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_ElementGetPropertyBuffer (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gchar* element = NULL;
	const char* _tmp45_;
	gchar* property = NULL;
	const char* _tmp46_;
	gchar* caps = NULL;
	guint8* data = NULL;
	int data_length1;
	gboolean result;
	DBusMessage* reply;
	const char* _tmp47_;
	guint8* _tmp48_;
	DBusMessageIter _tmp49_;
	int _tmp50_;
	dbus_bool_t _tmp52_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "ss")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp45_);
	dbus_message_iter_next (&iter);
	element = g_strdup (_tmp45_);
	dbus_message_iter_get_basic (&iter, &_tmp46_);
	dbus_message_iter_next (&iter);
	property = g_strdup (_tmp46_);
	data_length1 = 0;
	result = pipeline_ElementGetPropertyBuffer (self, element, property, &caps, &data, &data_length1);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (element);
	_g_free0 (property);
	_tmp47_ = caps;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &_tmp47_);
	_g_free0 (caps);
	_tmp48_ = data;
	dbus_message_iter_open_container (&iter, DBUS_TYPE_ARRAY, "y", &_tmp49_);
	for (_tmp50_ = 0; _tmp50_ < data_length1; _tmp50_++) {
		guint8 _tmp51_;
		_tmp51_ = *_tmp48_;
		dbus_message_iter_append_basic (&_tmp49_, DBUS_TYPE_BYTE, &_tmp51_);
		_tmp48_++;
	}
	dbus_message_iter_close_container (&iter, &_tmp49_);
	data = (g_free (data), NULL);
	_tmp52_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp52_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_PipelineGetDuration (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gint64 result;
	DBusMessage* reply;
	dbus_int64_t _tmp53_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	result = pipeline_PipelineGetDuration (self);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_tmp53_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_INT64, &_tmp53_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_PipelineGetPosition (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gint64 result;
	DBusMessage* reply;
	dbus_int64_t _tmp54_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	result = pipeline_PipelineGetPosition (self);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_tmp54_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_INT64, &_tmp54_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_PipelineSeek (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gint64 ipos_ns = 0LL;
	dbus_int64_t _tmp55_;
	gboolean result;
	DBusMessage* reply;
	dbus_bool_t _tmp56_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "x")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp55_);
	dbus_message_iter_next (&iter);
	ipos_ns = _tmp55_;
	result = pipeline_PipelineSeek (self, ipos_ns);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_tmp56_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp56_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_PipelineAsyncSeek (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gint64 ipos_ms = 0LL;
	dbus_int64_t _tmp57_;
	DBusMessage* reply;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "x")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp57_);
	dbus_message_iter_next (&iter);
	ipos_ms = _tmp57_;
	pipeline_PipelineAsyncSeek (self, ipos_ms);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_PipelineSkip (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gint64 period_ns = 0LL;
	dbus_int64_t _tmp58_;
	gboolean result;
	DBusMessage* reply;
	dbus_bool_t _tmp59_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "x")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp58_);
	dbus_message_iter_next (&iter);
	period_ns = _tmp58_;
	result = pipeline_PipelineSkip (self, period_ns);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_tmp59_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp59_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_PipelineSpeed (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gdouble new_rate = 0.0;
	double _tmp60_;
	gboolean result;
	DBusMessage* reply;
	dbus_bool_t _tmp61_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "d")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp60_);
	dbus_message_iter_next (&iter);
	new_rate = _tmp60_;
	result = pipeline_PipelineSpeed (self, new_rate);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_tmp61_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp61_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_PipelineSendEoS (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	DBusMessage* reply;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	pipeline_PipelineSendEoS (self);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_ElementSetState (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gchar* element = NULL;
	const char* _tmp62_;
	gint state = 0;
	dbus_int32_t _tmp63_;
	gboolean result;
	DBusMessage* reply;
	dbus_bool_t _tmp64_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "si")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp62_);
	dbus_message_iter_next (&iter);
	element = g_strdup (_tmp62_);
	dbus_message_iter_get_basic (&iter, &_tmp63_);
	dbus_message_iter_next (&iter);
	state = _tmp63_;
	result = pipeline_ElementSetState (self, element, state);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (element);
	_tmp64_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp64_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_ElementAsyncSetState (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gchar* element = NULL;
	const char* _tmp65_;
	gint state = 0;
	dbus_int32_t _tmp66_;
	DBusMessage* reply;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "si")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp65_);
	dbus_message_iter_next (&iter);
	element = g_strdup (_tmp65_);
	dbus_message_iter_get_basic (&iter, &_tmp66_);
	dbus_message_iter_next (&iter);
	state = _tmp66_;
	pipeline_ElementAsyncSetState (self, element, state);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (element);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_SetWindowId (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	guint64 winId = 0ULL;
	dbus_uint64_t _tmp67_;
	DBusMessage* reply;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "t")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp67_);
	dbus_message_iter_next (&iter);
	winId = _tmp67_;
	pipeline_SetWindowId (self, winId);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_pipeline_Ping (Pipeline* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gboolean result;
	DBusMessage* reply;
	dbus_bool_t _tmp68_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	result = pipeline_Ping (self);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_tmp68_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp68_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


DBusHandlerResult pipeline_dbus_message (DBusConnection* connection, DBusMessage* message, void* object) {
	DBusHandlerResult result;
	result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Introspectable", "Introspect")) {
		result = _dbus_pipeline_introspect (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Properties", "GetAll")) {
		result = _dbus_pipeline_property_get_all (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "PipelineSetState")) {
		result = _dbus_pipeline_PipelineSetState (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "PipelineAsyncSetState")) {
		result = _dbus_pipeline_PipelineAsyncSetState (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "PipelineIsInitialized")) {
		result = _dbus_pipeline_PipelineIsInitialized (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "PipelineGetId")) {
		result = _dbus_pipeline_PipelineGetId (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "PipelineSetId")) {
		result = _dbus_pipeline_PipelineSetId (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "PipelineGetPath")) {
		result = _dbus_pipeline_PipelineGetPath (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "PipelineSetPath")) {
		result = _dbus_pipeline_PipelineSetPath (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "PipelineGetState")) {
		result = _dbus_pipeline_PipelineGetState (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "ElementSetPropertyBoolean")) {
		result = _dbus_pipeline_ElementSetPropertyBoolean (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "ElementSetPropertyInt")) {
		result = _dbus_pipeline_ElementSetPropertyInt (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "ElementSetPropertyInt64")) {
		result = _dbus_pipeline_ElementSetPropertyInt64 (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "ElementSetPropertyString")) {
		result = _dbus_pipeline_ElementSetPropertyString (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "ElementGetPropertyBoolean")) {
		result = _dbus_pipeline_ElementGetPropertyBoolean (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "ElementGetPropertyInt")) {
		result = _dbus_pipeline_ElementGetPropertyInt (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "ElementGetPropertyInt64")) {
		result = _dbus_pipeline_ElementGetPropertyInt64 (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "ElementGetPropertyString")) {
		result = _dbus_pipeline_ElementGetPropertyString (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "ElementGetState")) {
		result = _dbus_pipeline_ElementGetState (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "ElementGetPropertyBuffer")) {
		result = _dbus_pipeline_ElementGetPropertyBuffer (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "PipelineGetDuration")) {
		result = _dbus_pipeline_PipelineGetDuration (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "PipelineGetPosition")) {
		result = _dbus_pipeline_PipelineGetPosition (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "PipelineSeek")) {
		result = _dbus_pipeline_PipelineSeek (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "PipelineAsyncSeek")) {
		result = _dbus_pipeline_PipelineAsyncSeek (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "PipelineSkip")) {
		result = _dbus_pipeline_PipelineSkip (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "PipelineSpeed")) {
		result = _dbus_pipeline_PipelineSpeed (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "PipelineSendEoS")) {
		result = _dbus_pipeline_PipelineSendEoS (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "ElementSetState")) {
		result = _dbus_pipeline_ElementSetState (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "ElementAsyncSetState")) {
		result = _dbus_pipeline_ElementAsyncSetState (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "SetWindowId")) {
		result = _dbus_pipeline_SetWindowId (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ridgerun.gstreamer.gstd.PipelineInterface", "Ping")) {
		result = _dbus_pipeline_Ping (object, connection, message);
	}
	if (result == DBUS_HANDLER_RESULT_HANDLED) {
		return result;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static void _dbus_pipeline_eo_s (GObject* _sender, guint64 pipe_id, DBusConnection* _connection) {
	const char * _path;
	DBusMessage *_message;
	DBusMessageIter _iter;
	dbus_uint64_t _tmp69_;
	_path = g_object_get_data (_sender, "dbus_object_path");
	_message = dbus_message_new_signal (_path, "com.ridgerun.gstreamer.gstd.PipelineInterface", "EoS");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp69_ = pipe_id;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_UINT64, &_tmp69_);
	dbus_connection_send (_connection, _message, NULL);
	dbus_message_unref (_message);
}


static void _dbus_pipeline_state_changed (GObject* _sender, guint64 pipe_id, GstState old_state, GstState new_state, const gchar* src, DBusConnection* _connection) {
	const char * _path;
	DBusMessage *_message;
	DBusMessageIter _iter;
	dbus_uint64_t _tmp70_;
	dbus_int32_t _tmp71_;
	dbus_int32_t _tmp72_;
	const char* _tmp73_;
	_path = g_object_get_data (_sender, "dbus_object_path");
	_message = dbus_message_new_signal (_path, "com.ridgerun.gstreamer.gstd.PipelineInterface", "StateChanged");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp70_ = pipe_id;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_UINT64, &_tmp70_);
	_tmp71_ = old_state;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_INT32, &_tmp71_);
	_tmp72_ = new_state;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_INT32, &_tmp72_);
	_tmp73_ = src;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp73_);
	dbus_connection_send (_connection, _message, NULL);
	dbus_message_unref (_message);
}


static void _dbus_pipeline_error (GObject* _sender, guint64 pipe_id, const gchar* err_message, DBusConnection* _connection) {
	const char * _path;
	DBusMessage *_message;
	DBusMessageIter _iter;
	dbus_uint64_t _tmp74_;
	const char* _tmp75_;
	_path = g_object_get_data (_sender, "dbus_object_path");
	_message = dbus_message_new_signal (_path, "com.ridgerun.gstreamer.gstd.PipelineInterface", "Error");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp74_ = pipe_id;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_UINT64, &_tmp74_);
	_tmp75_ = err_message;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp75_);
	dbus_connection_send (_connection, _message, NULL);
	dbus_message_unref (_message);
}


static void _dbus_pipeline_qo_s (GObject* _sender, guint64 pipe_id, gboolean live, guint64 running_time, guint64 stream_time, guint64 timestamp, guint64 duration, gint64 jitter, gdouble proportion, gint quality, gint format, guint64 processed, guint64 dropped, DBusConnection* _connection) {
	const char * _path;
	DBusMessage *_message;
	DBusMessageIter _iter;
	dbus_uint64_t _tmp76_;
	dbus_bool_t _tmp77_;
	dbus_uint64_t _tmp78_;
	dbus_uint64_t _tmp79_;
	dbus_uint64_t _tmp80_;
	dbus_uint64_t _tmp81_;
	dbus_int64_t _tmp82_;
	double _tmp83_;
	dbus_int32_t _tmp84_;
	dbus_int32_t _tmp85_;
	dbus_uint64_t _tmp86_;
	dbus_uint64_t _tmp87_;
	_path = g_object_get_data (_sender, "dbus_object_path");
	_message = dbus_message_new_signal (_path, "com.ridgerun.gstreamer.gstd.PipelineInterface", "QoS");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp76_ = pipe_id;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_UINT64, &_tmp76_);
	_tmp77_ = live;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_BOOLEAN, &_tmp77_);
	_tmp78_ = running_time;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_UINT64, &_tmp78_);
	_tmp79_ = stream_time;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_UINT64, &_tmp79_);
	_tmp80_ = timestamp;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_UINT64, &_tmp80_);
	_tmp81_ = duration;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_UINT64, &_tmp81_);
	_tmp82_ = jitter;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_INT64, &_tmp82_);
	_tmp83_ = proportion;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_DOUBLE, &_tmp83_);
	_tmp84_ = quality;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_INT32, &_tmp84_);
	_tmp85_ = format;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_INT32, &_tmp85_);
	_tmp86_ = processed;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_UINT64, &_tmp86_);
	_tmp87_ = dropped;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_UINT64, &_tmp87_);
	dbus_connection_send (_connection, _message, NULL);
	dbus_message_unref (_message);
}


void pipeline_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
	if (!g_object_get_data (object, "dbus_object_path")) {
		g_object_set_data (object, "dbus_object_path", g_strdup (path));
		dbus_connection_register_object_path (connection, path, &_pipeline_dbus_path_vtable, object);
		g_object_weak_ref (object, _vala_dbus_unregister_object, connection);
	}
	g_signal_connect (object, "eo-s", (GCallback) _dbus_pipeline_eo_s, connection);
	g_signal_connect (object, "state-changed", (GCallback) _dbus_pipeline_state_changed, connection);
	g_signal_connect (object, "error", (GCallback) _dbus_pipeline_error, connection);
	g_signal_connect (object, "qo-s", (GCallback) _dbus_pipeline_qo_s, connection);
}


/**
   Create a new instance of a Pipeline
   @param description, gst-launch style string description of the pipeline
   @param ids, pipeline identifier
 */
static GstBusSyncReply _pipeline_bus_sync_callback_gst_bus_sync_handler (GstBus* bus, GstMessage* message, gpointer self) {
	GstBusSyncReply result;
	result = pipeline_bus_sync_callback (self, bus, message);
	return result;
}


static gboolean _pipeline_bus_callback_gst_bus_func (GstBus* bus, GstMessage* message, gpointer self) {
	gboolean result;
	result = pipeline_bus_callback (self, bus, message);
	return result;
}


Pipeline* pipeline_construct (GType object_type, const gchar* description) {
	Pipeline * self = NULL;
	GstElement* _tmp0_ = NULL;
	GstElement* _tmp1_;
	GstElement* _tmp2_;
	GstElement* _tmp3_;
	GstBus* _tmp4_ = NULL;
	GstBus* bus;
	gboolean _tmp5_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (description != NULL, NULL);
	self = (Pipeline*) g_object_new (object_type, NULL);
	_tmp0_ = gst_parse_launch (description, &_inner_error_);
	_tmp1_ = _tmp0_;
	if (_inner_error_ != NULL) {
		goto __catch2_g_error;
	}
	_tmp3_ = (_tmp2_ = _tmp1_, GST_IS_ELEMENT (_tmp2_) ? ((GstElement*) _tmp2_) : NULL);
	_gst_object_unref0 (self->priv->pipeline);
	self->priv->pipeline = _tmp3_;
	_tmp4_ = gst_element_get_bus (self->priv->pipeline);
	bus = _tmp4_;
	gst_bus_set_sync_handler (bus, _pipeline_bus_sync_callback_gst_bus_sync_handler, self);
	gst_bus_add_watch_full (bus, G_PRIORITY_DEFAULT, _pipeline_bus_callback_gst_bus_func, g_object_ref (self), g_object_unref);
	g_object_unref (self);
	self->priv->initialized = TRUE;
	_tmp5_ = pipeline_PipelineIsInitialized (self);
	if (_tmp5_) {
		syslog (LOG_NOTICE, "Pipeline created, %s", description, NULL);
	} else {
		syslog (LOG_ERR, "Pipeline could not be initialized", NULL);
	}
	_gst_object_unref0 (bus);
	goto __finally2;
	__catch2_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		syslog (LOG_ERR, "Error constructing pipeline, %s", e->message, NULL);
		_g_error_free0 (e);
	}
	__finally2:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	return self;
}


Pipeline* pipeline_new (const gchar* description) {
	return pipeline_construct (TYPE_PIPELINE, description);
}


static gpointer _gst_object_ref0 (gpointer self) {
	return self ? gst_object_ref (self) : NULL;
}


static GstBusSyncReply pipeline_bus_sync_callback (Pipeline* self, GstBus* bus, GstMessage* message) {
	GstBusSyncReply result = 0;
	const GstStructure* _tmp0_ = NULL;
	const GstStructure* st;
	gboolean _tmp1_ = FALSE;
	GstElement* _tmp3_;
	GstPipeline* _tmp4_;
	GstPipeline* pipe;
	GstObject* _tmp5_ = NULL;
	GstObject* _tmp6_;
	GstElement* sink;
	GstElement* _tmp7_;
	GstXOverlay* _tmp8_;
	GstXOverlay* overlay;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (bus != NULL, 0);
	g_return_val_if_fail (message != NULL, 0);
	if (self->priv->windowId == 0) {
		result = GST_BUS_PASS;
		return result;
	}
	_tmp0_ = gst_message_get_structure (message);
	st = _tmp0_;
	if (st != NULL) {
		gboolean _tmp2_;
		_tmp2_ = gst_structure_has_name (st, "prepare-xwindow-id");
		_tmp1_ = _tmp2_;
	} else {
		_tmp1_ = FALSE;
	}
	if (!_tmp1_) {
		result = GST_BUS_PASS;
		return result;
	}
	syslog (LOG_DEBUG, "requested xwindow-id", NULL);
	_tmp4_ = _gst_object_ref0 ((_tmp3_ = self->priv->pipeline, GST_IS_PIPELINE (_tmp3_) ? ((GstPipeline*) _tmp3_) : NULL));
	pipe = _tmp4_;
	g_assert (pipe != NULL);
	_tmp5_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) pipe, "videosink");
	sink = (_tmp6_ = _tmp5_, GST_IS_ELEMENT (_tmp6_) ? ((GstElement*) _tmp6_) : NULL);
	if (sink == NULL) {
		result = GST_BUS_PASS;
		_gst_object_unref0 (sink);
		_gst_object_unref0 (pipe);
		return result;
	}
	_tmp8_ = _gst_object_ref0 ((_tmp7_ = sink, GST_IS_X_OVERLAY (_tmp7_) ? ((GstXOverlay*) _tmp7_) : NULL));
	overlay = _tmp8_;
	if (overlay == NULL) {
		result = GST_BUS_PASS;
		_gst_object_unref0 (overlay);
		_gst_object_unref0 (sink);
		_gst_object_unref0 (pipe);
		return result;
	}
	syslog (LOG_DEBUG, "set xwindow-id %lu", self->priv->windowId, NULL);
	gst_x_overlay_set_xwindow_id (overlay, self->priv->windowId);
	result = GST_BUS_PASS;
	_gst_object_unref0 (overlay);
	_gst_object_unref0 (sink);
	_gst_object_unref0 (pipe);
	return result;
}


static gboolean pipeline_bus_callback (Pipeline* self, GstBus* bus, GstMessage* message) {
	gboolean result = FALSE;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (bus != NULL, FALSE);
	g_return_val_if_fail (message != NULL, FALSE);
	_tmp0_ = gst_message_type_get_name (message->type);
	syslog (LOG_DEBUG, "received message %s", _tmp0_, NULL);
	switch (message->type) {
		case GST_MESSAGE_ERROR:
		{
			GError* err;
			gchar* dbg;
			GError* _tmp1_ = NULL;
			gchar* _tmp2_ = NULL;
			guint64 _tmp3_;
			err = NULL;
			dbg = NULL;
			gst_message_parse_error (message, &_tmp1_, &_tmp2_);
			_g_error_free0 (err);
			err = _tmp1_;
			_g_free0 (dbg);
			dbg = _tmp2_;
			_tmp3_ = pipeline_PipelineGetId (self);
			g_signal_emit_by_name (self, "error", _tmp3_, err->message);
			syslog (LOG_DEBUG, "Error on pipeline, %s", err->message, NULL);
			_g_free0 (dbg);
			_g_error_free0 (err);
			break;
		}
		case GST_MESSAGE_EOS:
		{
			guint64 _tmp4_;
			_tmp4_ = pipeline_PipelineGetId (self);
			g_signal_emit_by_name (self, "eo-s", _tmp4_);
			break;
		}
		case GST_MESSAGE_STATE_CHANGED:
		{
			GstState oldstate = 0;
			GstState newstate = 0;
			GstState pending = 0;
			gchar* _tmp5_ = NULL;
			gchar* src;
			GstState _tmp6_;
			GstState _tmp7_;
			GstState _tmp8_;
			const gchar* _tmp9_ = NULL;
			const gchar* _tmp10_ = NULL;
			guint64 _tmp11_;
			_tmp5_ = gst_object_get_name ((GstObject*) GST_ELEMENT (message->src));
			src = _tmp5_;
			gst_message_parse_state_changed (message, &_tmp6_, &_tmp7_, &_tmp8_);
			oldstate = _tmp6_;
			newstate = _tmp7_;
			pending = _tmp8_;
			_tmp9_ = gst_element_state_get_name (oldstate);
			_tmp10_ = gst_element_state_get_name (newstate);
			syslog (LOG_INFO, "%s,changes state from %s to %s", src, _tmp9_, _tmp10_, NULL);
			_tmp11_ = pipeline_PipelineGetId (self);
			g_signal_emit_by_name (self, "state-changed", _tmp11_, oldstate, newstate, src);
			_g_free0 (src);
			break;
		}
		default:
		{
			break;
		}
	}
	result = TRUE;
	return result;
}


static gboolean pipeline_PipelineSetStateImpl (Pipeline* self, GstState state) {
	gboolean result = FALSE;
	GstState current = 0;
	GstState pending = 0;
	GstState _tmp0_;
	GstState _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	gst_element_set_state (self->priv->pipeline, state);
	gst_element_get_state (self->priv->pipeline, &_tmp0_, &_tmp1_, (GstClockTime) GST_CLOCK_TIME_NONE);
	current = _tmp0_;
	pending = _tmp1_;
	if (current != state) {
		const gchar* _tmp2_ = NULL;
		_tmp2_ = gst_element_state_get_name (state);
		syslog (LOG_ERR, "Pipeline failed to change state to %s", _tmp2_, NULL);
		result = FALSE;
		return result;
	}
	result = TRUE;
	return result;
}


gboolean pipeline_PipelineSetState (Pipeline* self, gint state) {
	gboolean result = FALSE;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = pipeline_PipelineSetStateImpl (self, (GstState) state);
	result = _tmp0_;
	return result;
}


static void pipeline_PipelineAsyncSetStateImpl (Pipeline* self, GstState state) {
	const gchar* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	gst_element_set_state (self->priv->pipeline, state);
	_tmp0_ = gst_element_state_get_name (state);
	syslog (LOG_DEBUG, "Asynchronous state change to %s", _tmp0_, NULL);
}


void pipeline_PipelineAsyncSetState (Pipeline* self, gint state) {
	g_return_if_fail (self != NULL);
	pipeline_PipelineAsyncSetStateImpl (self, (GstState) state);
}


/**
   Returns initialized flag value.
 */
gboolean pipeline_PipelineIsInitialized (Pipeline* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->initialized;
	return result;
}


/**
           Gets the id of the pipe.
          */
guint64 pipeline_PipelineGetId (Pipeline* self) {
	guint64 result = 0ULL;
	g_return_val_if_fail (self != NULL, 0ULL);
	result = self->priv->id;
	return result;
}


/**
           Sets the id of the pipe.
          */
void pipeline_PipelineSetId (Pipeline* self, guint64 id) {
	g_return_if_fail (self != NULL);
	self->priv->id = id;
}


/**
   Returns the dbus-path assigned when created
 */
gchar* pipeline_PipelineGetPath (Pipeline* self) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self->priv->path);
	result = _tmp0_;
	return result;
}


/**
   Sets a dbus-path,this is assigned when connected to daemon
 */
gboolean pipeline_PipelineSetPath (Pipeline* self, const gchar* dbuspath) {
	gboolean result = FALSE;
	gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (dbuspath != NULL, FALSE);
	_tmp0_ = g_strdup (dbuspath);
	_tmp1_ = _tmp0_;
	_g_free0 (self->priv->path);
	self->priv->path = _tmp1_;
	result = TRUE;
	return result;
}


/**
   Gets the pipeline state
 */
gint pipeline_PipelineGetState (Pipeline* self) {
	gint result = 0;
	GstState current = 0;
	GstState pending = 0;
	GstState _tmp0_;
	GstState _tmp1_;
	g_return_val_if_fail (self != NULL, 0);
	gst_element_get_state (self->priv->pipeline, &_tmp0_, &_tmp1_, (GstClockTime) GST_CLOCK_TIME_NONE);
	current = _tmp0_;
	pending = _tmp1_;
	result = (gint) current;
	return result;
}


/**
   Sets a boolean property for an element on the pipeline
   @param element, whose property needs to be set
   @param property,property name
   @param val, bool property value
 */
static gpointer _g_param_spec_ref0 (gpointer self) {
	return self ? g_param_spec_ref (self) : NULL;
}


gboolean pipeline_ElementSetPropertyBoolean (Pipeline* self, const gchar* element, const gchar* property, gboolean val) {
	gboolean result = FALSE;
	GstElement* e;
	GstPipeline* pipe;
	GParamSpec* spec;
	GstElement* _tmp0_;
	GstPipeline* _tmp1_;
	GstPipeline* _tmp2_;
	GstObject* _tmp3_ = NULL;
	GstObject* _tmp4_;
	GstElement* _tmp5_;
	GObjectClass* _tmp6_ = NULL;
	GParamSpec* _tmp7_ = NULL;
	GParamSpec* _tmp8_;
	GParamSpec* _tmp9_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (element != NULL, FALSE);
	g_return_val_if_fail (property != NULL, FALSE);
	e = NULL;
	pipe = NULL;
	spec = NULL;
	_tmp1_ = _gst_object_ref0 ((_tmp0_ = self->priv->pipeline, GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL));
	_tmp2_ = _tmp1_;
	_gst_object_unref0 (pipe);
	pipe = _tmp2_;
	_tmp3_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) pipe, element);
	_tmp5_ = (_tmp4_ = _tmp3_, GST_IS_ELEMENT (_tmp4_) ? ((GstElement*) _tmp4_) : NULL);
	_gst_object_unref0 (e);
	e = _tmp5_;
	if (e == NULL) {
		syslog (LOG_WARNING, "Element %s not found on pipeline", element, NULL);
		result = FALSE;
		_g_param_spec_unref0 (spec);
		_gst_object_unref0 (pipe);
		_gst_object_unref0 (e);
		return result;
	}
	_tmp6_ = G_OBJECT_GET_CLASS ((GObject*) e);
	_tmp7_ = g_object_class_find_property (_tmp6_, property);
	_tmp8_ = _g_param_spec_ref0 (_tmp7_);
	_tmp9_ = _tmp8_;
	_g_param_spec_unref0 (spec);
	spec = _tmp9_;
	if (spec == NULL) {
		syslog (LOG_WARNING, "Element %s does not have the property %s", element, property, NULL);
		result = FALSE;
		_g_param_spec_unref0 (spec);
		_gst_object_unref0 (pipe);
		_gst_object_unref0 (e);
		return result;
	}
	g_object_set ((GObject*) e, property, val, NULL, NULL);
	result = TRUE;
	_g_param_spec_unref0 (spec);
	_gst_object_unref0 (pipe);
	_gst_object_unref0 (e);
	return result;
}


/**
   Sets an int property for an element on the pipeline
   @param element, whose property needs to be set
   @param property,property name
   @param val, int property value
 */
gboolean pipeline_ElementSetPropertyInt (Pipeline* self, const gchar* element, const gchar* property, gint val) {
	gboolean result = FALSE;
	GstElement* e;
	GstPipeline* pipe;
	GParamSpec* spec;
	GstElement* _tmp0_;
	GstPipeline* _tmp1_;
	GstPipeline* _tmp2_;
	GstObject* _tmp3_ = NULL;
	GstObject* _tmp4_;
	GstElement* _tmp5_;
	GObjectClass* _tmp6_ = NULL;
	GParamSpec* _tmp7_ = NULL;
	GParamSpec* _tmp8_;
	GParamSpec* _tmp9_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (element != NULL, FALSE);
	g_return_val_if_fail (property != NULL, FALSE);
	e = NULL;
	pipe = NULL;
	spec = NULL;
	_tmp1_ = _gst_object_ref0 ((_tmp0_ = self->priv->pipeline, GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL));
	_tmp2_ = _tmp1_;
	_gst_object_unref0 (pipe);
	pipe = _tmp2_;
	_tmp3_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) pipe, element);
	_tmp5_ = (_tmp4_ = _tmp3_, GST_IS_ELEMENT (_tmp4_) ? ((GstElement*) _tmp4_) : NULL);
	_gst_object_unref0 (e);
	e = _tmp5_;
	if (e == NULL) {
		syslog (LOG_WARNING, "Element %s not found on pipeline", element, NULL);
		result = FALSE;
		_g_param_spec_unref0 (spec);
		_gst_object_unref0 (pipe);
		_gst_object_unref0 (e);
		return result;
	}
	_tmp6_ = G_OBJECT_GET_CLASS ((GObject*) e);
	_tmp7_ = g_object_class_find_property (_tmp6_, property);
	_tmp8_ = _g_param_spec_ref0 (_tmp7_);
	_tmp9_ = _tmp8_;
	_g_param_spec_unref0 (spec);
	spec = _tmp9_;
	if (spec == NULL) {
		syslog (LOG_WARNING, "Gstd: Element %s does not have the property %s", element, property, NULL);
		result = FALSE;
		_g_param_spec_unref0 (spec);
		_gst_object_unref0 (pipe);
		_gst_object_unref0 (e);
		return result;
	}
	g_object_set ((GObject*) e, property, val, NULL, NULL);
	result = TRUE;
	_g_param_spec_unref0 (spec);
	_gst_object_unref0 (pipe);
	_gst_object_unref0 (e);
	return result;
}


/**
   Sets an long property for an element on the pipeline
   @param element, whose property needs to be set
   @param property,property name
   @param val, long property value     */
gboolean pipeline_ElementSetPropertyInt64 (Pipeline* self, const gchar* element, const gchar* property, gint64 val) {
	gboolean result = FALSE;
	GstElement* e;
	GstPipeline* pipe;
	GParamSpec* spec;
	GstElement* _tmp0_;
	GstPipeline* _tmp1_;
	GstPipeline* _tmp2_;
	GstObject* _tmp3_ = NULL;
	GstObject* _tmp4_;
	GstElement* _tmp5_;
	GObjectClass* _tmp6_ = NULL;
	GParamSpec* _tmp7_ = NULL;
	GParamSpec* _tmp8_;
	GParamSpec* _tmp9_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (element != NULL, FALSE);
	g_return_val_if_fail (property != NULL, FALSE);
	e = NULL;
	pipe = NULL;
	spec = NULL;
	_tmp1_ = _gst_object_ref0 ((_tmp0_ = self->priv->pipeline, GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL));
	_tmp2_ = _tmp1_;
	_gst_object_unref0 (pipe);
	pipe = _tmp2_;
	_tmp3_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) pipe, element);
	_tmp5_ = (_tmp4_ = _tmp3_, GST_IS_ELEMENT (_tmp4_) ? ((GstElement*) _tmp4_) : NULL);
	_gst_object_unref0 (e);
	e = _tmp5_;
	if (e == NULL) {
		syslog (LOG_WARNING, "Element %s not found on pipeline", element, NULL);
		result = FALSE;
		_g_param_spec_unref0 (spec);
		_gst_object_unref0 (pipe);
		_gst_object_unref0 (e);
		return result;
	}
	_tmp6_ = G_OBJECT_GET_CLASS ((GObject*) e);
	_tmp7_ = g_object_class_find_property (_tmp6_, property);
	_tmp8_ = _g_param_spec_ref0 (_tmp7_);
	_tmp9_ = _tmp8_;
	_g_param_spec_unref0 (spec);
	spec = _tmp9_;
	if (spec == NULL) {
		syslog (LOG_WARNING, "Element %s does not have the property %s", element, property, NULL);
		result = FALSE;
		_g_param_spec_unref0 (spec);
		_gst_object_unref0 (pipe);
		_gst_object_unref0 (e);
		return result;
	}
	g_object_set ((GObject*) e, property, val, NULL, NULL);
	result = TRUE;
	_g_param_spec_unref0 (spec);
	_gst_object_unref0 (pipe);
	_gst_object_unref0 (e);
	return result;
}


/**
   Sets a string property for an element on the pipeline
   @param element, whose property needs to be set
   @param property,property name
   @param val,string property value
 */
gboolean pipeline_ElementSetPropertyString (Pipeline* self, const gchar* element, const gchar* property, const gchar* val) {
	gboolean result = FALSE;
	GstElement* e;
	GstPipeline* pipe;
	GParamSpec* spec;
	GstElement* _tmp0_;
	GstPipeline* _tmp1_;
	GstPipeline* _tmp2_;
	GstObject* _tmp3_ = NULL;
	GstObject* _tmp4_;
	GstElement* _tmp5_;
	GObjectClass* _tmp6_ = NULL;
	GParamSpec* _tmp7_ = NULL;
	GParamSpec* _tmp8_;
	GParamSpec* _tmp9_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (element != NULL, FALSE);
	g_return_val_if_fail (property != NULL, FALSE);
	g_return_val_if_fail (val != NULL, FALSE);
	e = NULL;
	pipe = NULL;
	spec = NULL;
	_tmp1_ = _gst_object_ref0 ((_tmp0_ = self->priv->pipeline, GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL));
	_tmp2_ = _tmp1_;
	_gst_object_unref0 (pipe);
	pipe = _tmp2_;
	_tmp3_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) pipe, element);
	_tmp5_ = (_tmp4_ = _tmp3_, GST_IS_ELEMENT (_tmp4_) ? ((GstElement*) _tmp4_) : NULL);
	_gst_object_unref0 (e);
	e = _tmp5_;
	if (e == NULL) {
		syslog (LOG_WARNING, "Element %s not found on pipeline", element, NULL);
		result = FALSE;
		_g_param_spec_unref0 (spec);
		_gst_object_unref0 (pipe);
		_gst_object_unref0 (e);
		return result;
	}
	_tmp6_ = G_OBJECT_GET_CLASS ((GObject*) e);
	_tmp7_ = g_object_class_find_property (_tmp6_, property);
	_tmp8_ = _g_param_spec_ref0 (_tmp7_);
	_tmp9_ = _tmp8_;
	_g_param_spec_unref0 (spec);
	spec = _tmp9_;
	if (spec == NULL) {
		syslog (LOG_WARNING, "Element %s does not have the property %s", element, property, NULL);
		result = FALSE;
		_g_param_spec_unref0 (spec);
		_gst_object_unref0 (pipe);
		_gst_object_unref0 (e);
		return result;
	}
	g_object_set ((GObject*) e, property, val, NULL, NULL);
	result = TRUE;
	_g_param_spec_unref0 (spec);
	_gst_object_unref0 (pipe);
	_gst_object_unref0 (e);
	return result;
}


/**
   Gets an element's bool property value of a specific pipeline
   @param element, whose property value wants to be known
   @param property,property name
 */
gboolean pipeline_ElementGetPropertyBoolean (Pipeline* self, const gchar* element, const gchar* property, gboolean* val) {
	gboolean _val = FALSE;
	gboolean result = FALSE;
	GstElement* _tmp0_;
	GstPipeline* _tmp1_;
	GstPipeline* pipe;
	GstObject* _tmp2_ = NULL;
	GstObject* _tmp3_;
	GstElement* e;
	GObjectClass* _tmp4_ = NULL;
	GParamSpec* _tmp5_ = NULL;
	GParamSpec* _tmp6_;
	GParamSpec* spec;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (element != NULL, FALSE);
	g_return_val_if_fail (property != NULL, FALSE);
	_val = FALSE;
	_tmp1_ = _gst_object_ref0 ((_tmp0_ = self->priv->pipeline, GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL));
	pipe = _tmp1_;
	_tmp2_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) pipe, element);
	e = (_tmp3_ = _tmp2_, GST_IS_ELEMENT (_tmp3_) ? ((GstElement*) _tmp3_) : NULL);
	if (e == NULL) {
		syslog (LOG_WARNING, "Element %s not found on pipeline", element, NULL);
		result = FALSE;
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		if (val) {
			*val = _val;
		}
		return result;
	}
	_tmp4_ = G_OBJECT_GET_CLASS ((GObject*) e);
	_tmp5_ = g_object_class_find_property (_tmp4_, property);
	_tmp6_ = _g_param_spec_ref0 (_tmp5_);
	spec = _tmp6_;
	if (spec == NULL) {
		syslog (LOG_WARNING, "Element %s does not have the property %s", element, property, NULL);
		result = FALSE;
		_g_param_spec_unref0 (spec);
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		if (val) {
			*val = _val;
		}
		return result;
	}
	g_object_get ((GObject*) e, property, &_val, NULL, NULL);
	result = TRUE;
	_g_param_spec_unref0 (spec);
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	if (val) {
		*val = _val;
	}
	return result;
}


/**
   Gets an element's int property value of a specific pipeline
   @param element, whose property value wants to be known
   @param property,property name
   @param val value of the property
 */
gboolean pipeline_ElementGetPropertyInt (Pipeline* self, const gchar* element, const gchar* property, gint* val) {
	gint _val = 0;
	gboolean result = FALSE;
	GstElement* _tmp0_;
	GstPipeline* _tmp1_;
	GstPipeline* pipe;
	GstObject* _tmp2_ = NULL;
	GstObject* _tmp3_;
	GstElement* e;
	GObjectClass* _tmp4_ = NULL;
	GParamSpec* _tmp5_ = NULL;
	GParamSpec* _tmp6_;
	GParamSpec* spec;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (element != NULL, FALSE);
	g_return_val_if_fail (property != NULL, FALSE);
	_val = 0;
	_tmp1_ = _gst_object_ref0 ((_tmp0_ = self->priv->pipeline, GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL));
	pipe = _tmp1_;
	_tmp2_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) pipe, element);
	e = (_tmp3_ = _tmp2_, GST_IS_ELEMENT (_tmp3_) ? ((GstElement*) _tmp3_) : NULL);
	if (e == NULL) {
		syslog (LOG_WARNING, "Element %s not found on pipeline", element, NULL);
		result = FALSE;
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		if (val) {
			*val = _val;
		}
		return result;
	}
	_tmp4_ = G_OBJECT_GET_CLASS ((GObject*) e);
	_tmp5_ = g_object_class_find_property (_tmp4_, property);
	_tmp6_ = _g_param_spec_ref0 (_tmp5_);
	spec = _tmp6_;
	if (spec == NULL) {
		syslog (LOG_WARNING, "Element %s does not have the property %s", element, property, NULL);
		result = FALSE;
		_g_param_spec_unref0 (spec);
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		if (val) {
			*val = _val;
		}
		return result;
	}
	g_object_get ((GObject*) e, property, &_val, NULL, NULL);
	result = TRUE;
	_g_param_spec_unref0 (spec);
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	if (val) {
		*val = _val;
	}
	return result;
}


/**
   Gets an element's long property value of a specific pipeline
   @param element, whose property value wants to be known
   @param property,property name
   @param val value of the property
 */
gboolean pipeline_ElementGetPropertyInt64 (Pipeline* self, const gchar* element, const gchar* property, gint64* val) {
	gint64 _val = 0LL;
	gboolean result = FALSE;
	GstElement* _tmp0_;
	GstPipeline* _tmp1_;
	GstPipeline* pipe;
	GstObject* _tmp2_ = NULL;
	GstObject* _tmp3_;
	GstElement* e;
	GObjectClass* _tmp4_ = NULL;
	GParamSpec* _tmp5_ = NULL;
	GParamSpec* _tmp6_;
	GParamSpec* spec;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (element != NULL, FALSE);
	g_return_val_if_fail (property != NULL, FALSE);
	_val = (gint64) 0;
	_tmp1_ = _gst_object_ref0 ((_tmp0_ = self->priv->pipeline, GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL));
	pipe = _tmp1_;
	_tmp2_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) pipe, element);
	e = (_tmp3_ = _tmp2_, GST_IS_ELEMENT (_tmp3_) ? ((GstElement*) _tmp3_) : NULL);
	if (e == NULL) {
		syslog (LOG_WARNING, "Element %s not found on pipeline", element, NULL);
		result = FALSE;
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		if (val) {
			*val = _val;
		}
		return result;
	}
	_tmp4_ = G_OBJECT_GET_CLASS ((GObject*) e);
	_tmp5_ = g_object_class_find_property (_tmp4_, property);
	_tmp6_ = _g_param_spec_ref0 (_tmp5_);
	spec = _tmp6_;
	if (spec == NULL) {
		syslog (LOG_WARNING, "Element %s does not have the property %s", element, property, NULL);
		result = FALSE;
		_g_param_spec_unref0 (spec);
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		if (val) {
			*val = _val;
		}
		return result;
	}
	g_object_get ((GObject*) e, property, &_val, NULL, NULL);
	result = TRUE;
	_g_param_spec_unref0 (spec);
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	if (val) {
		*val = _val;
	}
	return result;
}


/**
   Gets an element's string property value of a specific pipeline
   @param element, whose property value wants to be known
   @param property,property name
   @param val value of the property
 */
gboolean pipeline_ElementGetPropertyString (Pipeline* self, const gchar* element, const gchar* property, gchar** val) {
	gchar* _val = NULL;
	gboolean result = FALSE;
	gchar* _tmp0_;
	gchar* _tmp1_;
	GstElement* _tmp2_;
	GstPipeline* _tmp3_;
	GstPipeline* pipe;
	GstObject* _tmp4_ = NULL;
	GstObject* _tmp5_;
	GstElement* e;
	GObjectClass* _tmp6_ = NULL;
	GParamSpec* _tmp7_ = NULL;
	GParamSpec* _tmp8_;
	GParamSpec* spec;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (element != NULL, FALSE);
	g_return_val_if_fail (property != NULL, FALSE);
	_tmp0_ = g_strdup ("");
	_tmp1_ = _tmp0_;
	_g_free0 (_val);
	_val = _tmp1_;
	_tmp3_ = _gst_object_ref0 ((_tmp2_ = self->priv->pipeline, GST_IS_PIPELINE (_tmp2_) ? ((GstPipeline*) _tmp2_) : NULL));
	pipe = _tmp3_;
	_tmp4_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) pipe, element);
	e = (_tmp5_ = _tmp4_, GST_IS_ELEMENT (_tmp5_) ? ((GstElement*) _tmp5_) : NULL);
	if (e == NULL) {
		syslog (LOG_WARNING, "Element %s not found on pipeline", element, NULL);
		result = FALSE;
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		if (val) {
			*val = _val;
		} else {
			_g_free0 (_val);
		}
		return result;
	}
	_tmp6_ = G_OBJECT_GET_CLASS ((GObject*) e);
	_tmp7_ = g_object_class_find_property (_tmp6_, property);
	_tmp8_ = _g_param_spec_ref0 (_tmp7_);
	spec = _tmp8_;
	if (spec == NULL) {
		syslog (LOG_WARNING, "Element %s does not have the property %s", element, property, NULL);
		result = FALSE;
		_g_param_spec_unref0 (spec);
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		if (val) {
			*val = _val;
		} else {
			_g_free0 (_val);
		}
		return result;
	}
	g_object_get ((GObject*) e, property, &_val, NULL, NULL);
	result = TRUE;
	_g_param_spec_unref0 (spec);
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	if (val) {
		*val = _val;
	} else {
		_g_free0 (_val);
	}
	return result;
}


/**
   Gets an element's state value of a specific pipeline
   @param element, whose property value wants to be known
   @param val value of the property
 */
gint pipeline_ElementGetState (Pipeline* self, const gchar* element) {
	gint result = 0;
	GstElement* _tmp0_;
	GstPipeline* _tmp1_;
	GstPipeline* pipe;
	GstObject* _tmp2_ = NULL;
	GstObject* _tmp3_;
	GstElement* e;
	GstState current = 0;
	GstState pending = 0;
	GstState _tmp6_;
	GstState _tmp7_;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (element != NULL, 0);
	_tmp1_ = _gst_object_ref0 ((_tmp0_ = self->priv->pipeline, GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL));
	pipe = _tmp1_;
	_tmp2_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) pipe, element);
	e = (_tmp3_ = _tmp2_, GST_IS_ELEMENT (_tmp3_) ? ((GstElement*) _tmp3_) : NULL);
	if (e == NULL) {
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_;
		_tmp4_ = gst_object_get_name ((GstObject*) pipe);
		_tmp5_ = _tmp4_;
		syslog (LOG_WARNING, "Element %s not found on pipeline %s", element, _tmp5_, NULL);
		_g_free0 (_tmp5_);
		result = (gint) GST_STATE_NULL;
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		return result;
	}
	gst_element_get_state (e, &_tmp6_, &_tmp7_, (GstClockTime) GST_CLOCK_TIME_NONE);
	current = _tmp6_;
	pending = _tmp7_;
	result = (gint) current;
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	return result;
}


/**
   Gets an element's buffer property value of a specific pipeline
   @param element, whose property value wants to be known
   @param property,property name
   @param caps caps of buffer
   @param data data
 */
static guint8* _vala_array_dup1 (guint8* self, int length) {
	return g_memdup (self, length * sizeof (guint8));
}


gboolean pipeline_ElementGetPropertyBuffer (Pipeline* self, const gchar* element, const gchar* property, gchar** caps, guint8** data, int* data_length1) {
	gchar* _caps = NULL;
	guint8* _data = NULL;
	int _data_length1 = 0;
	gboolean result = FALSE;
	gchar* _tmp0_;
	gchar* _tmp1_;
	guint8* _tmp2_ = NULL;
	guint8* _tmp3_;
	GstElement* _tmp4_;
	GstPipeline* _tmp5_;
	GstPipeline* pipe;
	GstObject* _tmp6_ = NULL;
	GstObject* _tmp7_;
	GstElement* e;
	GObjectClass* _tmp8_ = NULL;
	GParamSpec* _tmp9_ = NULL;
	GParamSpec* _tmp10_;
	GParamSpec* spec;
	GstBuffer* buffer;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (element != NULL, FALSE);
	g_return_val_if_fail (property != NULL, FALSE);
	_tmp0_ = g_strdup ("");
	_tmp1_ = _tmp0_;
	_g_free0 (_caps);
	_caps = _tmp1_;
	_tmp2_ = g_new0 (guint8, 0);
	_tmp3_ = _tmp2_;
	_data = (g_free (_data), NULL);
	_data_length1 = 0;
	_data = _tmp3_;
	_tmp5_ = _gst_object_ref0 ((_tmp4_ = self->priv->pipeline, GST_IS_PIPELINE (_tmp4_) ? ((GstPipeline*) _tmp4_) : NULL));
	pipe = _tmp5_;
	_tmp6_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) pipe, element);
	e = (_tmp7_ = _tmp6_, GST_IS_ELEMENT (_tmp7_) ? ((GstElement*) _tmp7_) : NULL);
	if (e == NULL) {
		syslog (LOG_WARNING, "Element %s not found on pipeline", element, NULL);
		result = FALSE;
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		if (caps) {
			*caps = _caps;
		} else {
			_g_free0 (_caps);
		}
		if (data) {
			*data = _data;
		} else {
			_data = (g_free (_data), NULL);
		}
		if (data_length1) {
			*data_length1 = _data_length1;
		}
		return result;
	}
	_tmp8_ = G_OBJECT_GET_CLASS ((GObject*) e);
	_tmp9_ = g_object_class_find_property (_tmp8_, property);
	_tmp10_ = _g_param_spec_ref0 (_tmp9_);
	spec = _tmp10_;
	if (spec == NULL) {
		syslog (LOG_WARNING, "Element %s does not have the property %s", element, property, NULL);
		result = FALSE;
		_g_param_spec_unref0 (spec);
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		if (caps) {
			*caps = _caps;
		} else {
			_g_free0 (_caps);
		}
		if (data) {
			*data = _data;
		} else {
			_data = (g_free (_data), NULL);
		}
		if (data_length1) {
			*data_length1 = _data_length1;
		}
		return result;
	}
	buffer = NULL;
	g_object_get ((GObject*) e, property, &buffer, NULL, NULL);
	if (buffer != NULL) {
		gchar* _tmp11_;
		gchar* _tmp16_;
		gchar* _tmp17_;
		guint8* _tmp18_;
		guint8* _tmp19_;
		guint8* _tmp20_;
		_tmp11_ = NULL;
		if (buffer->caps != NULL) {
			gchar* _tmp12_ = NULL;
			gchar* _tmp13_;
			_tmp12_ = gst_caps_to_string (buffer->caps);
			_tmp13_ = _tmp12_;
			_g_free0 (_tmp11_);
			_tmp11_ = _tmp13_;
		} else {
			gchar* _tmp14_;
			gchar* _tmp15_;
			_tmp14_ = g_strdup ("");
			_tmp15_ = _tmp14_;
			_g_free0 (_tmp11_);
			_tmp11_ = _tmp15_;
		}
		_tmp16_ = g_strdup (_tmp11_);
		_tmp17_ = _tmp16_;
		_g_free0 (_caps);
		_caps = _tmp17_;
		_tmp18_ = (_tmp19_ = buffer->data, (_tmp19_ == NULL) ? ((gpointer) _tmp19_) : _vala_array_dup1 (_tmp19_, (gint) buffer->size));
		_tmp20_ = _tmp18_;
		_data = (g_free (_data), NULL);
		_data_length1 = (gint) buffer->size;
		_data = _tmp20_;
		_g_free0 (_tmp11_);
	}
	result = TRUE;
	_gst_buffer_unref0 (buffer);
	_g_param_spec_unref0 (spec);
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	if (caps) {
		*caps = _caps;
	} else {
		_g_free0 (_caps);
	}
	if (data) {
		*data = _data;
	} else {
		_data = (g_free (_data), NULL);
	}
	if (data_length1) {
		*data_length1 = _data_length1;
	}
	return result;
}


/**
   Query duration to a pipeline on the server
   @return time in milliseconds or null if not available
 */
gint64 pipeline_PipelineGetDuration (Pipeline* self) {
	gint64 result = 0LL;
	GstFormat format;
	gint64 duration;
	gint64 _tmp0_;
	gboolean _tmp1_;
	g_return_val_if_fail (self != NULL, 0LL);
	format = GST_FORMAT_TIME;
	duration = (gint64) 0;
	_tmp1_ = gst_element_query_duration (self->priv->pipeline, &format, &_tmp0_);
	duration = _tmp0_;
	if (!_tmp1_) {
		result = (gint64) (-1);
		return result;
	}
	if (duration == GST_CLOCK_TIME_NONE) {
		result = (gint64) (-1);
		return result;
	}
	syslog (LOG_DEBUG, "Duration at server is %u:%02u:%02u.%03u", (guint) (duration / ((GST_SECOND * 60) * 60)), (guint) ((duration / (GST_SECOND * 60)) % 60), (guint) ((duration / GST_SECOND) % 60), (guint) (duration % GST_SECOND), NULL);
	result = duration;
	return result;
}


/**
   Query position to a pipeline on the server
   @return position in milliseconds or null if not available
 */
gint64 pipeline_PipelineGetPosition (Pipeline* self) {
	gint64 result = 0LL;
	GstFormat format;
	gint64 position;
	gint64 _tmp0_;
	gboolean _tmp1_;
	g_return_val_if_fail (self != NULL, 0LL);
	format = GST_FORMAT_TIME;
	position = (gint64) 0;
	_tmp1_ = gst_element_query_position (self->priv->pipeline, &format, &_tmp0_);
	position = _tmp0_;
	if (!_tmp1_) {
		result = (gint64) (-1);
		return result;
	}
	if (position == GST_CLOCK_TIME_NONE) {
		result = (gint64) (-1);
		return result;
	}
	syslog (LOG_DEBUG, "Position at server is %u:%02u:%02u.%03u", (guint) (position / ((GST_SECOND * 60) * 60)), (guint) ((position / (GST_SECOND * 60)) % 60), (guint) ((position / GST_SECOND) % 60), (guint) (position % GST_SECOND), NULL);
	result = position;
	return result;
}


/**
   Seeks a specific time position.
   Data in the pipeline is flushed.
   @param ipos_ms, absolute position in milliseconds
 */
gboolean pipeline_PipelineSeek (Pipeline* self, gint64 ipos_ns) {
	gboolean result = FALSE;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = gst_element_seek (self->priv->pipeline, self->priv->rate, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH, GST_SEEK_TYPE_SET, ipos_ns, GST_SEEK_TYPE_NONE, (gint64) GST_CLOCK_TIME_NONE);
	if (!_tmp0_) {
		syslog (LOG_WARNING, "Media type not seekable", NULL);
		result = FALSE;
		return result;
	}
	result = TRUE;
	return result;
}


/**
   Seeks a specific time position.
   Data in the pipeline is flushed.
   @param ipos_ms, absolute position in milliseconds
 */
void pipeline_PipelineAsyncSeek (Pipeline* self, gint64 ipos_ms) {
	g_return_if_fail (self != NULL);
	pipeline_PipelineSeek (self, ipos_ms);
}


/**
   Skips time, it moves position forward and backwards from
   the current position.
   Data in the pipeline is flushed.
   @param period_ms, relative time in milliseconds
 */
gboolean pipeline_PipelineSkip (Pipeline* self, gint64 period_ns) {
	gboolean result = FALSE;
	GstFormat format;
	GstSeekFlags flag;
	GstSeekType cur_type;
	GstSeekType stp_type;
	gint64 stp_pos_ns;
	gint64 cur_pos_ns;
	gint64 seek_ns;
	gint64 _tmp0_;
	gboolean _tmp1_;
	gboolean _tmp2_;
	g_return_val_if_fail (self != NULL, FALSE);
	format = GST_FORMAT_TIME;
	flag = GST_SEEK_FLAG_FLUSH;
	cur_type = GST_SEEK_TYPE_SET;
	stp_type = GST_SEEK_TYPE_NONE;
	stp_pos_ns = (gint64) GST_CLOCK_TIME_NONE;
	cur_pos_ns = (gint64) 0;
	seek_ns = (gint64) 0;
	_tmp1_ = gst_element_query_position (self->priv->pipeline, &format, &_tmp0_);
	cur_pos_ns = _tmp0_;
	if (!_tmp1_) {
		result = FALSE;
		return result;
	}
	seek_ns = cur_pos_ns + period_ns;
	_tmp2_ = gst_element_seek (self->priv->pipeline, self->priv->rate, format, flag, cur_type, seek_ns, stp_type, stp_pos_ns);
	if (!_tmp2_) {
		syslog (LOG_WARNING, "Media type not seekable", NULL);
		result = FALSE;
		return result;
	}
	result = TRUE;
	return result;
}


/**
   Changes pipeline speed, it enable fast|slow foward and
   fast|slow -reverse playback
   @param new_rate, values great than zero play forward, reverse
        otherwise.  Values greater than 1 (or -1 for reverse)
        play faster than normal, otherwise slower than normal.
 */
gboolean pipeline_PipelineSpeed (Pipeline* self, gdouble new_rate) {
	gboolean result = FALSE;
	GstFormat format;
	GstSeekFlags flag;
	GstSeekType type;
	gint64 pos_ns;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	format = GST_FORMAT_TIME;
	flag = GST_SEEK_FLAG_SKIP | GST_SEEK_FLAG_FLUSH;
	type = GST_SEEK_TYPE_NONE;
	pos_ns = (gint64) GST_CLOCK_TIME_NONE;
	self->priv->rate = new_rate;
	_tmp0_ = gst_element_seek (self->priv->pipeline, self->priv->rate, format, flag, type, pos_ns, type, pos_ns);
	if (!_tmp0_) {
		syslog (LOG_WARNING, "Speed could not be changed", NULL);
		result = FALSE;
		return result;
	}
	result = TRUE;
	return result;
}


void pipeline_PipelineSendEoS (Pipeline* self) {
	GstEvent* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = gst_event_new_eos ();
	gst_element_send_event (self->priv->pipeline, _tmp0_);
}


/**
   Sets an element to the specified state
   @param element, whose state is to be set
   @param state, desired element state
 */
gboolean pipeline_ElementSetState (Pipeline* self, const gchar* element, gint state) {
	gboolean result = FALSE;
	GstElement* e;
	GstPipeline* pipe;
	GstState current = 0;
	GstState pending = 0;
	GstElement* _tmp0_;
	GstPipeline* _tmp1_;
	GstPipeline* _tmp2_;
	GstObject* _tmp3_ = NULL;
	GstObject* _tmp4_;
	GstElement* _tmp5_;
	GstState _tmp6_;
	GstState _tmp7_;
	GstState _tmp8_;
	GstState _tmp9_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (element != NULL, FALSE);
	e = NULL;
	pipe = NULL;
	_tmp1_ = _gst_object_ref0 ((_tmp0_ = self->priv->pipeline, GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL));
	_tmp2_ = _tmp1_;
	_gst_object_unref0 (pipe);
	pipe = _tmp2_;
	_tmp3_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) pipe, element);
	_tmp5_ = (_tmp4_ = _tmp3_, GST_IS_ELEMENT (_tmp4_) ? ((GstElement*) _tmp4_) : NULL);
	_gst_object_unref0 (e);
	e = _tmp5_;
	if (e == NULL) {
		syslog (LOG_WARNING, "Element %s not found on pipeline", element, NULL);
		result = FALSE;
		_gst_object_unref0 (pipe);
		_gst_object_unref0 (e);
		return result;
	}
	gst_element_set_state (e, (GstState) state);
	gst_element_get_state (e, &_tmp6_, &_tmp7_, (GstClockTime) 4000000000U);
	current = _tmp6_;
	pending = _tmp7_;
	gst_element_get_state (e, &_tmp8_, &_tmp9_, (GstClockTime) 4000000000U);
	current = _tmp8_;
	pending = _tmp9_;
	if (current != state) {
		gchar* _tmp10_ = NULL;
		gchar* _tmp11_;
		_tmp10_ = g_strdup_printf ("%i", state);
		_tmp11_ = _tmp10_;
		syslog (LOG_ERR, "Element, failed to change state %s", _tmp11_, NULL);
		_g_free0 (_tmp11_);
		result = FALSE;
		_gst_object_unref0 (pipe);
		_gst_object_unref0 (e);
		return result;
	}
	result = TRUE;
	_gst_object_unref0 (pipe);
	_gst_object_unref0 (e);
	return result;
}


/**
   Sets an element to the specified state, returning before the state change may have occurred
   @param element, whose state is to be set
   @param state, desired element state
 */
void pipeline_ElementAsyncSetState (Pipeline* self, const gchar* element, gint state) {
	GstElement* e;
	GstPipeline* pipe;
	GstElement* _tmp0_;
	GstPipeline* _tmp1_;
	GstPipeline* _tmp2_;
	GstObject* _tmp3_ = NULL;
	GstObject* _tmp4_;
	GstElement* _tmp5_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (element != NULL);
	e = NULL;
	pipe = NULL;
	_tmp1_ = _gst_object_ref0 ((_tmp0_ = self->priv->pipeline, GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL));
	_tmp2_ = _tmp1_;
	_gst_object_unref0 (pipe);
	pipe = _tmp2_;
	_tmp3_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) pipe, element);
	_tmp5_ = (_tmp4_ = _tmp3_, GST_IS_ELEMENT (_tmp4_) ? ((GstElement*) _tmp4_) : NULL);
	_gst_object_unref0 (e);
	e = _tmp5_;
	if (e == NULL) {
		syslog (LOG_WARNING, "Element %s not found on pipeline", element, NULL);
	}
	gst_element_set_state (e, (GstState) state);
	_gst_object_unref0 (pipe);
	_gst_object_unref0 (e);
}


void pipeline_SetWindowId (Pipeline* self, guint64 winId) {
	g_return_if_fail (self != NULL);
	self->priv->windowId = (gulong) winId;
}


/**
   Ping pipeline..
   @return true if alive
 */
gboolean pipeline_Ping (Pipeline* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	result = TRUE;
	return result;
}


static void g_cclosure_user_marshal_VOID__UINT64 (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__UINT64) (gpointer data1, guint64 arg_1, gpointer data2);
	register GMarshalFunc_VOID__UINT64 callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 2);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__UINT64) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_uint64 (param_values + 1), data2);
}


static void g_cclosure_user_marshal_VOID__UINT64_ENUM_ENUM_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__UINT64_ENUM_ENUM_STRING) (gpointer data1, guint64 arg_1, gint arg_2, gint arg_3, const char* arg_4, gpointer data2);
	register GMarshalFunc_VOID__UINT64_ENUM_ENUM_STRING callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 5);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__UINT64_ENUM_ENUM_STRING) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_uint64 (param_values + 1), g_value_get_enum (param_values + 2), g_value_get_enum (param_values + 3), g_value_get_string (param_values + 4), data2);
}


static void g_cclosure_user_marshal_VOID__UINT64_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__UINT64_STRING) (gpointer data1, guint64 arg_1, const char* arg_2, gpointer data2);
	register GMarshalFunc_VOID__UINT64_STRING callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__UINT64_STRING) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_uint64 (param_values + 1), g_value_get_string (param_values + 2), data2);
}


static void g_cclosure_user_marshal_VOID__UINT64_BOOLEAN_UINT64_UINT64_UINT64_UINT64_INT64_DOUBLE_INT_INT_UINT64_UINT64 (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__UINT64_BOOLEAN_UINT64_UINT64_UINT64_UINT64_INT64_DOUBLE_INT_INT_UINT64_UINT64) (gpointer data1, guint64 arg_1, gboolean arg_2, guint64 arg_3, guint64 arg_4, guint64 arg_5, guint64 arg_6, gint64 arg_7, gdouble arg_8, gint arg_9, gint arg_10, guint64 arg_11, guint64 arg_12, gpointer data2);
	register GMarshalFunc_VOID__UINT64_BOOLEAN_UINT64_UINT64_UINT64_UINT64_INT64_DOUBLE_INT_INT_UINT64_UINT64 callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 13);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__UINT64_BOOLEAN_UINT64_UINT64_UINT64_UINT64_INT64_DOUBLE_INT_INT_UINT64_UINT64) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_uint64 (param_values + 1), g_value_get_boolean (param_values + 2), g_value_get_uint64 (param_values + 3), g_value_get_uint64 (param_values + 4), g_value_get_uint64 (param_values + 5), g_value_get_uint64 (param_values + 6), g_value_get_int64 (param_values + 7), g_value_get_double (param_values + 8), g_value_get_int (param_values + 9), g_value_get_int (param_values + 10), g_value_get_uint64 (param_values + 11), g_value_get_uint64 (param_values + 12), data2);
}


static void pipeline_class_init (PipelineClass * klass) {
	pipeline_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (PipelinePrivate));
	G_OBJECT_CLASS (klass)->finalize = pipeline_finalize;
	g_signal_new ("eo_s", TYPE_PIPELINE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__UINT64, G_TYPE_NONE, 1, G_TYPE_UINT64);
	g_signal_new ("state_changed", TYPE_PIPELINE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__UINT64_ENUM_ENUM_STRING, G_TYPE_NONE, 4, G_TYPE_UINT64, GST_TYPE_STATE, GST_TYPE_STATE, G_TYPE_STRING);
	g_signal_new ("error", TYPE_PIPELINE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__UINT64_STRING, G_TYPE_NONE, 2, G_TYPE_UINT64, G_TYPE_STRING);
	g_signal_new ("qo_s", TYPE_PIPELINE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__UINT64_BOOLEAN_UINT64_UINT64_UINT64_UINT64_INT64_DOUBLE_INT_INT_UINT64_UINT64, G_TYPE_NONE, 12, G_TYPE_UINT64, G_TYPE_BOOLEAN, G_TYPE_UINT64, G_TYPE_UINT64, G_TYPE_UINT64, G_TYPE_UINT64, G_TYPE_INT64, G_TYPE_DOUBLE, G_TYPE_INT, G_TYPE_INT, G_TYPE_UINT64, G_TYPE_UINT64);
	g_type_set_qdata (TYPE_PIPELINE, g_quark_from_static_string ("DBusObjectVTable"), (void*) (&_pipeline_dbus_vtable));
}


static void pipeline_instance_init (Pipeline * self) {
	gchar* _tmp0_;
	self->priv = PIPELINE_GET_PRIVATE (self);
	self->priv->id = (guint64) 0;
	self->priv->initialized = FALSE;
	_tmp0_ = g_strdup ("");
	self->priv->path = _tmp0_;
	self->priv->rate = 1.0;
	self->priv->windowId = (gulong) 0;
}


static void pipeline_finalize (GObject* obj) {
	Pipeline * self;
	gboolean _tmp0_;
	self = PIPELINE (obj);
	_tmp0_ = pipeline_PipelineIsInitialized (self);
	if (_tmp0_) {
		gboolean _tmp1_;
		_tmp1_ = pipeline_PipelineSetStateImpl (self, GST_STATE_NULL);
		if (!_tmp1_) {
			syslog (LOG_ERR, "Failed to destroy pipeline", NULL);
		}
	}
	_gst_object_unref0 (self->priv->pipeline);
	_g_free0 (self->priv->path);
	G_OBJECT_CLASS (pipeline_parent_class)->finalize (obj);
}


GType pipeline_get_type (void) {
	static volatile gsize pipeline_type_id__volatile = 0;
	if (g_once_init_enter (&pipeline_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (PipelineClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) pipeline_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Pipeline), 0, (GInstanceInitFunc) pipeline_instance_init, NULL };
		GType pipeline_type_id;
		pipeline_type_id = g_type_register_static (G_TYPE_OBJECT, "Pipeline", &g_define_type_info, 0);
		g_once_init_leave (&pipeline_type_id__volatile, pipeline_type_id);
	}
	return pipeline_type_id__volatile;
}



