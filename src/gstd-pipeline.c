/* gstd-pipeline.c generated by valac 0.14.0, the Vala compiler
 * generated from gstd-pipeline.vala, do not modify */

/*
 * gstd/src/gstd-pipeline.vala
 *
 * GStreamer daemon Pipeline class - framework for controlling audio and video streaming using D-Bus messages
 *
 * Copyright (c) 2010, RidgeRun
 * All rights reserved.
 *
 * GPL2 license - See http://www.opensource.org/licenses/gpl-2.0.php for complete text.
 */

#include <glib.h>
#include <glib-object.h>
#include <gio/gio.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <gst/gst.h>
#include <syslog.h>
#include <gst/interfaces/xoverlay.h>


#define GSTD_TYPE_PIPELINE_INTERFACE (gstd_pipeline_interface_get_type ())
#define GSTD_PIPELINE_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSTD_TYPE_PIPELINE_INTERFACE, gstdPipelineInterface))
#define GSTD_IS_PIPELINE_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSTD_TYPE_PIPELINE_INTERFACE))
#define GSTD_PIPELINE_INTERFACE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GSTD_TYPE_PIPELINE_INTERFACE, gstdPipelineInterfaceIface))

typedef struct _gstdPipelineInterface gstdPipelineInterface;
typedef struct _gstdPipelineInterfaceIface gstdPipelineInterfaceIface;

#define GSTD_TYPE_PIPELINE_INTERFACE_PROXY (gstd_pipeline_interface_proxy_get_type ())

#define GSTD_TYPE_PIPELINE (gstd_pipeline_get_type ())
#define GSTD_PIPELINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSTD_TYPE_PIPELINE, gstdPipeline))
#define GSTD_PIPELINE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GSTD_TYPE_PIPELINE, gstdPipelineClass))
#define GSTD_IS_PIPELINE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSTD_TYPE_PIPELINE))
#define GSTD_IS_PIPELINE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GSTD_TYPE_PIPELINE))
#define GSTD_PIPELINE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GSTD_TYPE_PIPELINE, gstdPipelineClass))

typedef struct _gstdPipeline gstdPipeline;
typedef struct _gstdPipelineClass gstdPipelineClass;
typedef struct _gstdPipelinePrivate gstdPipelinePrivate;
#define _gst_object_unref0(var) ((var == NULL) ? NULL : (var = (gst_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_param_spec_unref0(var) ((var == NULL) ? NULL : (var = (g_param_spec_unref (var), NULL)))
#define _gst_buffer_unref0(var) ((var == NULL) ? NULL : (var = (gst_buffer_unref (var), NULL)))

struct _gstdPipelineInterfaceIface {
	GTypeInterface parent_iface;
	void (*pipeline_set_id) (gstdPipelineInterface* self, guint64 id, GError** error);
	guint64 (*pipeline_get_id) (gstdPipelineInterface* self, GError** error);
	gboolean (*pipeline_set_state) (gstdPipelineInterface* self, gint state, GError** error);
	void (*pipeline_async_set_state) (gstdPipelineInterface* self, gint state, GError** error);
	gboolean (*element_set_property_boolean) (gstdPipelineInterface* self, const gchar* element, const gchar* property, gboolean val, GError** error);
	gboolean (*element_set_property_int) (gstdPipelineInterface* self, const gchar* element, const gchar* property, gint val, GError** error);
	gboolean (*element_set_property_int64) (gstdPipelineInterface* self, const gchar* element, const gchar* property, gint64 val, GError** error);
	gboolean (*element_set_property_string) (gstdPipelineInterface* self, const gchar* element, const gchar* property, const gchar* val, GError** error);
	void (*element_get_property_boolean) (gstdPipelineInterface* self, const gchar* element, const gchar* property, gboolean* val, gboolean* success, GError** error);
	void (*element_get_property_int) (gstdPipelineInterface* self, const gchar* element, const gchar* property, gint* val, gboolean* success, GError** error);
	void (*element_get_property_int64) (gstdPipelineInterface* self, const gchar* element, const gchar* property, gint64* val, gboolean* success, GError** error);
	void (*element_get_property_string) (gstdPipelineInterface* self, const gchar* element, const gchar* property, gchar** val, gboolean* success, GError** error);
	void (*element_get_property_buffer) (gstdPipelineInterface* self, const gchar* element, const gchar* property, gchar** caps, guint8** data, int* data_length1, gboolean* success, GError** error);
	gint64 (*pipeline_get_duration) (gstdPipelineInterface* self, GError** error);
	gint64 (*pipeline_get_position) (gstdPipelineInterface* self, GError** error);
	gboolean (*pipeline_speed) (gstdPipelineInterface* self, gdouble newrate, GError** error);
	gboolean (*pipeline_skip) (gstdPipelineInterface* self, gint64 period_ns, GError** error);
	gboolean (*pipeline_seek) (gstdPipelineInterface* self, gint64 ipos_ns, GError** error);
	void (*pipeline_step) (gstdPipelineInterface* self, guint64 frames, GError** error);
	void (*pipeline_async_seek) (gstdPipelineInterface* self, gint64 ipos_ns, GError** error);
	gint (*pipeline_get_state) (gstdPipelineInterface* self, GError** error);
	gint (*element_get_state) (gstdPipelineInterface* self, const gchar* element, GError** error);
	void (*pipeline_send_eos) (gstdPipelineInterface* self, GError** error);
	gboolean (*pipeline_send_custom_event) (gstdPipelineInterface* self, const gchar* type, const gchar* name, GError** error);
	void (*set_window_id) (gstdPipelineInterface* self, guint64 winId, GError** error);
	gboolean (*ping) (gstdPipelineInterface* self, GError** error);
	gboolean (*element_set_state) (gstdPipelineInterface* self, const gchar* element, gint state, GError** error);
	void (*element_async_set_state) (gstdPipelineInterface* self, const gchar* element, gint state, GError** error);
};

struct _gstdPipeline {
	GObject parent_instance;
	gstdPipelinePrivate * priv;
};

struct _gstdPipelineClass {
	GObjectClass parent_class;
};

struct _gstdPipelinePrivate {
	GstElement* _pipeline;
	guint64 _id;
	gboolean _initialized;
	gchar* _path;
	gdouble _rate;
	guint64 _windowId;
};


static gpointer gstd_pipeline_parent_class = NULL;
static gstdPipelineInterfaceIface* gstd_pipeline_gstd_pipeline_interface_parent_iface = NULL;

GType gstd_pipeline_interface_proxy_get_type (void) G_GNUC_CONST;
guint gstd_pipeline_interface_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
GType gstd_pipeline_interface_get_type (void) G_GNUC_CONST;
GType gstd_pipeline_get_type (void) G_GNUC_CONST;
#define GSTD_PIPELINE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GSTD_TYPE_PIPELINE, gstdPipelinePrivate))
enum  {
	GSTD_PIPELINE_DUMMY_PROPERTY
};
static gboolean gstd_pipeline_pipeline_set_state_impl (gstdPipeline* self, GstState state);
gstdPipeline* gstd_pipeline_new (const gchar* description);
gstdPipeline* gstd_pipeline_construct (GType object_type, const gchar* description);
static GstBusSyncReply gstd_pipeline_bus_sync_callback (gstdPipeline* self, GstBus* bus, GstMessage* message);
static GstBusSyncReply _gstd_pipeline_bus_sync_callback_gst_bus_sync_handler (GstBus* bus, GstMessage* message, gpointer self);
static gboolean gstd_pipeline_bus_callback (gstdPipeline* self, GstBus* bus, GstMessage* message);
static gboolean _gstd_pipeline_bus_callback_gst_bus_func (GstBus* bus, GstMessage* message, gpointer self);
static gboolean gstd_pipeline_real_pipeline_set_state (gstdPipelineInterface* base, gint state, GError** error);
static void gstd_pipeline_pipeline_async_set_state_impl (gstdPipeline* self, GstState state);
static void gstd_pipeline_real_pipeline_async_set_state (gstdPipelineInterface* base, gint state, GError** error);
gboolean gstd_pipeline_pipeline_is_initialized (gstdPipeline* self);
static guint64 gstd_pipeline_real_pipeline_get_id (gstdPipelineInterface* base, GError** error);
static void gstd_pipeline_real_pipeline_set_id (gstdPipelineInterface* base, guint64 id, GError** error);
gchar* gstd_pipeline_pipeline_get_path (gstdPipeline* self);
gboolean gstd_pipeline_pipeline_set_path (gstdPipeline* self, const gchar* dbuspath);
static gint gstd_pipeline_real_pipeline_get_state (gstdPipelineInterface* base, GError** error);
static gboolean gstd_pipeline_real_element_set_property_boolean (gstdPipelineInterface* base, const gchar* element, const gchar* property, gboolean val, GError** error);
static gboolean gstd_pipeline_real_element_set_property_int (gstdPipelineInterface* base, const gchar* element, const gchar* property, gint val, GError** error);
static gboolean gstd_pipeline_real_element_set_property_int64 (gstdPipelineInterface* base, const gchar* element, const gchar* property, gint64 val, GError** error);
static gboolean gstd_pipeline_real_element_set_property_string (gstdPipelineInterface* base, const gchar* element, const gchar* property, const gchar* val, GError** error);
static void gstd_pipeline_real_element_get_property_boolean (gstdPipelineInterface* base, const gchar* element, const gchar* property, gboolean* val, gboolean* success, GError** error);
static gboolean gstd_pipeline_element_get_property_boolean_impl (gstdPipeline* self, const gchar* element, const gchar* property, gboolean* val);
static void gstd_pipeline_real_element_get_property_int (gstdPipelineInterface* base, const gchar* element, const gchar* property, gint* val, gboolean* success, GError** error);
static gboolean gstd_pipeline_element_get_property_int_impl (gstdPipeline* self, const gchar* element, const gchar* property, gint* val);
static void gstd_pipeline_real_element_get_property_int64 (gstdPipelineInterface* base, const gchar* element, const gchar* property, gint64* val, gboolean* success, GError** error);
static gboolean gstd_pipeline_element_get_property_int64_impl (gstdPipeline* self, const gchar* element, const gchar* property, gint64* val);
static void gstd_pipeline_real_element_get_property_string (gstdPipelineInterface* base, const gchar* element, const gchar* property, gchar** val, gboolean* success, GError** error);
static gboolean gstd_pipeline_element_get_property_string_impl (gstdPipeline* self, const gchar* element, const gchar* property, gchar** val);
static gint gstd_pipeline_real_element_get_state (gstdPipelineInterface* base, const gchar* element, GError** error);
static void gstd_pipeline_real_element_get_property_buffer (gstdPipelineInterface* base, const gchar* element, const gchar* property, gchar** caps, guint8** data, int* data_length1, gboolean* success, GError** error);
static gboolean gstd_pipeline_element_get_property_buffer_impl (gstdPipeline* self, const gchar* element, const gchar* property, gchar** caps, guint8** data, int* data_length1);
static guint8* _vala_array_dup1 (guint8* self, int length);
static gint64 gstd_pipeline_real_pipeline_get_duration (gstdPipelineInterface* base, GError** error);
static gint64 gstd_pipeline_real_pipeline_get_position (gstdPipelineInterface* base, GError** error);
static gboolean gstd_pipeline_pipeline_seek_impl (gstdPipeline* self, gint64 ipos_ns);
static gboolean gstd_pipeline_real_pipeline_seek (gstdPipelineInterface* base, gint64 ipos_ns, GError** error);
static void gstd_pipeline_real_pipeline_async_seek (gstdPipelineInterface* base, gint64 ipos_ns, GError** error);
static gboolean gstd_pipeline_real_pipeline_skip (gstdPipelineInterface* base, gint64 period_ns, GError** error);
static gboolean gstd_pipeline_real_pipeline_speed (gstdPipelineInterface* base, gdouble new_rate, GError** error);
static void gstd_pipeline_real_pipeline_send_eos (gstdPipelineInterface* base, GError** error);
static void gstd_pipeline_real_pipeline_step (gstdPipelineInterface* base, guint64 frames, GError** error);
static gboolean gstd_pipeline_real_pipeline_send_custom_event (gstdPipelineInterface* base, const gchar* stype, const gchar* name, GError** error);
static gboolean gstd_pipeline_real_element_set_state (gstdPipelineInterface* base, const gchar* element, gint state, GError** error);
static void gstd_pipeline_real_element_async_set_state (gstdPipelineInterface* base, const gchar* element, gint state, GError** error);
static void gstd_pipeline_real_set_window_id (gstdPipelineInterface* base, guint64 winId, GError** error);
static gboolean gstd_pipeline_real_ping (gstdPipelineInterface* base, GError** error);
static void gstd_pipeline_finalize (GObject* obj);


/**
   Create a new instance of a Pipeline
   @param description, gst-launch style string description of the pipeline
   @param ids, pipeline identifier
 */
static GstBusSyncReply _gstd_pipeline_bus_sync_callback_gst_bus_sync_handler (GstBus* bus, GstMessage* message, gpointer self) {
	GstBusSyncReply result;
	result = gstd_pipeline_bus_sync_callback (self, bus, message);
	return result;
}


static gboolean _gstd_pipeline_bus_callback_gst_bus_func (GstBus* bus, GstMessage* message, gpointer self) {
	gboolean result;
	result = gstd_pipeline_bus_callback (self, bus, message);
	return result;
}


gstdPipeline* gstd_pipeline_construct (GType object_type, const gchar* description) {
	gstdPipeline * self = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (description != NULL, NULL);
	self = (gstdPipeline*) g_object_new (object_type, NULL);
	{
		const gchar* _tmp0_;
		GstElement* _tmp1_ = NULL;
		GstElement* _tmp2_;
		GstElement* _tmp3_;
		GstBus* _tmp4_ = NULL;
		GstBus* bus;
		GstBus* _tmp5_;
		GstBus* _tmp6_;
		const gchar* _tmp7_;
		_tmp0_ = description;
		_tmp1_ = gst_parse_launch (_tmp0_, &_inner_error_);
		_tmp2_ = _tmp1_;
		if (_inner_error_ != NULL) {
			goto __catch4_g_error;
		}
		_gst_object_unref0 (self->priv->_pipeline);
		self->priv->_pipeline = GST_IS_ELEMENT (_tmp2_) ? ((GstElement*) _tmp2_) : NULL;
		_tmp3_ = self->priv->_pipeline;
		_tmp4_ = gst_element_get_bus (_tmp3_);
		bus = _tmp4_;
		_tmp5_ = bus;
		gst_bus_set_sync_handler (_tmp5_, _gstd_pipeline_bus_sync_callback_gst_bus_sync_handler, self);
		_tmp6_ = bus;
		gst_bus_add_watch_full (_tmp6_, G_PRIORITY_DEFAULT, _gstd_pipeline_bus_callback_gst_bus_func, g_object_ref (self), g_object_unref);
		g_object_unref ((GObject*) self);
		self->priv->_initialized = TRUE;
		_tmp7_ = description;
		syslog (LOG_NOTICE, "Pipeline created, %s", _tmp7_, NULL);
		_gst_object_unref0 (bus);
	}
	goto __finally4;
	__catch4_g_error:
	{
		GError* e = NULL;
		GError* _tmp8_;
		const gchar* _tmp9_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp8_ = e;
		_tmp9_ = _tmp8_->message;
		syslog (LOG_ERR, "Error constructing pipeline, %s", _tmp9_, NULL);
		_g_error_free0 (e);
	}
	__finally4:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	return self;
}


gstdPipeline* gstd_pipeline_new (const gchar* description) {
	return gstd_pipeline_construct (GSTD_TYPE_PIPELINE, description);
}


static gpointer _gst_object_ref0 (gpointer self) {
	return self ? gst_object_ref (self) : NULL;
}


static GstBusSyncReply gstd_pipeline_bus_sync_callback (gstdPipeline* self, GstBus* bus, GstMessage* message) {
	GstBusSyncReply result = 0;
	guint64 _tmp0_;
	GstMessage* _tmp1_;
	const GstStructure* _tmp2_ = NULL;
	const GstStructure* st;
	gboolean _tmp3_ = FALSE;
	const GstStructure* _tmp4_;
	gboolean _tmp7_;
	GstElement* _tmp8_;
	GstPipeline* _tmp9_;
	GstPipeline* pipe;
	GstPipeline* _tmp10_;
	GstPipeline* _tmp11_;
	GstObject* _tmp12_ = NULL;
	GstElement* sink;
	GstElement* _tmp13_;
	GstElement* _tmp14_;
	GstXOverlay* _tmp15_;
	GstXOverlay* overlay;
	GstXOverlay* _tmp16_;
	guint64 _tmp17_;
	GstXOverlay* _tmp18_;
	guint64 _tmp19_;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (bus != NULL, 0);
	g_return_val_if_fail (message != NULL, 0);
	_tmp0_ = self->priv->_windowId;
	if (_tmp0_ == ((guint64) 0)) {
		result = GST_BUS_PASS;
		return result;
	}
	_tmp1_ = message;
	_tmp2_ = gst_message_get_structure (_tmp1_);
	st = _tmp2_;
	_tmp4_ = st;
	if (_tmp4_ != NULL) {
		const GstStructure* _tmp5_;
		gboolean _tmp6_ = FALSE;
		_tmp5_ = st;
		_tmp6_ = gst_structure_has_name (_tmp5_, "prepare-xwindow-id");
		_tmp3_ = _tmp6_;
	} else {
		_tmp3_ = FALSE;
	}
	_tmp7_ = _tmp3_;
	if (!_tmp7_) {
		result = GST_BUS_PASS;
		return result;
	}
	syslog (LOG_DEBUG, "requested xwindow-id", NULL);
	_tmp8_ = self->priv->_pipeline;
	_tmp9_ = _gst_object_ref0 (GST_IS_PIPELINE (_tmp8_) ? ((GstPipeline*) _tmp8_) : NULL);
	pipe = _tmp9_;
	_tmp10_ = pipe;
	g_assert (_tmp10_ != NULL);
	_tmp11_ = pipe;
	_tmp12_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) _tmp11_, "videosink");
	sink = GST_IS_ELEMENT (_tmp12_) ? ((GstElement*) _tmp12_) : NULL;
	_tmp13_ = sink;
	if (_tmp13_ == NULL) {
		result = GST_BUS_PASS;
		_gst_object_unref0 (sink);
		_gst_object_unref0 (pipe);
		return result;
	}
	_tmp14_ = sink;
	_tmp15_ = _gst_object_ref0 (GST_IS_X_OVERLAY (_tmp14_) ? ((GstXOverlay*) _tmp14_) : NULL);
	overlay = _tmp15_;
	_tmp16_ = overlay;
	if (_tmp16_ == NULL) {
		result = GST_BUS_PASS;
		_gst_object_unref0 (overlay);
		_gst_object_unref0 (sink);
		_gst_object_unref0 (pipe);
		return result;
	}
	_tmp17_ = self->priv->_windowId;
	syslog (LOG_DEBUG, "set xwindow-id %llu", _tmp17_, NULL);
	_tmp18_ = overlay;
	_tmp19_ = self->priv->_windowId;
	gst_x_overlay_set_xwindow_id (_tmp18_, (gulong) _tmp19_);
	result = GST_BUS_PASS;
	_gst_object_unref0 (overlay);
	_gst_object_unref0 (sink);
	_gst_object_unref0 (pipe);
	return result;
}


static gboolean gstd_pipeline_bus_callback (gstdPipeline* self, GstBus* bus, GstMessage* message) {
	gboolean result = FALSE;
	GstMessage* _tmp0_;
	GstMessageType _tmp1_;
	const gchar* _tmp2_ = NULL;
	GstMessage* _tmp3_;
	GstMessageType _tmp4_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (bus != NULL, FALSE);
	g_return_val_if_fail (message != NULL, FALSE);
	_tmp0_ = message;
	_tmp1_ = _tmp0_->type;
	_tmp2_ = gst_message_type_get_name (_tmp1_);
	syslog (LOG_DEBUG, "received message %s", _tmp2_, NULL);
	_tmp3_ = message;
	_tmp4_ = _tmp3_->type;
	switch (_tmp4_) {
		case GST_MESSAGE_ERROR:
		{
			GError* err = NULL;
			gchar* dbg = NULL;
			GstMessage* _tmp5_;
			GError* _tmp6_ = NULL;
			gchar* _tmp7_ = NULL;
			guint64 _tmp8_;
			GError* _tmp9_;
			const gchar* _tmp10_;
			GError* _tmp11_;
			const gchar* _tmp12_;
			_tmp5_ = message;
			gst_message_parse_error (_tmp5_, &_tmp6_, &_tmp7_);
			_g_error_free0 (err);
			err = _tmp6_;
			_g_free0 (dbg);
			dbg = _tmp7_;
			_tmp8_ = self->priv->_id;
			_tmp9_ = err;
			_tmp10_ = _tmp9_->message;
			g_signal_emit_by_name ((gstdPipelineInterface*) self, "error", _tmp8_, _tmp10_);
			_tmp11_ = err;
			_tmp12_ = _tmp11_->message;
			syslog (LOG_DEBUG, "Error on pipeline, %s", _tmp12_, NULL);
			_g_free0 (dbg);
			_g_error_free0 (err);
			break;
		}
		case GST_MESSAGE_EOS:
		{
			guint64 _tmp13_;
			_tmp13_ = self->priv->_id;
			g_signal_emit_by_name ((gstdPipelineInterface*) self, "eos", _tmp13_);
			break;
		}
		case GST_MESSAGE_STATE_CHANGED:
		{
			GstState oldstate = 0;
			GstState newstate = 0;
			GstState pending = 0;
			GstMessage* _tmp14_;
			GstObject* _tmp15_;
			gchar* _tmp16_ = NULL;
			gchar* src;
			GstMessage* _tmp17_;
			GstState _tmp18_ = 0;
			GstState _tmp19_ = 0;
			GstState _tmp20_ = 0;
			const gchar* _tmp21_;
			GstState _tmp22_;
			const gchar* _tmp23_ = NULL;
			GstState _tmp24_;
			const gchar* _tmp25_ = NULL;
			guint64 _tmp26_;
			GstState _tmp27_;
			GstState _tmp28_;
			const gchar* _tmp29_;
			_tmp14_ = message;
			_tmp15_ = _tmp14_->src;
			_tmp16_ = gst_object_get_name ((GstObject*) (GST_IS_ELEMENT (_tmp15_) ? ((GstElement*) _tmp15_) : NULL));
			src = _tmp16_;
			_tmp17_ = message;
			gst_message_parse_state_changed (_tmp17_, &_tmp18_, &_tmp19_, &_tmp20_);
			oldstate = _tmp18_;
			newstate = _tmp19_;
			pending = _tmp20_;
			_tmp21_ = src;
			_tmp22_ = oldstate;
			_tmp23_ = gst_element_state_get_name (_tmp22_);
			_tmp24_ = newstate;
			_tmp25_ = gst_element_state_get_name (_tmp24_);
			syslog (LOG_INFO, "%s,changes state from %s to %s", _tmp21_, _tmp23_, _tmp25_, NULL);
			_tmp26_ = self->priv->_id;
			_tmp27_ = oldstate;
			_tmp28_ = newstate;
			_tmp29_ = src;
			g_signal_emit_by_name ((gstdPipelineInterface*) self, "state-changed", _tmp26_, (gint) _tmp27_, (gint) _tmp28_, _tmp29_);
			_g_free0 (src);
			break;
		}
		case GST_MESSAGE_QOS:
		{
			gboolean live = FALSE;
			guint64 running_time = 0ULL;
			guint64 stream_time = 0ULL;
			guint64 timestamp = 0ULL;
			guint64 duration = 0ULL;
			gint64 jitter = 0LL;
			gdouble proportion = 0.0;
			gint quality = 0;
			gint format = 0;
			guint64 processed = 0ULL;
			guint64 dropped = 0ULL;
			GstMessage* _tmp30_;
			gboolean _tmp31_ = FALSE;
			guint64 _tmp32_ = 0ULL;
			guint64 _tmp33_ = 0ULL;
			guint64 _tmp34_ = 0ULL;
			guint64 _tmp35_ = 0ULL;
			GstMessage* _tmp36_;
			gint64 _tmp37_ = 0LL;
			gdouble _tmp38_ = 0.0;
			gint _tmp39_ = 0;
			GstFormat fmt = 0;
			GstMessage* _tmp40_;
			GstFormat _tmp41_ = 0;
			guint64 _tmp42_ = 0ULL;
			guint64 _tmp43_ = 0ULL;
			GstFormat _tmp44_;
			guint64 _tmp45_;
			gboolean _tmp46_;
			guint64 _tmp47_;
			guint64 _tmp48_;
			guint64 _tmp49_;
			guint64 _tmp50_;
			gint64 _tmp51_;
			gdouble _tmp52_;
			gint _tmp53_;
			gint _tmp54_;
			guint64 _tmp55_;
			guint64 _tmp56_;
			_tmp30_ = message;
			gst_message_parse_qos (_tmp30_, &_tmp31_, &_tmp32_, &_tmp33_, &_tmp34_, &_tmp35_);
			live = _tmp31_;
			running_time = _tmp32_;
			stream_time = _tmp33_;
			timestamp = _tmp34_;
			duration = _tmp35_;
			_tmp36_ = message;
			gst_message_parse_qos_values (_tmp36_, &_tmp37_, &_tmp38_, &_tmp39_);
			jitter = _tmp37_;
			proportion = _tmp38_;
			quality = _tmp39_;
			_tmp40_ = message;
			gst_message_parse_qos_stats (_tmp40_, &_tmp41_, &_tmp42_, &_tmp43_);
			fmt = _tmp41_;
			processed = _tmp42_;
			dropped = _tmp43_;
			_tmp44_ = fmt;
			format = (gint) _tmp44_;
			_tmp45_ = self->priv->_id;
			_tmp46_ = live;
			_tmp47_ = running_time;
			_tmp48_ = stream_time;
			_tmp49_ = timestamp;
			_tmp50_ = duration;
			_tmp51_ = jitter;
			_tmp52_ = proportion;
			_tmp53_ = quality;
			_tmp54_ = format;
			_tmp55_ = processed;
			_tmp56_ = dropped;
			g_signal_emit_by_name ((gstdPipelineInterface*) self, "qos", _tmp45_, _tmp46_, _tmp47_, _tmp48_, _tmp49_, _tmp50_, _tmp51_, _tmp52_, _tmp53_, _tmp54_, _tmp55_, _tmp56_);
			break;
		}
		default:
		{
			break;
		}
	}
	result = TRUE;
	return result;
}


static gboolean gstd_pipeline_pipeline_set_state_impl (gstdPipeline* self, GstState state) {
	gboolean result = FALSE;
	GstElement* _tmp0_;
	GstState _tmp1_;
	GstState current = 0;
	GstState pending = 0;
	GstElement* _tmp2_;
	GstState _tmp3_ = 0;
	GstState _tmp4_ = 0;
	GstState _tmp5_;
	GstState _tmp6_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_pipeline;
	_tmp1_ = state;
	gst_element_set_state (_tmp0_, _tmp1_);
	_tmp2_ = self->priv->_pipeline;
	gst_element_get_state (_tmp2_, &_tmp3_, &_tmp4_, (GstClockTime) GST_CLOCK_TIME_NONE);
	current = _tmp3_;
	pending = _tmp4_;
	_tmp5_ = current;
	_tmp6_ = state;
	if (_tmp5_ != _tmp6_) {
		GstState _tmp7_;
		const gchar* _tmp8_ = NULL;
		_tmp7_ = state;
		_tmp8_ = gst_element_state_get_name (_tmp7_);
		syslog (LOG_ERR, "Pipeline failed to change state to %s", _tmp8_, NULL);
		result = FALSE;
		return result;
	}
	result = TRUE;
	return result;
}


static gboolean gstd_pipeline_real_pipeline_set_state (gstdPipelineInterface* base, gint state, GError** error) {
	gstdPipeline * self;
	gboolean result = FALSE;
	gint _tmp0_;
	gboolean _tmp1_ = FALSE;
	self = (gstdPipeline*) base;
	_tmp0_ = state;
	_tmp1_ = gstd_pipeline_pipeline_set_state_impl (self, (GstState) _tmp0_);
	result = _tmp1_;
	return result;
}


static void gstd_pipeline_pipeline_async_set_state_impl (gstdPipeline* self, GstState state) {
	GstElement* _tmp0_;
	GstState _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->_pipeline;
	_tmp1_ = state;
	gst_element_set_state (_tmp0_, _tmp1_);
}


static void gstd_pipeline_real_pipeline_async_set_state (gstdPipelineInterface* base, gint state, GError** error) {
	gstdPipeline * self;
	gint _tmp0_;
	self = (gstdPipeline*) base;
	_tmp0_ = state;
	gstd_pipeline_pipeline_async_set_state_impl (self, (GstState) _tmp0_);
}


/**
   Returns initialized flag value.
 */
gboolean gstd_pipeline_pipeline_is_initialized (gstdPipeline* self) {
	gboolean result = FALSE;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_initialized;
	result = _tmp0_;
	return result;
}


/**
           Gets the id of the pipe.
          */
static guint64 gstd_pipeline_real_pipeline_get_id (gstdPipelineInterface* base, GError** error) {
	gstdPipeline * self;
	guint64 result = 0ULL;
	guint64 _tmp0_;
	self = (gstdPipeline*) base;
	_tmp0_ = self->priv->_id;
	result = _tmp0_;
	return result;
}


/**
           Sets the id of the pipe.
          */
static void gstd_pipeline_real_pipeline_set_id (gstdPipelineInterface* base, guint64 id, GError** error) {
	gstdPipeline * self;
	guint64 _tmp0_;
	self = (gstdPipeline*) base;
	_tmp0_ = id;
	self->priv->_id = _tmp0_;
}


/**
   Returns the dbus-path assigned when created
 */
gchar* gstd_pipeline_pipeline_get_path (gstdPipeline* self) {
	gchar* result = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_path;
	_tmp1_ = g_strdup (_tmp0_);
	result = _tmp1_;
	return result;
}


/**
   Sets a dbus-path,this is assigned when connected to daemon
 */
gboolean gstd_pipeline_pipeline_set_path (gstdPipeline* self, const gchar* dbuspath) {
	gboolean result = FALSE;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (dbuspath != NULL, FALSE);
	_tmp0_ = dbuspath;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_path);
	self->priv->_path = _tmp1_;
	result = TRUE;
	return result;
}


/**
   Gets the pipeline state
 */
static gint gstd_pipeline_real_pipeline_get_state (gstdPipelineInterface* base, GError** error) {
	gstdPipeline * self;
	gint result = 0;
	GstState current = 0;
	GstState pending = 0;
	GstElement* _tmp0_;
	GstState _tmp1_ = 0;
	GstState _tmp2_ = 0;
	self = (gstdPipeline*) base;
	_tmp0_ = self->priv->_pipeline;
	gst_element_get_state (_tmp0_, &_tmp1_, &_tmp2_, (GstClockTime) GST_CLOCK_TIME_NONE);
	current = _tmp1_;
	pending = _tmp2_;
	result = (gint) current;
	return result;
}


/**
   Sets a boolean property for an element on the pipeline
   @param element, whose property needs to be set
   @param property,property name
   @param val, bool property value
 */
static gpointer _g_param_spec_ref0 (gpointer self) {
	return self ? g_param_spec_ref (self) : NULL;
}


static gboolean gstd_pipeline_real_element_set_property_boolean (gstdPipelineInterface* base, const gchar* element, const gchar* property, gboolean val, GError** error) {
	gstdPipeline * self;
	gboolean result = FALSE;
	GstElement* _tmp0_;
	GstPipeline* _tmp1_;
	GstPipeline* pipe;
	GstPipeline* _tmp2_;
	const gchar* _tmp3_;
	GstObject* _tmp4_ = NULL;
	GstElement* e;
	GstElement* _tmp5_;
	GstElement* _tmp7_;
	GObjectClass* _tmp8_ = NULL;
	const gchar* _tmp9_;
	GParamSpec* _tmp10_ = NULL;
	GParamSpec* _tmp11_;
	GParamSpec* spec;
	GParamSpec* _tmp12_;
	GstElement* _tmp15_;
	const gchar* _tmp16_;
	gboolean _tmp17_;
	self = (gstdPipeline*) base;
	g_return_val_if_fail (element != NULL, FALSE);
	g_return_val_if_fail (property != NULL, FALSE);
	_tmp0_ = self->priv->_pipeline;
	_tmp1_ = _gst_object_ref0 (GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL);
	pipe = _tmp1_;
	_tmp2_ = pipe;
	_tmp3_ = element;
	_tmp4_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) _tmp2_, _tmp3_);
	e = GST_IS_ELEMENT (_tmp4_) ? ((GstElement*) _tmp4_) : NULL;
	_tmp5_ = e;
	if (_tmp5_ == NULL) {
		const gchar* _tmp6_;
		_tmp6_ = element;
		syslog (LOG_WARNING, "Element %s not found on pipeline", _tmp6_, NULL);
		result = FALSE;
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		return result;
	}
	_tmp7_ = e;
	_tmp8_ = G_OBJECT_GET_CLASS ((GObject*) _tmp7_);
	_tmp9_ = property;
	_tmp10_ = g_object_class_find_property (_tmp8_, _tmp9_);
	_tmp11_ = _g_param_spec_ref0 (_tmp10_);
	spec = _tmp11_;
	_tmp12_ = spec;
	if (_tmp12_ == NULL) {
		const gchar* _tmp13_;
		const gchar* _tmp14_;
		_tmp13_ = element;
		_tmp14_ = property;
		syslog (LOG_WARNING, "Element %s does not have the property %s", _tmp13_, _tmp14_, NULL);
		result = FALSE;
		_g_param_spec_unref0 (spec);
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		return result;
	}
	_tmp15_ = e;
	_tmp16_ = property;
	_tmp17_ = val;
	g_object_set ((GObject*) _tmp15_, _tmp16_, _tmp17_, NULL, NULL);
	result = TRUE;
	_g_param_spec_unref0 (spec);
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	return result;
}


/**
   Sets an int property for an element on the pipeline
   @param element, whose property needs to be set
   @param property,property name
   @param val, int property value
 */
static gboolean gstd_pipeline_real_element_set_property_int (gstdPipelineInterface* base, const gchar* element, const gchar* property, gint val, GError** error) {
	gstdPipeline * self;
	gboolean result = FALSE;
	GstElement* _tmp0_;
	GstPipeline* _tmp1_;
	GstPipeline* pipe;
	GstPipeline* _tmp2_;
	const gchar* _tmp3_;
	GstObject* _tmp4_ = NULL;
	GstElement* e;
	GstElement* _tmp5_;
	GstElement* _tmp7_;
	GObjectClass* _tmp8_ = NULL;
	const gchar* _tmp9_;
	GParamSpec* _tmp10_ = NULL;
	GParamSpec* _tmp11_;
	GParamSpec* spec;
	GParamSpec* _tmp12_;
	GstElement* _tmp15_;
	const gchar* _tmp16_;
	gint _tmp17_;
	self = (gstdPipeline*) base;
	g_return_val_if_fail (element != NULL, FALSE);
	g_return_val_if_fail (property != NULL, FALSE);
	_tmp0_ = self->priv->_pipeline;
	_tmp1_ = _gst_object_ref0 (GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL);
	pipe = _tmp1_;
	_tmp2_ = pipe;
	_tmp3_ = element;
	_tmp4_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) _tmp2_, _tmp3_);
	e = GST_IS_ELEMENT (_tmp4_) ? ((GstElement*) _tmp4_) : NULL;
	_tmp5_ = e;
	if (_tmp5_ == NULL) {
		const gchar* _tmp6_;
		_tmp6_ = element;
		syslog (LOG_WARNING, "Element %s not found on pipeline", _tmp6_, NULL);
		result = FALSE;
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		return result;
	}
	_tmp7_ = e;
	_tmp8_ = G_OBJECT_GET_CLASS ((GObject*) _tmp7_);
	_tmp9_ = property;
	_tmp10_ = g_object_class_find_property (_tmp8_, _tmp9_);
	_tmp11_ = _g_param_spec_ref0 (_tmp10_);
	spec = _tmp11_;
	_tmp12_ = spec;
	if (_tmp12_ == NULL) {
		const gchar* _tmp13_;
		const gchar* _tmp14_;
		_tmp13_ = element;
		_tmp14_ = property;
		syslog (LOG_WARNING, "Gstd: Element %s does not have the property %s", _tmp13_, _tmp14_, NULL);
		result = FALSE;
		_g_param_spec_unref0 (spec);
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		return result;
	}
	_tmp15_ = e;
	_tmp16_ = property;
	_tmp17_ = val;
	g_object_set ((GObject*) _tmp15_, _tmp16_, _tmp17_, NULL, NULL);
	result = TRUE;
	_g_param_spec_unref0 (spec);
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	return result;
}


/**
   Sets an long property for an element on the pipeline
   @param element, whose property needs to be set
   @param property,property name
   @param val, long property value     */
static gboolean gstd_pipeline_real_element_set_property_int64 (gstdPipelineInterface* base, const gchar* element, const gchar* property, gint64 val, GError** error) {
	gstdPipeline * self;
	gboolean result = FALSE;
	GstElement* _tmp0_;
	GstPipeline* _tmp1_;
	GstPipeline* pipe;
	GstPipeline* _tmp2_;
	const gchar* _tmp3_;
	GstObject* _tmp4_ = NULL;
	GstElement* e;
	GstElement* _tmp5_;
	GstElement* _tmp7_;
	GObjectClass* _tmp8_ = NULL;
	const gchar* _tmp9_;
	GParamSpec* _tmp10_ = NULL;
	GParamSpec* _tmp11_;
	GParamSpec* spec;
	GParamSpec* _tmp12_;
	GstElement* _tmp15_;
	const gchar* _tmp16_;
	gint64 _tmp17_;
	self = (gstdPipeline*) base;
	g_return_val_if_fail (element != NULL, FALSE);
	g_return_val_if_fail (property != NULL, FALSE);
	_tmp0_ = self->priv->_pipeline;
	_tmp1_ = _gst_object_ref0 (GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL);
	pipe = _tmp1_;
	_tmp2_ = pipe;
	_tmp3_ = element;
	_tmp4_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) _tmp2_, _tmp3_);
	e = GST_IS_ELEMENT (_tmp4_) ? ((GstElement*) _tmp4_) : NULL;
	_tmp5_ = e;
	if (_tmp5_ == NULL) {
		const gchar* _tmp6_;
		_tmp6_ = element;
		syslog (LOG_WARNING, "Element %s not found on pipeline", _tmp6_, NULL);
		result = FALSE;
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		return result;
	}
	_tmp7_ = e;
	_tmp8_ = G_OBJECT_GET_CLASS ((GObject*) _tmp7_);
	_tmp9_ = property;
	_tmp10_ = g_object_class_find_property (_tmp8_, _tmp9_);
	_tmp11_ = _g_param_spec_ref0 (_tmp10_);
	spec = _tmp11_;
	_tmp12_ = spec;
	if (_tmp12_ == NULL) {
		const gchar* _tmp13_;
		const gchar* _tmp14_;
		_tmp13_ = element;
		_tmp14_ = property;
		syslog (LOG_WARNING, "Element %s does not have the property %s", _tmp13_, _tmp14_, NULL);
		result = FALSE;
		_g_param_spec_unref0 (spec);
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		return result;
	}
	_tmp15_ = e;
	_tmp16_ = property;
	_tmp17_ = val;
	g_object_set ((GObject*) _tmp15_, _tmp16_, _tmp17_, NULL, NULL);
	result = TRUE;
	_g_param_spec_unref0 (spec);
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	return result;
}


/**
   Sets a string property for an element on the pipeline
   @param element, whose property needs to be set
   @param property,property name
   @param val,string property value
 */
static gboolean gstd_pipeline_real_element_set_property_string (gstdPipelineInterface* base, const gchar* element, const gchar* property, const gchar* val, GError** error) {
	gstdPipeline * self;
	gboolean result = FALSE;
	GstElement* _tmp0_;
	GstPipeline* _tmp1_;
	GstPipeline* pipe;
	GstPipeline* _tmp2_;
	const gchar* _tmp3_;
	GstObject* _tmp4_ = NULL;
	GstElement* e;
	GstElement* _tmp5_;
	GstElement* _tmp7_;
	GObjectClass* _tmp8_ = NULL;
	const gchar* _tmp9_;
	GParamSpec* _tmp10_ = NULL;
	GParamSpec* _tmp11_;
	GParamSpec* spec;
	GParamSpec* _tmp12_;
	GstElement* _tmp15_;
	const gchar* _tmp16_;
	const gchar* _tmp17_;
	self = (gstdPipeline*) base;
	g_return_val_if_fail (element != NULL, FALSE);
	g_return_val_if_fail (property != NULL, FALSE);
	g_return_val_if_fail (val != NULL, FALSE);
	_tmp0_ = self->priv->_pipeline;
	_tmp1_ = _gst_object_ref0 (GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL);
	pipe = _tmp1_;
	_tmp2_ = pipe;
	_tmp3_ = element;
	_tmp4_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) _tmp2_, _tmp3_);
	e = GST_IS_ELEMENT (_tmp4_) ? ((GstElement*) _tmp4_) : NULL;
	_tmp5_ = e;
	if (_tmp5_ == NULL) {
		const gchar* _tmp6_;
		_tmp6_ = element;
		syslog (LOG_WARNING, "Element %s not found on pipeline", _tmp6_, NULL);
		result = FALSE;
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		return result;
	}
	_tmp7_ = e;
	_tmp8_ = G_OBJECT_GET_CLASS ((GObject*) _tmp7_);
	_tmp9_ = property;
	_tmp10_ = g_object_class_find_property (_tmp8_, _tmp9_);
	_tmp11_ = _g_param_spec_ref0 (_tmp10_);
	spec = _tmp11_;
	_tmp12_ = spec;
	if (_tmp12_ == NULL) {
		const gchar* _tmp13_;
		const gchar* _tmp14_;
		_tmp13_ = element;
		_tmp14_ = property;
		syslog (LOG_WARNING, "Element %s does not have the property %s", _tmp13_, _tmp14_, NULL);
		result = FALSE;
		_g_param_spec_unref0 (spec);
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		return result;
	}
	_tmp15_ = e;
	_tmp16_ = property;
	_tmp17_ = val;
	g_object_set ((GObject*) _tmp15_, _tmp16_, _tmp17_, NULL, NULL);
	result = TRUE;
	_g_param_spec_unref0 (spec);
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	return result;
}


static void gstd_pipeline_real_element_get_property_boolean (gstdPipelineInterface* base, const gchar* element, const gchar* property, gboolean* val, gboolean* success, GError** error) {
	gstdPipeline * self;
	gboolean _vala_val = FALSE;
	gboolean _vala_success = FALSE;
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	self = (gstdPipeline*) base;
	g_return_if_fail (element != NULL);
	g_return_if_fail (property != NULL);
	_tmp0_ = element;
	_tmp1_ = property;
	_tmp3_ = gstd_pipeline_element_get_property_boolean_impl (self, _tmp0_, _tmp1_, &_tmp2_);
	_vala_val = _tmp2_;
	_vala_success = _tmp3_;
	if (val) {
		*val = _vala_val;
	}
	if (success) {
		*success = _vala_success;
	}
}


/**
   Gets an element's bool property value of a specific pipeline
   @param element, whose property value wants to be known
   @param property,property name
 */
static gboolean gstd_pipeline_element_get_property_boolean_impl (gstdPipeline* self, const gchar* element, const gchar* property, gboolean* val) {
	gboolean _vala_val = FALSE;
	gboolean result = FALSE;
	GstElement* _tmp0_;
	GstPipeline* _tmp1_;
	GstPipeline* pipe;
	GstPipeline* _tmp2_;
	const gchar* _tmp3_;
	GstObject* _tmp4_ = NULL;
	GstElement* e;
	GstElement* _tmp5_;
	GstElement* _tmp7_;
	GObjectClass* _tmp8_ = NULL;
	const gchar* _tmp9_;
	GParamSpec* _tmp10_ = NULL;
	GParamSpec* _tmp11_;
	GParamSpec* spec;
	GParamSpec* _tmp12_;
	GstElement* _tmp15_;
	const gchar* _tmp16_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (element != NULL, FALSE);
	g_return_val_if_fail (property != NULL, FALSE);
	_vala_val = FALSE;
	_tmp0_ = self->priv->_pipeline;
	_tmp1_ = _gst_object_ref0 (GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL);
	pipe = _tmp1_;
	_tmp2_ = pipe;
	_tmp3_ = element;
	_tmp4_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) _tmp2_, _tmp3_);
	e = GST_IS_ELEMENT (_tmp4_) ? ((GstElement*) _tmp4_) : NULL;
	_tmp5_ = e;
	if (_tmp5_ == NULL) {
		const gchar* _tmp6_;
		_tmp6_ = element;
		syslog (LOG_WARNING, "Element %s not found on pipeline", _tmp6_, NULL);
		result = FALSE;
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		if (val) {
			*val = _vala_val;
		}
		return result;
	}
	_tmp7_ = e;
	_tmp8_ = G_OBJECT_GET_CLASS ((GObject*) _tmp7_);
	_tmp9_ = property;
	_tmp10_ = g_object_class_find_property (_tmp8_, _tmp9_);
	_tmp11_ = _g_param_spec_ref0 (_tmp10_);
	spec = _tmp11_;
	_tmp12_ = spec;
	if (_tmp12_ == NULL) {
		const gchar* _tmp13_;
		const gchar* _tmp14_;
		_tmp13_ = element;
		_tmp14_ = property;
		syslog (LOG_WARNING, "Element %s does not have the property %s", _tmp13_, _tmp14_, NULL);
		result = FALSE;
		_g_param_spec_unref0 (spec);
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		if (val) {
			*val = _vala_val;
		}
		return result;
	}
	_tmp15_ = e;
	_tmp16_ = property;
	g_object_get ((GObject*) _tmp15_, _tmp16_, &_vala_val, NULL, NULL);
	result = TRUE;
	_g_param_spec_unref0 (spec);
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	if (val) {
		*val = _vala_val;
	}
	return result;
}


static void gstd_pipeline_real_element_get_property_int (gstdPipelineInterface* base, const gchar* element, const gchar* property, gint* val, gboolean* success, GError** error) {
	gstdPipeline * self;
	gint _vala_val = 0;
	gboolean _vala_success = FALSE;
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	gint _tmp2_ = 0;
	gboolean _tmp3_ = FALSE;
	self = (gstdPipeline*) base;
	g_return_if_fail (element != NULL);
	g_return_if_fail (property != NULL);
	_tmp0_ = element;
	_tmp1_ = property;
	_tmp3_ = gstd_pipeline_element_get_property_int_impl (self, _tmp0_, _tmp1_, &_tmp2_);
	_vala_val = _tmp2_;
	_vala_success = _tmp3_;
	if (val) {
		*val = _vala_val;
	}
	if (success) {
		*success = _vala_success;
	}
}


/**
   Gets an element's int property value of a specific pipeline
   @param element, whose property value wants to be known
   @param property,property name
   @param val value of the property
 */
static gboolean gstd_pipeline_element_get_property_int_impl (gstdPipeline* self, const gchar* element, const gchar* property, gint* val) {
	gint _vala_val = 0;
	gboolean result = FALSE;
	GstElement* _tmp0_;
	GstPipeline* _tmp1_;
	GstPipeline* pipe;
	GstPipeline* _tmp2_;
	const gchar* _tmp3_;
	GstObject* _tmp4_ = NULL;
	GstElement* e;
	GstElement* _tmp5_;
	GstElement* _tmp7_;
	GObjectClass* _tmp8_ = NULL;
	const gchar* _tmp9_;
	GParamSpec* _tmp10_ = NULL;
	GParamSpec* _tmp11_;
	GParamSpec* spec;
	GParamSpec* _tmp12_;
	GstElement* _tmp15_;
	const gchar* _tmp16_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (element != NULL, FALSE);
	g_return_val_if_fail (property != NULL, FALSE);
	_vala_val = 0;
	_tmp0_ = self->priv->_pipeline;
	_tmp1_ = _gst_object_ref0 (GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL);
	pipe = _tmp1_;
	_tmp2_ = pipe;
	_tmp3_ = element;
	_tmp4_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) _tmp2_, _tmp3_);
	e = GST_IS_ELEMENT (_tmp4_) ? ((GstElement*) _tmp4_) : NULL;
	_tmp5_ = e;
	if (_tmp5_ == NULL) {
		const gchar* _tmp6_;
		_tmp6_ = element;
		syslog (LOG_WARNING, "Element %s not found on pipeline", _tmp6_, NULL);
		result = FALSE;
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		if (val) {
			*val = _vala_val;
		}
		return result;
	}
	_tmp7_ = e;
	_tmp8_ = G_OBJECT_GET_CLASS ((GObject*) _tmp7_);
	_tmp9_ = property;
	_tmp10_ = g_object_class_find_property (_tmp8_, _tmp9_);
	_tmp11_ = _g_param_spec_ref0 (_tmp10_);
	spec = _tmp11_;
	_tmp12_ = spec;
	if (_tmp12_ == NULL) {
		const gchar* _tmp13_;
		const gchar* _tmp14_;
		_tmp13_ = element;
		_tmp14_ = property;
		syslog (LOG_WARNING, "Element %s does not have the property %s", _tmp13_, _tmp14_, NULL);
		result = FALSE;
		_g_param_spec_unref0 (spec);
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		if (val) {
			*val = _vala_val;
		}
		return result;
	}
	_tmp15_ = e;
	_tmp16_ = property;
	g_object_get ((GObject*) _tmp15_, _tmp16_, &_vala_val, NULL, NULL);
	result = TRUE;
	_g_param_spec_unref0 (spec);
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	if (val) {
		*val = _vala_val;
	}
	return result;
}


static void gstd_pipeline_real_element_get_property_int64 (gstdPipelineInterface* base, const gchar* element, const gchar* property, gint64* val, gboolean* success, GError** error) {
	gstdPipeline * self;
	gint64 _vala_val = 0LL;
	gboolean _vala_success = FALSE;
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	gint64 _tmp2_ = 0LL;
	gboolean _tmp3_ = FALSE;
	self = (gstdPipeline*) base;
	g_return_if_fail (element != NULL);
	g_return_if_fail (property != NULL);
	_tmp0_ = element;
	_tmp1_ = property;
	_tmp3_ = gstd_pipeline_element_get_property_int64_impl (self, _tmp0_, _tmp1_, &_tmp2_);
	_vala_val = _tmp2_;
	_vala_success = _tmp3_;
	if (val) {
		*val = _vala_val;
	}
	if (success) {
		*success = _vala_success;
	}
}


/**
   Gets an element's long property value of a specific pipeline
   @param element, whose property value wants to be known
   @param property,property name
   @param val value of the property
 */
static gboolean gstd_pipeline_element_get_property_int64_impl (gstdPipeline* self, const gchar* element, const gchar* property, gint64* val) {
	gint64 _vala_val = 0LL;
	gboolean result = FALSE;
	GstElement* _tmp0_;
	GstPipeline* _tmp1_;
	GstPipeline* pipe;
	GstPipeline* _tmp2_;
	const gchar* _tmp3_;
	GstObject* _tmp4_ = NULL;
	GstElement* e;
	GstElement* _tmp5_;
	GstElement* _tmp7_;
	GObjectClass* _tmp8_ = NULL;
	const gchar* _tmp9_;
	GParamSpec* _tmp10_ = NULL;
	GParamSpec* _tmp11_;
	GParamSpec* spec;
	GParamSpec* _tmp12_;
	GstElement* _tmp15_;
	const gchar* _tmp16_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (element != NULL, FALSE);
	g_return_val_if_fail (property != NULL, FALSE);
	_vala_val = (gint64) 0;
	_tmp0_ = self->priv->_pipeline;
	_tmp1_ = _gst_object_ref0 (GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL);
	pipe = _tmp1_;
	_tmp2_ = pipe;
	_tmp3_ = element;
	_tmp4_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) _tmp2_, _tmp3_);
	e = GST_IS_ELEMENT (_tmp4_) ? ((GstElement*) _tmp4_) : NULL;
	_tmp5_ = e;
	if (_tmp5_ == NULL) {
		const gchar* _tmp6_;
		_tmp6_ = element;
		syslog (LOG_WARNING, "Element %s not found on pipeline", _tmp6_, NULL);
		result = FALSE;
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		if (val) {
			*val = _vala_val;
		}
		return result;
	}
	_tmp7_ = e;
	_tmp8_ = G_OBJECT_GET_CLASS ((GObject*) _tmp7_);
	_tmp9_ = property;
	_tmp10_ = g_object_class_find_property (_tmp8_, _tmp9_);
	_tmp11_ = _g_param_spec_ref0 (_tmp10_);
	spec = _tmp11_;
	_tmp12_ = spec;
	if (_tmp12_ == NULL) {
		const gchar* _tmp13_;
		const gchar* _tmp14_;
		_tmp13_ = element;
		_tmp14_ = property;
		syslog (LOG_WARNING, "Element %s does not have the property %s", _tmp13_, _tmp14_, NULL);
		result = FALSE;
		_g_param_spec_unref0 (spec);
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		if (val) {
			*val = _vala_val;
		}
		return result;
	}
	_tmp15_ = e;
	_tmp16_ = property;
	g_object_get ((GObject*) _tmp15_, _tmp16_, &_vala_val, NULL, NULL);
	result = TRUE;
	_g_param_spec_unref0 (spec);
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	if (val) {
		*val = _vala_val;
	}
	return result;
}


static void gstd_pipeline_real_element_get_property_string (gstdPipelineInterface* base, const gchar* element, const gchar* property, gchar** val, gboolean* success, GError** error) {
	gstdPipeline * self;
	gchar* _vala_val = NULL;
	gboolean _vala_success = FALSE;
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	self = (gstdPipeline*) base;
	g_return_if_fail (element != NULL);
	g_return_if_fail (property != NULL);
	_tmp0_ = element;
	_tmp1_ = property;
	_tmp3_ = gstd_pipeline_element_get_property_string_impl (self, _tmp0_, _tmp1_, &_tmp2_);
	_g_free0 (_vala_val);
	_vala_val = _tmp2_;
	_vala_success = _tmp3_;
	if (val) {
		*val = _vala_val;
	} else {
		_g_free0 (_vala_val);
	}
	if (success) {
		*success = _vala_success;
	}
}


/**
   Gets an element's string property value of a specific pipeline
   @param element, whose property value wants to be known
   @param property,property name
   @param val value of the property
 */
static gboolean gstd_pipeline_element_get_property_string_impl (gstdPipeline* self, const gchar* element, const gchar* property, gchar** val) {
	gchar* _vala_val = NULL;
	gboolean result = FALSE;
	gchar* _tmp0_;
	GstElement* _tmp1_;
	GstPipeline* _tmp2_;
	GstPipeline* pipe;
	GstPipeline* _tmp3_;
	const gchar* _tmp4_;
	GstObject* _tmp5_ = NULL;
	GstElement* e;
	GstElement* _tmp6_;
	GstElement* _tmp8_;
	GObjectClass* _tmp9_ = NULL;
	const gchar* _tmp10_;
	GParamSpec* _tmp11_ = NULL;
	GParamSpec* _tmp12_;
	GParamSpec* spec;
	GParamSpec* _tmp13_;
	GstElement* _tmp16_;
	const gchar* _tmp17_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (element != NULL, FALSE);
	g_return_val_if_fail (property != NULL, FALSE);
	_tmp0_ = g_strdup ("");
	_g_free0 (_vala_val);
	_vala_val = _tmp0_;
	_tmp1_ = self->priv->_pipeline;
	_tmp2_ = _gst_object_ref0 (GST_IS_PIPELINE (_tmp1_) ? ((GstPipeline*) _tmp1_) : NULL);
	pipe = _tmp2_;
	_tmp3_ = pipe;
	_tmp4_ = element;
	_tmp5_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) _tmp3_, _tmp4_);
	e = GST_IS_ELEMENT (_tmp5_) ? ((GstElement*) _tmp5_) : NULL;
	_tmp6_ = e;
	if (_tmp6_ == NULL) {
		const gchar* _tmp7_;
		_tmp7_ = element;
		syslog (LOG_WARNING, "Element %s not found on pipeline", _tmp7_, NULL);
		result = FALSE;
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		if (val) {
			*val = _vala_val;
		} else {
			_g_free0 (_vala_val);
		}
		return result;
	}
	_tmp8_ = e;
	_tmp9_ = G_OBJECT_GET_CLASS ((GObject*) _tmp8_);
	_tmp10_ = property;
	_tmp11_ = g_object_class_find_property (_tmp9_, _tmp10_);
	_tmp12_ = _g_param_spec_ref0 (_tmp11_);
	spec = _tmp12_;
	_tmp13_ = spec;
	if (_tmp13_ == NULL) {
		const gchar* _tmp14_;
		const gchar* _tmp15_;
		_tmp14_ = element;
		_tmp15_ = property;
		syslog (LOG_WARNING, "Element %s does not have the property %s", _tmp14_, _tmp15_, NULL);
		result = FALSE;
		_g_param_spec_unref0 (spec);
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		if (val) {
			*val = _vala_val;
		} else {
			_g_free0 (_vala_val);
		}
		return result;
	}
	_tmp16_ = e;
	_tmp17_ = property;
	g_object_get ((GObject*) _tmp16_, _tmp17_, &_vala_val, NULL, NULL);
	result = TRUE;
	_g_param_spec_unref0 (spec);
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	if (val) {
		*val = _vala_val;
	} else {
		_g_free0 (_vala_val);
	}
	return result;
}


/**
   Gets an element's state value of a specific pipeline
   @param element, whose property value wants to be known
   @param val value of the property
 */
static gint gstd_pipeline_real_element_get_state (gstdPipelineInterface* base, const gchar* element, GError** error) {
	gstdPipeline * self;
	gint result = 0;
	GstElement* _tmp0_;
	GstPipeline* _tmp1_;
	GstPipeline* pipe;
	GstPipeline* _tmp2_;
	const gchar* _tmp3_;
	GstObject* _tmp4_ = NULL;
	GstElement* e;
	GstElement* _tmp5_;
	GstState current = 0;
	GstState pending = 0;
	GstElement* _tmp10_;
	GstState _tmp11_ = 0;
	GstState _tmp12_ = 0;
	self = (gstdPipeline*) base;
	g_return_val_if_fail (element != NULL, 0);
	_tmp0_ = self->priv->_pipeline;
	_tmp1_ = _gst_object_ref0 (GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL);
	pipe = _tmp1_;
	_tmp2_ = pipe;
	_tmp3_ = element;
	_tmp4_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) _tmp2_, _tmp3_);
	e = GST_IS_ELEMENT (_tmp4_) ? ((GstElement*) _tmp4_) : NULL;
	_tmp5_ = e;
	if (_tmp5_ == NULL) {
		const gchar* _tmp6_;
		GstPipeline* _tmp7_;
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_;
		_tmp6_ = element;
		_tmp7_ = pipe;
		_tmp8_ = gst_object_get_name ((GstObject*) _tmp7_);
		_tmp9_ = _tmp8_;
		syslog (LOG_WARNING, "Element %s not found on pipeline %s", _tmp6_, _tmp9_, NULL);
		_g_free0 (_tmp9_);
		result = (gint) GST_STATE_NULL;
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		return result;
	}
	_tmp10_ = e;
	gst_element_get_state (_tmp10_, &_tmp11_, &_tmp12_, (GstClockTime) GST_CLOCK_TIME_NONE);
	current = _tmp11_;
	pending = _tmp12_;
	result = (gint) current;
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	return result;
}


static void gstd_pipeline_real_element_get_property_buffer (gstdPipelineInterface* base, const gchar* element, const gchar* property, gchar** caps, guint8** data, int* data_length1, gboolean* success, GError** error) {
	gstdPipeline * self;
	gchar* _vala_caps = NULL;
	guint8* _vala_data = NULL;
	int _vala_data_length1 = 0;
	gboolean _vala_success = FALSE;
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_ = NULL;
	guint8* _tmp3_ = NULL;
	gint _tmp4_ = 0;
	gboolean _tmp5_ = FALSE;
	self = (gstdPipeline*) base;
	g_return_if_fail (element != NULL);
	g_return_if_fail (property != NULL);
	_tmp0_ = element;
	_tmp1_ = property;
	_tmp5_ = gstd_pipeline_element_get_property_buffer_impl (self, _tmp0_, _tmp1_, &_tmp2_, &_tmp3_, &_tmp4_);
	_g_free0 (_vala_caps);
	_vala_caps = _tmp2_;
	_vala_data = (g_free (_vala_data), NULL);
	_vala_data = _tmp3_;
	_vala_data_length1 = _tmp4_;
	_vala_success = _tmp5_;
	if (caps) {
		*caps = _vala_caps;
	} else {
		_g_free0 (_vala_caps);
	}
	if (data) {
		*data = _vala_data;
	} else {
		_vala_data = (g_free (_vala_data), NULL);
	}
	if (data_length1) {
		*data_length1 = _vala_data_length1;
	}
	if (success) {
		*success = _vala_success;
	}
}


/**
   Gets an element's buffer property value of a specific pipeline
   @param element, whose property value wants to be known
   @param property,property name
   @param caps caps of buffer
   @param data data
 */
static guint8* _vala_array_dup1 (guint8* self, int length) {
	return g_memdup (self, length * sizeof (guint8));
}


static gboolean gstd_pipeline_element_get_property_buffer_impl (gstdPipeline* self, const gchar* element, const gchar* property, gchar** caps, guint8** data, int* data_length1) {
	gchar* _vala_caps = NULL;
	guint8* _vala_data = NULL;
	int _vala_data_length1 = 0;
	gboolean result = FALSE;
	gchar* _tmp0_;
	guint8* _tmp1_ = NULL;
	GstElement* _tmp2_;
	GstPipeline* _tmp3_;
	GstPipeline* pipe;
	GstPipeline* _tmp4_;
	const gchar* _tmp5_;
	GstObject* _tmp6_ = NULL;
	GstElement* e;
	GstElement* _tmp7_;
	GstElement* _tmp9_;
	GObjectClass* _tmp10_ = NULL;
	const gchar* _tmp11_;
	GParamSpec* _tmp12_ = NULL;
	GParamSpec* _tmp13_;
	GParamSpec* spec;
	GParamSpec* _tmp14_;
	GstBuffer* buffer;
	GstElement* _tmp17_;
	const gchar* _tmp18_;
	GstBuffer* _tmp19_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (element != NULL, FALSE);
	g_return_val_if_fail (property != NULL, FALSE);
	_tmp0_ = g_strdup ("");
	_g_free0 (_vala_caps);
	_vala_caps = _tmp0_;
	_tmp1_ = g_new0 (guint8, 0);
	_vala_data = (g_free (_vala_data), NULL);
	_vala_data = _tmp1_;
	_vala_data_length1 = 0;
	_tmp2_ = self->priv->_pipeline;
	_tmp3_ = _gst_object_ref0 (GST_IS_PIPELINE (_tmp2_) ? ((GstPipeline*) _tmp2_) : NULL);
	pipe = _tmp3_;
	_tmp4_ = pipe;
	_tmp5_ = element;
	_tmp6_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) _tmp4_, _tmp5_);
	e = GST_IS_ELEMENT (_tmp6_) ? ((GstElement*) _tmp6_) : NULL;
	_tmp7_ = e;
	if (_tmp7_ == NULL) {
		const gchar* _tmp8_;
		_tmp8_ = element;
		syslog (LOG_WARNING, "Element %s not found on pipeline", _tmp8_, NULL);
		result = FALSE;
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		if (caps) {
			*caps = _vala_caps;
		} else {
			_g_free0 (_vala_caps);
		}
		if (data) {
			*data = _vala_data;
		} else {
			_vala_data = (g_free (_vala_data), NULL);
		}
		if (data_length1) {
			*data_length1 = _vala_data_length1;
		}
		return result;
	}
	_tmp9_ = e;
	_tmp10_ = G_OBJECT_GET_CLASS ((GObject*) _tmp9_);
	_tmp11_ = property;
	_tmp12_ = g_object_class_find_property (_tmp10_, _tmp11_);
	_tmp13_ = _g_param_spec_ref0 (_tmp12_);
	spec = _tmp13_;
	_tmp14_ = spec;
	if (_tmp14_ == NULL) {
		const gchar* _tmp15_;
		const gchar* _tmp16_;
		_tmp15_ = element;
		_tmp16_ = property;
		syslog (LOG_WARNING, "Element %s does not have the property %s", _tmp15_, _tmp16_, NULL);
		result = FALSE;
		_g_param_spec_unref0 (spec);
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		if (caps) {
			*caps = _vala_caps;
		} else {
			_g_free0 (_vala_caps);
		}
		if (data) {
			*data = _vala_data;
		} else {
			_vala_data = (g_free (_vala_data), NULL);
		}
		if (data_length1) {
			*data_length1 = _vala_data_length1;
		}
		return result;
	}
	buffer = NULL;
	_tmp17_ = e;
	_tmp18_ = property;
	g_object_get ((GObject*) _tmp17_, _tmp18_, &buffer, NULL, NULL);
	_tmp19_ = buffer;
	if (_tmp19_ != NULL) {
		gchar* _tmp20_ = NULL;
		GstBuffer* _tmp21_;
		GstCaps* _tmp22_;
		const gchar* _tmp27_;
		gchar* _tmp28_;
		GstBuffer* _tmp29_;
		guint8* _tmp30_;
		gint _tmp30__length1;
		guint8* _tmp31_;
		gint _tmp31__length1;
		_tmp21_ = buffer;
		_tmp22_ = _tmp21_->caps;
		if (_tmp22_ != NULL) {
			GstBuffer* _tmp23_;
			GstCaps* _tmp24_;
			gchar* _tmp25_ = NULL;
			_tmp23_ = buffer;
			_tmp24_ = _tmp23_->caps;
			_tmp25_ = gst_caps_to_string (_tmp24_);
			_g_free0 (_tmp20_);
			_tmp20_ = _tmp25_;
		} else {
			gchar* _tmp26_;
			_tmp26_ = g_strdup ("");
			_g_free0 (_tmp20_);
			_tmp20_ = _tmp26_;
		}
		_tmp27_ = _tmp20_;
		_tmp28_ = g_strdup (_tmp27_);
		_g_free0 (_vala_caps);
		_vala_caps = _tmp28_;
		_tmp29_ = buffer;
		_tmp30_ = _tmp29_->data;
		_tmp30__length1 = (gint) _tmp29_->size;
		_tmp31_ = (_tmp30_ != NULL) ? _vala_array_dup1 (_tmp30_, _tmp30__length1) : ((gpointer) _tmp30_);
		_tmp31__length1 = _tmp30__length1;
		_vala_data = (g_free (_vala_data), NULL);
		_vala_data = _tmp31_;
		_vala_data_length1 = _tmp31__length1;
		_g_free0 (_tmp20_);
	}
	result = TRUE;
	_gst_buffer_unref0 (buffer);
	_g_param_spec_unref0 (spec);
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	if (caps) {
		*caps = _vala_caps;
	} else {
		_g_free0 (_vala_caps);
	}
	if (data) {
		*data = _vala_data;
	} else {
		_vala_data = (g_free (_vala_data), NULL);
	}
	if (data_length1) {
		*data_length1 = _vala_data_length1;
	}
	return result;
}


/**
   Query duration to a pipeline on the server
   @return time in milliseconds or null if not available
 */
static gint64 gstd_pipeline_real_pipeline_get_duration (gstdPipelineInterface* base, GError** error) {
	gstdPipeline * self;
	gint64 result = 0LL;
	GstFormat format;
	gint64 duration;
	GstElement* _tmp0_;
	gint64 _tmp1_ = 0LL;
	gboolean _tmp2_ = FALSE;
	gint64 _tmp3_;
	gint64 _tmp4_;
	gint64 _tmp5_;
	gint64 _tmp6_;
	gint64 _tmp7_;
	self = (gstdPipeline*) base;
	format = GST_FORMAT_TIME;
	duration = (gint64) 0;
	_tmp0_ = self->priv->_pipeline;
	_tmp2_ = gst_element_query_duration (_tmp0_, &format, &_tmp1_);
	duration = _tmp1_;
	if (!_tmp2_) {
		result = (gint64) (-1);
		return result;
	}
	_tmp3_ = duration;
	if (_tmp3_ == ((gint64) GST_CLOCK_TIME_NONE)) {
		result = (gint64) (-1);
		return result;
	}
	_tmp4_ = duration;
	_tmp5_ = duration;
	_tmp6_ = duration;
	_tmp7_ = duration;
	syslog (LOG_DEBUG, "Duration at server is %u:%02u:%02u.%03u", (guint) (_tmp4_ / ((GST_SECOND * 60) * 60)), (guint) ((_tmp5_ / (GST_SECOND * 60)) % 60), (guint) ((_tmp6_ / GST_SECOND) % 60), (guint) (_tmp7_ % GST_SECOND), NULL);
	result = duration;
	return result;
}


/**
   Query position to a pipeline on the server
   @return position in milliseconds or null if not available
 */
static gint64 gstd_pipeline_real_pipeline_get_position (gstdPipelineInterface* base, GError** error) {
	gstdPipeline * self;
	gint64 result = 0LL;
	GstFormat format;
	gint64 position;
	GstElement* _tmp0_;
	gint64 _tmp1_ = 0LL;
	gboolean _tmp2_ = FALSE;
	gint64 _tmp3_;
	gint64 _tmp4_;
	gint64 _tmp5_;
	gint64 _tmp6_;
	gint64 _tmp7_;
	self = (gstdPipeline*) base;
	format = GST_FORMAT_TIME;
	position = (gint64) 0;
	_tmp0_ = self->priv->_pipeline;
	_tmp2_ = gst_element_query_position (_tmp0_, &format, &_tmp1_);
	position = _tmp1_;
	if (!_tmp2_) {
		result = (gint64) (-1);
		return result;
	}
	_tmp3_ = position;
	if (_tmp3_ == ((gint64) GST_CLOCK_TIME_NONE)) {
		result = (gint64) (-1);
		return result;
	}
	_tmp4_ = position;
	_tmp5_ = position;
	_tmp6_ = position;
	_tmp7_ = position;
	syslog (LOG_DEBUG, "Position at server is %u:%02u:%02u.%03u", (guint) (_tmp4_ / ((GST_SECOND * 60) * 60)), (guint) ((_tmp5_ / (GST_SECOND * 60)) % 60), (guint) ((_tmp6_ / GST_SECOND) % 60), (guint) (_tmp7_ % GST_SECOND), NULL);
	result = position;
	return result;
}


static gboolean gstd_pipeline_pipeline_seek_impl (gstdPipeline* self, gint64 ipos_ns) {
	gboolean result = FALSE;
	GstElement* _tmp0_;
	gdouble _tmp1_;
	gint64 _tmp2_;
	gboolean _tmp3_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_pipeline;
	_tmp1_ = self->priv->_rate;
	_tmp2_ = ipos_ns;
	_tmp3_ = gst_element_seek (_tmp0_, _tmp1_, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH, GST_SEEK_TYPE_SET, _tmp2_, GST_SEEK_TYPE_NONE, (gint64) GST_CLOCK_TIME_NONE);
	if (!_tmp3_) {
		syslog (LOG_WARNING, "Media type not seekable", NULL);
		result = FALSE;
		return result;
	}
	result = TRUE;
	return result;
}


/**
   Seeks a specific time position.
   Data in the pipeline is flushed.
   @param ipos_ns, absolute position in nanoseconds
 */
static gboolean gstd_pipeline_real_pipeline_seek (gstdPipelineInterface* base, gint64 ipos_ns, GError** error) {
	gstdPipeline * self;
	gboolean result = FALSE;
	gint64 _tmp0_;
	gboolean _tmp1_ = FALSE;
	self = (gstdPipeline*) base;
	_tmp0_ = ipos_ns;
	_tmp1_ = gstd_pipeline_pipeline_seek_impl (self, _tmp0_);
	result = _tmp1_;
	return result;
}


/**
   Seeks a specific time position.
   Data in the pipeline is flushed.
   @param ipos_ms, absolute position in nanoseconds
 */
static void gstd_pipeline_real_pipeline_async_seek (gstdPipelineInterface* base, gint64 ipos_ns, GError** error) {
	gstdPipeline * self;
	gint64 _tmp0_;
	self = (gstdPipeline*) base;
	_tmp0_ = ipos_ns;
	gstd_pipeline_pipeline_seek_impl (self, _tmp0_);
}


/**
   Skips time, it moves position forward and backwards from
   the current position.
   Data in the pipeline is flushed.
   @param period_ms, relative time in milliseconds
 */
static gboolean gstd_pipeline_real_pipeline_skip (gstdPipelineInterface* base, gint64 period_ns, GError** error) {
	gstdPipeline * self;
	gboolean result = FALSE;
	GstFormat format;
	gint64 cur_pos_ns;
	GstElement* _tmp0_;
	gint64 _tmp1_ = 0LL;
	gboolean _tmp2_ = FALSE;
	gint64 _tmp3_;
	gint64 _tmp4_;
	gint64 seek_ns;
	GstElement* _tmp5_;
	gdouble _tmp6_;
	GstFormat _tmp7_;
	gint64 _tmp8_;
	gboolean _tmp9_ = FALSE;
	self = (gstdPipeline*) base;
	format = GST_FORMAT_TIME;
	cur_pos_ns = (gint64) 0;
	_tmp0_ = self->priv->_pipeline;
	_tmp2_ = gst_element_query_position (_tmp0_, &format, &_tmp1_);
	cur_pos_ns = _tmp1_;
	if (!_tmp2_) {
		result = FALSE;
		return result;
	}
	_tmp3_ = cur_pos_ns;
	_tmp4_ = period_ns;
	seek_ns = _tmp3_ + _tmp4_;
	_tmp5_ = self->priv->_pipeline;
	_tmp6_ = self->priv->_rate;
	_tmp7_ = format;
	_tmp8_ = seek_ns;
	_tmp9_ = gst_element_seek (_tmp5_, _tmp6_, _tmp7_, GST_SEEK_FLAG_FLUSH, GST_SEEK_TYPE_SET, _tmp8_, GST_SEEK_TYPE_NONE, (gint64) GST_CLOCK_TIME_NONE);
	if (!_tmp9_) {
		syslog (LOG_WARNING, "Media type not seekable", NULL);
		result = FALSE;
		return result;
	}
	result = TRUE;
	return result;
}


/**
   Changes pipeline speed, it enable fast|slow foward and
   fast|slow -reverse playback
   @param new_rate, values great than zero play forward, reverse
        otherwise.  Values greater than 1 (or -1 for reverse)
        play faster than normal, otherwise slower than normal.
 */
static gboolean gstd_pipeline_real_pipeline_speed (gstdPipelineInterface* base, gdouble new_rate, GError** error) {
	gstdPipeline * self;
	gboolean result = FALSE;
	gdouble _tmp0_;
	GstElement* _tmp1_;
	gdouble _tmp2_;
	gboolean _tmp3_ = FALSE;
	self = (gstdPipeline*) base;
	_tmp0_ = new_rate;
	self->priv->_rate = _tmp0_;
	_tmp1_ = self->priv->_pipeline;
	_tmp2_ = self->priv->_rate;
	_tmp3_ = gst_element_seek (_tmp1_, _tmp2_, GST_FORMAT_TIME, GST_SEEK_FLAG_SKIP | GST_SEEK_FLAG_FLUSH, GST_SEEK_TYPE_NONE, (gint64) GST_CLOCK_TIME_NONE, GST_SEEK_TYPE_NONE, (gint64) GST_CLOCK_TIME_NONE);
	if (!_tmp3_) {
		syslog (LOG_WARNING, "Speed could not be changed", NULL);
		result = FALSE;
		return result;
	}
	result = TRUE;
	return result;
}


static void gstd_pipeline_real_pipeline_send_eos (gstdPipelineInterface* base, GError** error) {
	gstdPipeline * self;
	GstElement* _tmp0_;
	GstEvent* _tmp1_;
	self = (gstdPipeline*) base;
	_tmp0_ = self->priv->_pipeline;
	_tmp1_ = gst_event_new_eos ();
	gst_element_send_event (_tmp0_, _tmp1_);
}


static void gstd_pipeline_real_pipeline_step (gstdPipelineInterface* base, guint64 frames, GError** error) {
	gstdPipeline * self;
	GstElement* _tmp0_;
	guint64 _tmp1_;
	GstEvent* _tmp2_;
	self = (gstdPipeline*) base;
	gstd_pipeline_pipeline_set_state_impl (self, GST_STATE_PAUSED);
	_tmp0_ = self->priv->_pipeline;
	_tmp1_ = frames;
	_tmp2_ = gst_event_new_step (GST_FORMAT_BUFFERS, _tmp1_, 1.0, TRUE, FALSE);
	gst_element_send_event (_tmp0_, _tmp2_);
}


static gboolean gstd_pipeline_real_pipeline_send_custom_event (gstdPipelineInterface* base, const gchar* stype, const gchar* name, GError** error) {
	gstdPipeline * self;
	gboolean result = FALSE;
	GstEventType type = 0;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	GQuark _tmp4_ = 0U;
	static GQuark _tmp3_label0 = 0;
	static GQuark _tmp3_label1 = 0;
	static GQuark _tmp3_label2 = 0;
	static GQuark _tmp3_label3 = 0;
	static GQuark _tmp3_label4 = 0;
	GstElement* _tmp5_;
	GstEventType _tmp6_;
	const gchar* _tmp7_;
	GstStructure* _tmp8_;
	GstEvent* _tmp9_;
	self = (gstdPipeline*) base;
	g_return_val_if_fail (stype != NULL, FALSE);
	g_return_val_if_fail (name != NULL, FALSE);
	_tmp0_ = stype;
	_tmp1_ = g_utf8_strdown (_tmp0_, (gssize) (-1));
	_tmp2_ = _tmp1_;
	_tmp4_ = (NULL == _tmp2_) ? 0 : g_quark_from_string (_tmp2_);
	g_free (_tmp2_);
	if (_tmp4_ == ((0 != _tmp3_label0) ? _tmp3_label0 : (_tmp3_label0 = g_quark_from_static_string ("upstream")))) {
		switch (0) {
			default:
			{
				type = GST_EVENT_CUSTOM_UPSTREAM;
				break;
			}
		}
	} else if (_tmp4_ == ((0 != _tmp3_label1) ? _tmp3_label1 : (_tmp3_label1 = g_quark_from_static_string ("downstream")))) {
		switch (0) {
			default:
			{
				type = GST_EVENT_CUSTOM_DOWNSTREAM;
				break;
			}
		}
	} else if (_tmp4_ == ((0 != _tmp3_label2) ? _tmp3_label2 : (_tmp3_label2 = g_quark_from_static_string ("downstream_oob")))) {
		switch (0) {
			default:
			{
				type = GST_EVENT_CUSTOM_DOWNSTREAM_OOB;
				break;
			}
		}
	} else if (_tmp4_ == ((0 != _tmp3_label3) ? _tmp3_label3 : (_tmp3_label3 = g_quark_from_static_string ("both")))) {
		switch (0) {
			default:
			{
				type = GST_EVENT_CUSTOM_BOTH;
				break;
			}
		}
	} else if (_tmp4_ == ((0 != _tmp3_label4) ? _tmp3_label4 : (_tmp3_label4 = g_quark_from_static_string ("both_oob")))) {
		switch (0) {
			default:
			{
				type = GST_EVENT_CUSTOM_BOTH_OOB;
				break;
			}
		}
	} else {
		switch (0) {
			default:
			{
				result = FALSE;
				return result;
			}
		}
	}
	_tmp5_ = self->priv->_pipeline;
	_tmp6_ = type;
	_tmp7_ = name;
	_tmp8_ = gst_structure_empty_new (_tmp7_);
	_tmp9_ = gst_event_new_custom (_tmp6_, _tmp8_);
	gst_element_send_event (_tmp5_, _tmp9_);
	result = TRUE;
	return result;
}


/**
   Sets an element to the specified state
   @param element, whose state is to be set
   @param state, desired element state
 */
static gboolean gstd_pipeline_real_element_set_state (gstdPipelineInterface* base, const gchar* element, gint state, GError** error) {
	gstdPipeline * self;
	gboolean result = FALSE;
	GstElement* _tmp0_;
	GstPipeline* _tmp1_;
	GstPipeline* pipe;
	GstPipeline* _tmp2_;
	const gchar* _tmp3_;
	GstObject* _tmp4_ = NULL;
	GstElement* e;
	GstElement* _tmp5_;
	GstElement* _tmp7_;
	gint _tmp8_;
	GstState current = 0;
	GstState pending = 0;
	GstElement* _tmp9_;
	GstState _tmp10_ = 0;
	GstState _tmp11_ = 0;
	GstState _tmp12_;
	gint _tmp13_;
	self = (gstdPipeline*) base;
	g_return_val_if_fail (element != NULL, FALSE);
	_tmp0_ = self->priv->_pipeline;
	_tmp1_ = _gst_object_ref0 (GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL);
	pipe = _tmp1_;
	_tmp2_ = pipe;
	_tmp3_ = element;
	_tmp4_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) _tmp2_, _tmp3_);
	e = GST_IS_ELEMENT (_tmp4_) ? ((GstElement*) _tmp4_) : NULL;
	_tmp5_ = e;
	if (_tmp5_ == NULL) {
		const gchar* _tmp6_;
		_tmp6_ = element;
		syslog (LOG_WARNING, "Element %s not found on pipeline", _tmp6_, NULL);
		result = FALSE;
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		return result;
	}
	_tmp7_ = e;
	_tmp8_ = state;
	gst_element_set_state (_tmp7_, (GstState) _tmp8_);
	_tmp9_ = e;
	gst_element_get_state (_tmp9_, &_tmp10_, &_tmp11_, (GstClockTime) GST_CLOCK_TIME_NONE);
	current = _tmp10_;
	pending = _tmp11_;
	_tmp12_ = current;
	_tmp13_ = state;
	if (_tmp12_ != _tmp13_) {
		gint _tmp14_;
		gchar* _tmp15_ = NULL;
		gchar* _tmp16_;
		_tmp14_ = state;
		_tmp15_ = g_strdup_printf ("%i", _tmp14_);
		_tmp16_ = _tmp15_;
		syslog (LOG_ERR, "Element, failed to change state %s", _tmp16_, NULL);
		_g_free0 (_tmp16_);
		result = FALSE;
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		return result;
	}
	result = TRUE;
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	return result;
}


/**
   Sets an element to the specified state, returning before the state change may have occurred
   @param element, whose state is to be set
   @param state, desired element state
 */
static void gstd_pipeline_real_element_async_set_state (gstdPipelineInterface* base, const gchar* element, gint state, GError** error) {
	gstdPipeline * self;
	GstElement* _tmp0_;
	GstPipeline* _tmp1_;
	GstPipeline* pipe;
	GstPipeline* _tmp2_;
	const gchar* _tmp3_;
	GstObject* _tmp4_ = NULL;
	GstElement* e;
	GstElement* _tmp5_;
	GstElement* _tmp7_;
	gint _tmp8_;
	self = (gstdPipeline*) base;
	g_return_if_fail (element != NULL);
	_tmp0_ = self->priv->_pipeline;
	_tmp1_ = _gst_object_ref0 (GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL);
	pipe = _tmp1_;
	_tmp2_ = pipe;
	_tmp3_ = element;
	_tmp4_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) _tmp2_, _tmp3_);
	e = GST_IS_ELEMENT (_tmp4_) ? ((GstElement*) _tmp4_) : NULL;
	_tmp5_ = e;
	if (_tmp5_ == NULL) {
		const gchar* _tmp6_;
		_tmp6_ = element;
		syslog (LOG_WARNING, "Element %s not found on pipeline", _tmp6_, NULL);
	}
	_tmp7_ = e;
	_tmp8_ = state;
	gst_element_set_state (_tmp7_, (GstState) _tmp8_);
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
}


static void gstd_pipeline_real_set_window_id (gstdPipelineInterface* base, guint64 winId, GError** error) {
	gstdPipeline * self;
	guint64 _tmp0_;
	self = (gstdPipeline*) base;
	_tmp0_ = winId;
	self->priv->_windowId = _tmp0_;
}


/**
   Ping pipeline..
   @return true if alive
 */
static gboolean gstd_pipeline_real_ping (gstdPipelineInterface* base, GError** error) {
	gstdPipeline * self;
	gboolean result = FALSE;
	self = (gstdPipeline*) base;
	result = TRUE;
	return result;
}


static void gstd_pipeline_class_init (gstdPipelineClass * klass) {
	gstd_pipeline_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (gstdPipelinePrivate));
	G_OBJECT_CLASS (klass)->finalize = gstd_pipeline_finalize;
}


static void gstd_pipeline_gstd_pipeline_interface_interface_init (gstdPipelineInterfaceIface * iface) {
	gstd_pipeline_gstd_pipeline_interface_parent_iface = g_type_interface_peek_parent (iface);
	iface->pipeline_set_state = (gboolean (*)(gstdPipelineInterface*, gint, GError**)) gstd_pipeline_real_pipeline_set_state;
	iface->pipeline_async_set_state = (void (*)(gstdPipelineInterface*, gint, GError**)) gstd_pipeline_real_pipeline_async_set_state;
	iface->pipeline_get_id = (guint64 (*)(gstdPipelineInterface*, GError**)) gstd_pipeline_real_pipeline_get_id;
	iface->pipeline_set_id = (void (*)(gstdPipelineInterface*, guint64, GError**)) gstd_pipeline_real_pipeline_set_id;
	iface->pipeline_get_state = (gint (*)(gstdPipelineInterface*, GError**)) gstd_pipeline_real_pipeline_get_state;
	iface->element_set_property_boolean = (gboolean (*)(gstdPipelineInterface*, const gchar*, const gchar*, gboolean, GError**)) gstd_pipeline_real_element_set_property_boolean;
	iface->element_set_property_int = (gboolean (*)(gstdPipelineInterface*, const gchar*, const gchar*, gint, GError**)) gstd_pipeline_real_element_set_property_int;
	iface->element_set_property_int64 = (gboolean (*)(gstdPipelineInterface*, const gchar*, const gchar*, gint64, GError**)) gstd_pipeline_real_element_set_property_int64;
	iface->element_set_property_string = (gboolean (*)(gstdPipelineInterface*, const gchar*, const gchar*, const gchar*, GError**)) gstd_pipeline_real_element_set_property_string;
	iface->element_get_property_boolean = (void (*)(gstdPipelineInterface*, const gchar*, const gchar*, gboolean*, gboolean*, GError**)) gstd_pipeline_real_element_get_property_boolean;
	iface->element_get_property_int = (void (*)(gstdPipelineInterface*, const gchar*, const gchar*, gint*, gboolean*, GError**)) gstd_pipeline_real_element_get_property_int;
	iface->element_get_property_int64 = (void (*)(gstdPipelineInterface*, const gchar*, const gchar*, gint64*, gboolean*, GError**)) gstd_pipeline_real_element_get_property_int64;
	iface->element_get_property_string = (void (*)(gstdPipelineInterface*, const gchar*, const gchar*, gchar**, gboolean*, GError**)) gstd_pipeline_real_element_get_property_string;
	iface->element_get_state = (gint (*)(gstdPipelineInterface*, const gchar*, GError**)) gstd_pipeline_real_element_get_state;
	iface->element_get_property_buffer = (void (*)(gstdPipelineInterface*, const gchar*, const gchar*, gchar**, guint8**, int*, gboolean*, GError**)) gstd_pipeline_real_element_get_property_buffer;
	iface->pipeline_get_duration = (gint64 (*)(gstdPipelineInterface*, GError**)) gstd_pipeline_real_pipeline_get_duration;
	iface->pipeline_get_position = (gint64 (*)(gstdPipelineInterface*, GError**)) gstd_pipeline_real_pipeline_get_position;
	iface->pipeline_seek = (gboolean (*)(gstdPipelineInterface*, gint64, GError**)) gstd_pipeline_real_pipeline_seek;
	iface->pipeline_async_seek = (void (*)(gstdPipelineInterface*, gint64, GError**)) gstd_pipeline_real_pipeline_async_seek;
	iface->pipeline_skip = (gboolean (*)(gstdPipelineInterface*, gint64, GError**)) gstd_pipeline_real_pipeline_skip;
	iface->pipeline_speed = (gboolean (*)(gstdPipelineInterface*, gdouble, GError**)) gstd_pipeline_real_pipeline_speed;
	iface->pipeline_send_eos = (void (*)(gstdPipelineInterface*, GError**)) gstd_pipeline_real_pipeline_send_eos;
	iface->pipeline_step = (void (*)(gstdPipelineInterface*, guint64, GError**)) gstd_pipeline_real_pipeline_step;
	iface->pipeline_send_custom_event = (gboolean (*)(gstdPipelineInterface*, const gchar*, const gchar*, GError**)) gstd_pipeline_real_pipeline_send_custom_event;
	iface->element_set_state = (gboolean (*)(gstdPipelineInterface*, const gchar*, gint, GError**)) gstd_pipeline_real_element_set_state;
	iface->element_async_set_state = (void (*)(gstdPipelineInterface*, const gchar*, gint, GError**)) gstd_pipeline_real_element_async_set_state;
	iface->set_window_id = (void (*)(gstdPipelineInterface*, guint64, GError**)) gstd_pipeline_real_set_window_id;
	iface->ping = (gboolean (*)(gstdPipelineInterface*, GError**)) gstd_pipeline_real_ping;
}


static void gstd_pipeline_instance_init (gstdPipeline * self) {
	gchar* _tmp0_;
	self->priv = GSTD_PIPELINE_GET_PRIVATE (self);
	self->priv->_id = (guint64) 0;
	self->priv->_initialized = FALSE;
	_tmp0_ = g_strdup ("");
	self->priv->_path = _tmp0_;
	self->priv->_rate = 1.0;
	self->priv->_windowId = (guint64) 0;
}


static void gstd_pipeline_finalize (GObject* obj) {
	gstdPipeline * self;
	gboolean _tmp0_;
	self = GSTD_PIPELINE (obj);
	_tmp0_ = self->priv->_initialized;
	if (_tmp0_) {
		gboolean _tmp1_ = FALSE;
		_tmp1_ = gstd_pipeline_pipeline_set_state_impl (self, GST_STATE_NULL);
		if (!_tmp1_) {
			syslog (LOG_ERR, "Failed to destroy pipeline", NULL);
		}
	}
	_gst_object_unref0 (self->priv->_pipeline);
	_g_free0 (self->priv->_path);
	G_OBJECT_CLASS (gstd_pipeline_parent_class)->finalize (obj);
}


GType gstd_pipeline_get_type (void) {
	static volatile gsize gstd_pipeline_type_id__volatile = 0;
	if (g_once_init_enter (&gstd_pipeline_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (gstdPipelineClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gstd_pipeline_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (gstdPipeline), 0, (GInstanceInitFunc) gstd_pipeline_instance_init, NULL };
		static const GInterfaceInfo gstd_pipeline_interface_info = { (GInterfaceInitFunc) gstd_pipeline_gstd_pipeline_interface_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType gstd_pipeline_type_id;
		gstd_pipeline_type_id = g_type_register_static (G_TYPE_OBJECT, "gstdPipeline", &g_define_type_info, 0);
		g_type_add_interface_static (gstd_pipeline_type_id, GSTD_TYPE_PIPELINE_INTERFACE, &gstd_pipeline_interface_info);
		g_once_init_leave (&gstd_pipeline_type_id__volatile, gstd_pipeline_type_id);
	}
	return gstd_pipeline_type_id__volatile;
}



