/* main.c generated by valac 0.12.1, the Vala compiler
 * generated from main.vala, do not modify */

/*
 * gstd/src/main.vala
 *
 * Main function for GStreamer daemon - framework for controlling audio and video streaming using D-Bus messages
 *
 * Copyright (c) 2010, RidgeRun
 * All rights reserved.
 *
 * GPL2 license - See http://www.opensource.org/licenses/gpl-2.0.php for complete text.
 */

#include <glib.h>
#include <glib-object.h>
#include <dbus/dbus-glib-lowlevel.h>
#include <dbus/dbus-glib.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <gst/gst.h>
#include <dbus/dbus.h>


#define TYPE_GSTD_SIGNALS (gstd_signals_get_type ())
#define GSTD_SIGNALS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GSTD_SIGNALS, GstdSignals))
#define GSTD_SIGNALS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GSTD_SIGNALS, GstdSignalsClass))
#define IS_GSTD_SIGNALS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GSTD_SIGNALS))
#define IS_GSTD_SIGNALS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GSTD_SIGNALS))
#define GSTD_SIGNALS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GSTD_SIGNALS, GstdSignalsClass))

typedef struct _GstdSignals GstdSignals;
typedef struct _GstdSignalsClass GstdSignalsClass;

#define TYPE_WATCHDOG (watchdog_get_type ())
#define WATCHDOG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_WATCHDOG, Watchdog))
#define WATCHDOG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_WATCHDOG, WatchdogClass))
#define IS_WATCHDOG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_WATCHDOG))
#define IS_WATCHDOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_WATCHDOG))
#define WATCHDOG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_WATCHDOG, WatchdogClass))

typedef struct _Watchdog Watchdog;
typedef struct _WatchdogClass WatchdogClass;
#define _g_option_context_free0(var) ((var == NULL) ? NULL : (var = (g_option_context_free (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_main_loop_unref0(var) ((var == NULL) ? NULL : (var = (g_main_loop_unref (var), NULL)))
#define _dbus_g_connection_unref0(var) ((var == NULL) ? NULL : (var = (dbus_g_connection_unref (var), NULL)))

#define TYPE_FACTORY (factory_get_type ())
#define FACTORY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FACTORY, Factory))
#define FACTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FACTORY, FactoryClass))
#define IS_FACTORY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FACTORY))
#define IS_FACTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FACTORY))
#define FACTORY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FACTORY, FactoryClass))

typedef struct _Factory Factory;
typedef struct _FactoryClass FactoryClass;
typedef struct _DBusObjectVTable _DBusObjectVTable;

typedef enum  {
	ERROR_GSTD_OPTION,
	ERROR_GSTD_BUS,
	ERROR_GSTD_SERVICE_OWNERSHIP
} ErrorGstd;
#define ERROR_GSTD error_gstd_quark ()
struct _DBusObjectVTable {
	void (*register_object) (DBusConnection*, const char*, void*);
};


extern GMainLoop* loop;
GMainLoop* loop = NULL;
extern DBusGConnection* conn;
DBusGConnection* conn = NULL;
extern gboolean useSystemBus;
gboolean useSystemBus = FALSE;
extern gboolean useSessionBus;
gboolean useSessionBus = FALSE;
extern gint debugLevel;
gint debugLevel = 0;
extern gint signalPollRate;
gint signalPollRate = 0;
extern gboolean enableWatchdog;
gboolean enableWatchdog = FALSE;

GQuark error_gstd_quark (void);
gint _vala_main (gchar** args, int args_length1);
GType gstd_signals_get_type (void) G_GNUC_CONST;
GType watchdog_get_type (void) G_GNUC_CONST;
static guint _dynamic_request_name0 (DBusGProxy* self, const gchar* param1, guint param2, GError** error);
Factory* factory_new (void);
Factory* factory_construct (GType object_type);
GType factory_get_type (void) G_GNUC_CONST;
static void _vala_dbus_register_object (DBusConnection* connection, const char* path, void* object);
static void _vala_dbus_unregister_object (gpointer connection, GObject* object);
GstdSignals* gstd_signals_new (GMainLoop* loop, Factory* factory, guint pollrate_ms, GError** error);
GstdSignals* gstd_signals_construct (GType object_type, GMainLoop* loop, Factory* factory, guint pollrate_ms, GError** error);
Watchdog* watchdog_new (guint timeoutInSec);
Watchdog* watchdog_construct (GType object_type, guint timeoutInSec);

const GOptionEntry options[5] = {{"system", '\0', 0, G_OPTION_ARG_NONE, &useSystemBus, "Use system bus", NULL}, {"session", '\0', 0, G_OPTION_ARG_NONE, &useSessionBus, "Use session bus", NULL}, {"debug", 'd', 0, G_OPTION_ARG_INT, &debugLevel, "Set debug level (0..3: error, warning, info, debug)", NULL}, {"signals", 's', 0, G_OPTION_ARG_INT, &signalPollRate, "Enable running thread to catch Posix signals and set poll rate in mill" \
"iseconds (--signals=1000)", NULL}, {NULL}};

GQuark error_gstd_quark (void) {
	return g_quark_from_static_string ("error_gstd-quark");
}


static guint _dynamic_request_name0 (DBusGProxy* self, const gchar* param1, guint param2, GError** error) {
	guint result;
	dbus_g_proxy_call (self, "RequestName", error, G_TYPE_STRING, param1, G_TYPE_UINT, param2, G_TYPE_INVALID, G_TYPE_UINT, &result, G_TYPE_INVALID);
	if (*error) {
		return 0U;
	}
	return result;
}


static void _vala_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
	const _DBusObjectVTable * vtable;
	vtable = g_type_get_qdata (G_TYPE_FROM_INSTANCE (object), g_quark_from_static_string ("DBusObjectVTable"));
	if (vtable) {
		vtable->register_object (connection, path, object);
	} else {
		g_warning ("Object does not implement any D-Bus interface");
	}
}


static void _vala_dbus_unregister_object (gpointer connection, GObject* object) {
	char* path;
	path = g_object_steal_data ((GObject*) object, "dbus_object_path");
	dbus_connection_unregister_object_path (connection, path);
	g_free (path);
}


gint _vala_main (gchar** args, int args_length1) {
	gint result = 0;
	GstdSignals* signal_processor;
	Watchdog* wd;
	GOptionContext* _tmp0_ = NULL;
	GOptionContext* opt;
	gboolean _tmp6_ = FALSE;
	GMainLoop* _tmp8_ = NULL;
	DBusBusType _tmp9_ = 0;
	DBusGConnection* _tmp11_ = NULL;
	DBusGConnection* _tmp12_;
	DBusGProxy* _tmp13_ = NULL;
	DBusGProxy* bus;
	guint _tmp14_;
	guint request_name_result;
	Factory* _tmp16_ = NULL;
	Factory* factory;
	GError * _inner_error_ = NULL;
	signal_processor = NULL;
	wd = NULL;
	openlog ("gstd", LOG_PID, LOG_USER);
	syslog (LOG_ERR, "Started", NULL);
	_tmp0_ = g_option_context_new ("");
	opt = _tmp0_;
	g_option_context_add_main_entries (opt, options, NULL);
	g_option_context_parse (opt, &args_length1, &args, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_OPTION_ERROR) {
			goto __catch1_g_option_error;
		}
		_g_option_context_free0 (opt);
		_g_object_unref0 (wd);
		_g_object_unref0 (signal_processor);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	goto __finally1;
	__catch1_g_option_error:
	{
		GError * e;
		GError* _tmp1_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp1_ = g_error_new (ERROR_GSTD, ERROR_GSTD_OPTION, "OptionError failure: %s", e->message);
		_inner_error_ = _tmp1_;
		_g_error_free0 (e);
		goto __finally1;
	}
	__finally1:
	if (_inner_error_ != NULL) {
		_g_option_context_free0 (opt);
		goto __catch0_g_error;
	}
	switch (debugLevel) {
		case 0:
		{
			gint _tmp2_;
			_tmp2_ = LOG_UPTO (LOG_ERR);
			setlogmask (_tmp2_);
			break;
		}
		case 1:
		{
			gint _tmp3_;
			_tmp3_ = LOG_UPTO (LOG_WARNING);
			setlogmask (_tmp3_);
			break;
		}
		case 2:
		{
			gint _tmp4_;
			_tmp4_ = LOG_UPTO (LOG_INFO);
			setlogmask (_tmp4_);
			break;
		}
		default:
		{
			gint _tmp5_;
			_tmp5_ = LOG_UPTO (LOG_DEBUG);
			setlogmask (_tmp5_);
			break;
		}
	}
	syslog (LOG_DEBUG, "Debug logging enabled", NULL);
	if (useSystemBus) {
		_tmp6_ = useSessionBus;
	} else {
		_tmp6_ = FALSE;
	}
	if (_tmp6_) {
		GError* _tmp7_ = NULL;
		_tmp7_ = g_error_new_literal (ERROR_GSTD, ERROR_GSTD_BUS, "you have to choose: system or session bus");
		_inner_error_ = _tmp7_;
		_g_option_context_free0 (opt);
		goto __catch0_g_error;
	}
	gst_init (&args_length1, &args);
	_tmp8_ = g_main_loop_new (NULL, FALSE);
	_g_main_loop_unref0 (loop);
	loop = _tmp8_;
	if (useSystemBus) {
		_tmp9_ = DBUS_BUS_SYSTEM;
	} else {
		DBusBusType _tmp10_ = 0;
		if (useSessionBus) {
			_tmp10_ = DBUS_BUS_SESSION;
		} else {
			_tmp10_ = DBUS_BUS_STARTER;
		}
		_tmp9_ = _tmp10_;
	}
	_tmp11_ = dbus_g_bus_get (_tmp9_, &_inner_error_);
	_tmp12_ = _tmp11_;
	if (_inner_error_ != NULL) {
		_g_option_context_free0 (opt);
		goto __catch0_g_error;
	}
	_dbus_g_connection_unref0 (conn);
	conn = _tmp12_;
	_tmp13_ = dbus_g_proxy_new_for_name (conn, "org.freedesktop.DBus", "/org/freedesktop/DBus", "org.freedesktop.DBus");
	bus = _tmp13_;
	_tmp14_ = _dynamic_request_name0 (bus, "com.ridgerun.gstreamer.gstd", (guint) 0, &_inner_error_);
	request_name_result = _tmp14_;
	if (_inner_error_ != NULL) {
		_g_object_unref0 (bus);
		_g_option_context_free0 (opt);
		goto __catch0_g_error;
	}
	if (request_name_result != DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER) {
		GError* _tmp15_ = NULL;
		_tmp15_ = g_error_new_literal (ERROR_GSTD, ERROR_GSTD_SERVICE_OWNERSHIP, "Failed to obtain primary ownership of " "the service. This usually means there is another instance of " "gstd already running");
		_inner_error_ = _tmp15_;
		_g_object_unref0 (bus);
		_g_option_context_free0 (opt);
		goto __catch0_g_error;
	}
	_tmp16_ = factory_new ();
	factory = _tmp16_;
	_vala_dbus_register_object (dbus_g_connection_get_connection (conn), "/com/ridgerun/gstreamer/gstd/factory", (GObject*) factory);
	if (signalPollRate > 0) {
		GstdSignals* _tmp17_ = NULL;
		GstdSignals* _tmp18_;
		_tmp17_ = gstd_signals_new (loop, factory, (guint) signalPollRate, &_inner_error_);
		_tmp18_ = _tmp17_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (factory);
			_g_object_unref0 (bus);
			_g_option_context_free0 (opt);
			goto __catch0_g_error;
		}
		_g_object_unref0 (signal_processor);
		signal_processor = _tmp18_;
	}
	if (enableWatchdog) {
		Watchdog* _tmp19_ = NULL;
		_tmp19_ = watchdog_new ((guint) 1000);
		_g_object_unref0 (wd);
		wd = _tmp19_;
	}
	g_main_loop_run (loop);
	_g_object_unref0 (factory);
	_g_object_unref0 (bus);
	_g_option_context_free0 (opt);
	goto __finally0;
	__catch0_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		syslog (LOG_ERR, "Error: %s", e->message, NULL);
		_g_error_free0 (e);
	}
	__finally0:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (wd);
		_g_object_unref0 (signal_processor);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	syslog (LOG_ERR, "Ended", NULL);
	result = 0;
	_g_object_unref0 (wd);
	_g_object_unref0 (signal_processor);
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return _vala_main (argv, argc);
}



