/* gstd-watchdog.c generated by valac 0.12.1, the Vala compiler
 * generated from gstd-watchdog.vala, do not modify */

/*
 * gstd/src/gstd-watchdog.vala
 *
 * Watchdog monitor for GStreamer daemon
 *
 * Monitor the glib mainloop with simple periodic timer to ensure that gstd
 * is able to react on DBUS requests.  Not that this does not ensure that a
 * GStreamer pipe may have gotten stuck. To handle a stuck pipeline, a
 * watchdog thread monitors all GStreamer threads by pushing 
 * GST_EVENT_SINK_MESSAGE events into each running pipe (all source elements)
 * and verifies the event arrives at each sink elements after a defined timeout.
 * GST_EVENT_SINK_MESSAGE is an event that each pipeline sink turns into a
 * message. GST_EVENT_SINK_MESSAGE is used to send messages that should be
 * emitted in sync with rendering. GST_EVENT_SINK_MESSAGE has been in GStreamer
 * since: 0.10.26.  However, at the time of this writing GstBaseTransform
 * doesn't implement forwarding GST_EVENT_SINK_MESSAGE events, which caused
 * this watchdog implementation to bark always.
 *
 * Copyright (c) 2011, RidgeRun
 * All rights reserved.
 *
 * GPL2 license - See http://www.opensource.org/licenses/gpl-2.0.php for complete text.
 */

#include <glib.h>
#include <glib-object.h>


#define TYPE_WATCHDOG (watchdog_get_type ())
#define WATCHDOG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_WATCHDOG, Watchdog))
#define WATCHDOG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_WATCHDOG, WatchdogClass))
#define IS_WATCHDOG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_WATCHDOG))
#define IS_WATCHDOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_WATCHDOG))
#define WATCHDOG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_WATCHDOG, WatchdogClass))

typedef struct _Watchdog Watchdog;
typedef struct _WatchdogClass WatchdogClass;
typedef struct _WatchdogPrivate WatchdogPrivate;

struct _Watchdog {
	GObject parent_instance;
	WatchdogPrivate * priv;
};

struct _WatchdogClass {
	GObjectClass parent_class;
};


static gpointer watchdog_parent_class = NULL;

GType watchdog_get_type (void) G_GNUC_CONST;
enum  {
	WATCHDOG_DUMMY_PROPERTY
};
Watchdog* watchdog_new (guint timeoutInSec);
Watchdog* watchdog_construct (GType object_type, guint timeoutInSec);
static void watchdog_finalize (GObject* obj);


Watchdog* watchdog_construct (GType object_type, guint timeoutInSec) {
	Watchdog * self = NULL;
	self = (Watchdog*) g_object_new (object_type, NULL);
	return self;
}


Watchdog* watchdog_new (guint timeoutInSec) {
	return watchdog_construct (TYPE_WATCHDOG, timeoutInSec);
}


static void watchdog_class_init (WatchdogClass * klass) {
	watchdog_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = watchdog_finalize;
}


static void watchdog_instance_init (Watchdog * self) {
}


static void watchdog_finalize (GObject* obj) {
	Watchdog * self;
	self = WATCHDOG (obj);
	G_OBJECT_CLASS (watchdog_parent_class)->finalize (obj);
}


GType watchdog_get_type (void) {
	static volatile gsize watchdog_type_id__volatile = 0;
	if (g_once_init_enter (&watchdog_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (WatchdogClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) watchdog_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Watchdog), 0, (GInstanceInitFunc) watchdog_instance_init, NULL };
		GType watchdog_type_id;
		watchdog_type_id = g_type_register_static (G_TYPE_OBJECT, "Watchdog", &g_define_type_info, 0);
		g_once_init_leave (&watchdog_type_id__volatile, watchdog_type_id);
	}
	return watchdog_type_id__volatile;
}



