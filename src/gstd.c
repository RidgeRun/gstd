/* gstd.c generated by valac, the Vala compiler
 * generated from gstd.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gst/gst.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <dbus/dbus.h>
#include <dbus/dbus-glib.h>
#include <dbus/dbus-glib-lowlevel.h>


#define TYPE_HARRIER (harrier_get_type ())
#define HARRIER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_HARRIER, Harrier))
#define HARRIER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_HARRIER, HarrierClass))
#define IS_HARRIER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_HARRIER))
#define IS_HARRIER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_HARRIER))
#define HARRIER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_HARRIER, HarrierClass))

typedef struct _Harrier Harrier;
typedef struct _HarrierClass HarrierClass;
typedef struct _HarrierPrivate HarrierPrivate;
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _gst_object_unref0(var) ((var == NULL) ? NULL : (var = (gst_object_unref (var), NULL)))
typedef struct _DBusObjectVTable _DBusObjectVTable;

struct _Harrier {
	GObject parent_instance;
	HarrierPrivate * priv;
};

struct _HarrierClass {
	GObjectClass parent_class;
};

struct _HarrierPrivate {
	GHashTable* pipelines;
	gint next_id;
	gint ids_available;
	gint* ids;
	gint ids_length1;
	gint ids_size;
};

struct _DBusObjectVTable {
	void (*register_object) (DBusConnection*, const char*, void*);
};


extern GMainLoop* loop;
static gpointer harrier_parent_class = NULL;

GType harrier_get_type (void);
#define HARRIER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_HARRIER, HarrierPrivate))
enum  {
	HARRIER_DUMMY_PROPERTY
};
Harrier* harrier_new (void);
Harrier* harrier_construct (GType object_type);
static gboolean harrier_bus_callback (Harrier* self, GstBus* bus, GstMessage* message);
static gboolean _harrier_bus_callback_gst_bus_func (GstBus* bus, GstMessage* message, gpointer self);
gint harrier_PipelineCreate (Harrier* self, const char* description);
static gboolean harrier_PipelineSetState (Harrier* self, gint id, GstState state);
gboolean harrier_PipelineDestroy (Harrier* self, gint id);
gboolean harrier_PipelinePlay (Harrier* self, gint id);
gboolean harrier_PipelinePause (Harrier* self, gint id);
gboolean harrier_PipelineNull (Harrier* self, gint id);
gboolean harrier_ElementSetPropertyBoolean (Harrier* self, gint id, const char* element, const char* property, gboolean val);
gboolean harrier_ElementSetPropertyInt (Harrier* self, gint id, const char* element, const char* property, gint val);
gboolean harrier_ElementSetPropertyLong (Harrier* self, gint id, const char* element, const char* property, glong val);
gboolean harrier_ElementSetPropertyString (Harrier* self, gint id, const char* element, const char* property, const char* val);
gboolean harrier_ElementGetPropertyBoolean (Harrier* self, gint id, const char* element, const char* property);
gint harrier_ElementGetPropertyInt (Harrier* self, gint id, const char* element, const char* property);
glong harrier_ElementGetPropertyLong (Harrier* self, gint id, const char* element, const char* property);
char* harrier_ElementGetPropertyString (Harrier* self, gint id, const char* element, const char* property);
gint64 harrier_PipelineGetDuration (Harrier* self, gint id);
gint64 harrier_PipelineGetPosition (Harrier* self, gint id);
void harrier_dbus_register_object (DBusConnection* connection, const char* path, void* object);
void _harrier_dbus_unregister (DBusConnection* connection, void* _user_data_);
DBusHandlerResult harrier_dbus_message (DBusConnection* connection, DBusMessage* message, void* object);
static DBusHandlerResult _dbus_harrier_introspect (Harrier* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_harrier_property_get_all (Harrier* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_harrier_PipelineCreate (Harrier* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_harrier_PipelineDestroy (Harrier* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_harrier_PipelinePlay (Harrier* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_harrier_PipelinePause (Harrier* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_harrier_PipelineNull (Harrier* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_harrier_ElementSetPropertyBoolean (Harrier* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_harrier_ElementSetPropertyInt (Harrier* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_harrier_ElementSetPropertyLong (Harrier* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_harrier_ElementSetPropertyString (Harrier* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_harrier_ElementGetPropertyBoolean (Harrier* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_harrier_ElementGetPropertyInt (Harrier* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_harrier_ElementGetPropertyLong (Harrier* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_harrier_ElementGetPropertyString (Harrier* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_harrier_PipelineGetDuration (Harrier* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_harrier_PipelineGetPosition (Harrier* self, DBusConnection* connection, DBusMessage* message);
static void _dbus_harrier_eos (GObject* _sender, DBusConnection* _connection);
static void _dbus_harrier_state_changed (GObject* _sender, const char* new_state, DBusConnection* _connection);
static void _dbus_harrier_error (GObject* _sender, const char* err_message, DBusConnection* _connection);
static void harrier_finalize (GObject* obj);
static void _vala_dbus_register_object (DBusConnection* connection, const char* path, void* object);
static void _vala_dbus_unregister_object (gpointer connection, GObject* object);

static const DBusObjectPathVTable _harrier_dbus_path_vtable = {_harrier_dbus_unregister, harrier_dbus_message};
static const _DBusObjectVTable _harrier_dbus_vtable = {harrier_dbus_register_object};


Harrier* harrier_construct (GType object_type) {
	Harrier * self;
	gint i = 0;
	GHashTable* _tmp0_;
	gint* _tmp1_;
	self = (Harrier*) g_object_new (object_type, NULL);
	self->priv->pipelines = (_tmp0_ = g_hash_table_new (g_int_hash, g_int_equal), _g_hash_table_unref0 (self->priv->pipelines), _tmp0_);
	self->priv->next_id = 0;
	self->priv->ids = (_tmp1_ = g_new0 (gint, 20), self->priv->ids = (g_free (self->priv->ids), NULL), self->priv->ids_length1 = 20, self->priv->ids_size = self->priv->ids_length1, _tmp1_);
	self->priv->ids_available = 20;
	{
		gboolean _tmp2_;
		i = 0;
		_tmp2_ = TRUE;
		while (TRUE) {
			if (!_tmp2_) {
				i++;
			}
			_tmp2_ = FALSE;
			if (!(i < 20)) {
				break;
			}
			self->priv->ids[i] = i;
		}
	}
	return self;
}


Harrier* harrier_new (void) {
	return harrier_construct (TYPE_HARRIER);
}


static gboolean harrier_bus_callback (Harrier* self, GstBus* bus, GstMessage* message) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (bus != NULL, FALSE);
	g_return_val_if_fail (message != NULL, FALSE);
	switch (message->type) {
		case GST_MESSAGE_ERROR:
		{
			GError* err;
			char* debug;
			char* _tmp3_;
			char* _tmp2_ = NULL;
			GError* _tmp1_;
			GError* _tmp0_ = NULL;
			err = NULL;
			debug = NULL;
			(gst_message_parse_error (message, &_tmp0_, &_tmp2_), err = (_tmp1_ = _tmp0_, _g_error_free0 (err), _tmp1_));
			debug = (_tmp3_ = _tmp2_, _g_free0 (debug), _tmp3_);
			g_signal_emit_by_name (self, "error", err->message);
			g_main_loop_quit (loop);
			_g_error_free0 (err);
			_g_free0 (debug);
			break;
		}
		case GST_MESSAGE_EOS:
		{
			g_signal_emit_by_name (self, "eos");
			break;
		}
		case GST_MESSAGE_STATE_CHANGED:
		{
			GstState oldstate = 0;
			GstState newstate = 0;
			GstState pending = 0;
			gst_message_parse_state_changed (message, &oldstate, &newstate, &pending);
			g_signal_emit_by_name (self, "state-changed", gst_element_state_get_name (newstate));
			break;
		}
		default:
		{
			break;
		}
	}
	result = TRUE;
	return result;
}


static gboolean _harrier_bus_callback_gst_bus_func (GstBus* bus, GstMessage* message, gpointer self) {
	return harrier_bus_callback (self, bus, message);
}


gint harrier_PipelineCreate (Harrier* self, const char* description) {
	gint result;
	GError * _inner_error_;
	gint ret;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (description != NULL, 0);
	_inner_error_ = NULL;
	ret = -1;
	if (self->priv->ids_available <= 0) {
		fprintf (stderr, "Failed to create pipeline, no more ids available");
		result = -1;
		return result;
	}
	{
		GstElement* _tmp0_;
		GstElement* _tmp1_;
		GstElement* newpipe;
		GstBus* bus;
		_tmp0_ = gst_parse_launch (description, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch1_g_error;
			goto __finally1;
		}
		newpipe = (_tmp1_ = _tmp0_, GST_IS_ELEMENT (_tmp1_) ? ((GstElement*) _tmp1_) : NULL);
		g_assert (newpipe != NULL);
		bus = gst_element_get_bus (newpipe);
		gst_bus_add_watch (bus, _harrier_bus_callback_gst_bus_func, self);
		((GObject*) newpipe)->ref_count++;
		while (TRUE) {
			if (!(g_hash_table_lookup (self->priv->pipelines, &self->priv->next_id) != NULL)) {
				break;
			}
			self->priv->next_id = (self->priv->next_id++) % 20;
		}
		g_hash_table_insert (self->priv->pipelines, &self->priv->ids[self->priv->next_id], newpipe);
		ret = self->priv->next_id;
		self->priv->next_id++;
		self->priv->ids_available--;
		fprintf (stdout, "Pipeline %d created: %s\n", ret, description);
		_gst_object_unref0 (newpipe);
		_gst_object_unref0 (bus);
	}
	goto __finally1;
	__catch1_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			fprintf (stderr, "Failed to create pipeline with description: %s.\n" "Error: %s\n", description, e->message);
			_g_error_free0 (e);
		}
	}
	__finally1:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
		g_clear_error (&_inner_error_);
		return 0;
	}
	result = ret;
	return result;
}


static gpointer _gst_object_ref0 (gpointer self) {
	return self ? gst_object_ref (self) : NULL;
}


gboolean harrier_PipelineDestroy (Harrier* self, gint id) {
	gboolean result;
	GObject* o = NULL;
	gpointer _tmp0_;
	GstElement* pipe;
	g_return_val_if_fail (self != NULL, FALSE);
	pipe = _gst_object_ref0 ((_tmp0_ = g_hash_table_lookup (self->priv->pipelines, &id), GST_IS_ELEMENT (_tmp0_) ? ((GstElement*) _tmp0_) : NULL));
	if (pipe == NULL) {
		fprintf (stdout, "Pipe not found by id %d\n", id);
		result = FALSE;
		_gst_object_unref0 (pipe);
		return result;
	}
	if (!harrier_PipelineSetState (self, id, GST_STATE_NULL)) {
		result = FALSE;
		_gst_object_unref0 (pipe);
		return result;
	}
	g_hash_table_remove (self->priv->pipelines, &id);
	o = G_OBJECT (pipe);
	g_object_unref (o);
	result = TRUE;
	_gst_object_unref0 (pipe);
	return result;
}


static gboolean harrier_PipelineSetState (Harrier* self, gint id, GstState state) {
	gboolean result;
	gpointer _tmp0_;
	GstElement* pipe;
	GstState current = 0;
	GstState pending = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	pipe = _gst_object_ref0 ((_tmp0_ = g_hash_table_lookup (self->priv->pipelines, &id), GST_IS_ELEMENT (_tmp0_) ? ((GstElement*) _tmp0_) : NULL));
	if (pipe == NULL) {
		fprintf (stdout, "Pipe not found by id %d\n", id);
		result = FALSE;
		_gst_object_unref0 (pipe);
		return result;
	}
	gst_element_set_state (pipe, state);
	gst_element_get_state (pipe, &current, &pending, (GstClockTime) 2000000000);
	if (current != state) {
		fprintf (stderr, "Element %d, failed to change state %s\n", id, gst_element_state_get_name (state));
		result = FALSE;
		_gst_object_unref0 (pipe);
		return result;
	}
	result = TRUE;
	_gst_object_unref0 (pipe);
	return result;
}


gboolean harrier_PipelinePlay (Harrier* self, gint id) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = harrier_PipelineSetState (self, id, GST_STATE_PLAYING);
	return result;
}


gboolean harrier_PipelinePause (Harrier* self, gint id) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = harrier_PipelineSetState (self, id, GST_STATE_PAUSED);
	return result;
}


gboolean harrier_PipelineNull (Harrier* self, gint id) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = harrier_PipelineSetState (self, id, GST_STATE_NULL);
	return result;
}


gboolean harrier_ElementSetPropertyBoolean (Harrier* self, gint id, const char* element, const char* property, gboolean val) {
	gboolean result;
	GstElement* e;
	gpointer _tmp0_;
	GstPipeline* pipe;
	GstElement* _tmp2_;
	GstObject* _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (element != NULL, FALSE);
	g_return_val_if_fail (property != NULL, FALSE);
	e = NULL;
	pipe = _gst_object_ref0 ((_tmp0_ = g_hash_table_lookup (self->priv->pipelines, &id), GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL));
	if (pipe == NULL) {
		fprintf (stderr, "Pipe not found by id %d\n", id);
		result = FALSE;
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		return result;
	}
	e = (_tmp2_ = _gst_object_ref0 ((_tmp1_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) pipe, element), GST_IS_ELEMENT (_tmp1_) ? ((GstElement*) _tmp1_) : NULL)), _gst_object_unref0 (e), _tmp2_);
	if (e == NULL) {
		fprintf (stderr, "Element %s not found on pipe id %d", element, id);
		result = FALSE;
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		return result;
	}
	g_object_set ((GObject*) e, property, val, NULL, NULL);
	result = TRUE;
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	return result;
}


gboolean harrier_ElementSetPropertyInt (Harrier* self, gint id, const char* element, const char* property, gint val) {
	gboolean result;
	GstElement* e;
	gpointer _tmp0_;
	GstPipeline* pipe;
	GstElement* _tmp2_;
	GstObject* _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (element != NULL, FALSE);
	g_return_val_if_fail (property != NULL, FALSE);
	e = NULL;
	pipe = _gst_object_ref0 ((_tmp0_ = g_hash_table_lookup (self->priv->pipelines, &id), GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL));
	if (pipe == NULL) {
		fprintf (stderr, "Pipe not found by id %d\n", id);
		result = FALSE;
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		return result;
	}
	e = (_tmp2_ = _gst_object_ref0 ((_tmp1_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) pipe, element), GST_IS_ELEMENT (_tmp1_) ? ((GstElement*) _tmp1_) : NULL)), _gst_object_unref0 (e), _tmp2_);
	if (e == NULL) {
		fprintf (stderr, "Element %s not found on pipe id %d\n", element, id);
		result = FALSE;
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		return result;
	}
	g_object_set ((GObject*) e, property, val, NULL, NULL);
	result = TRUE;
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	return result;
}


gboolean harrier_ElementSetPropertyLong (Harrier* self, gint id, const char* element, const char* property, glong val) {
	gboolean result;
	GstElement* e;
	gpointer _tmp0_;
	GstPipeline* pipe;
	GstElement* _tmp2_;
	GstObject* _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (element != NULL, FALSE);
	g_return_val_if_fail (property != NULL, FALSE);
	e = NULL;
	pipe = _gst_object_ref0 ((_tmp0_ = g_hash_table_lookup (self->priv->pipelines, &id), GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL));
	if (pipe == NULL) {
		fprintf (stderr, "Pipe not found by id %d\n", id);
		result = FALSE;
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		return result;
	}
	e = (_tmp2_ = _gst_object_ref0 ((_tmp1_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) pipe, element), GST_IS_ELEMENT (_tmp1_) ? ((GstElement*) _tmp1_) : NULL)), _gst_object_unref0 (e), _tmp2_);
	if (e == NULL) {
		fprintf (stderr, "Element %s not found on pipe id %d", element, id);
		result = FALSE;
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		return result;
	}
	g_object_set ((GObject*) e, property, val, NULL, NULL);
	result = TRUE;
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	return result;
}


gboolean harrier_ElementSetPropertyString (Harrier* self, gint id, const char* element, const char* property, const char* val) {
	gboolean result;
	GstElement* e;
	gpointer _tmp0_;
	GstPipeline* pipe;
	GstElement* _tmp2_;
	GstObject* _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (element != NULL, FALSE);
	g_return_val_if_fail (property != NULL, FALSE);
	g_return_val_if_fail (val != NULL, FALSE);
	e = NULL;
	pipe = _gst_object_ref0 ((_tmp0_ = g_hash_table_lookup (self->priv->pipelines, &id), GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL));
	if (pipe == NULL) {
		fprintf (stderr, "Pipe not found by id %d\n", id);
		result = FALSE;
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		return result;
	}
	e = (_tmp2_ = _gst_object_ref0 ((_tmp1_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) pipe, element), GST_IS_ELEMENT (_tmp1_) ? ((GstElement*) _tmp1_) : NULL)), _gst_object_unref0 (e), _tmp2_);
	if (e == NULL) {
		fprintf (stderr, "Element %s not found on pipe id %d", element, id);
		result = FALSE;
		_gst_object_unref0 (e);
		_gst_object_unref0 (pipe);
		return result;
	}
	g_object_set ((GObject*) e, property, val, NULL, NULL);
	result = TRUE;
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	return result;
}


gboolean harrier_ElementGetPropertyBoolean (Harrier* self, gint id, const char* element, const char* property) {
	gboolean result;
	GstElement* e;
	gboolean bool_v;
	gpointer _tmp0_;
	GstPipeline* pipe;
	GstElement* _tmp2_;
	GstObject* _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (element != NULL, FALSE);
	g_return_val_if_fail (property != NULL, FALSE);
	e = NULL;
	bool_v = FALSE;
	pipe = _gst_object_ref0 ((_tmp0_ = g_hash_table_lookup (self->priv->pipelines, &id), GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL));
	if (pipe == NULL) {
		fprintf (stderr, "Pipe not found by id %d\n", id);
	}
	e = (_tmp2_ = _gst_object_ref0 ((_tmp1_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) pipe, element), GST_IS_ELEMENT (_tmp1_) ? ((GstElement*) _tmp1_) : NULL)), _gst_object_unref0 (e), _tmp2_);
	if (e == NULL) {
		fprintf (stderr, "Element %s not found on pipe id %d", element, id);
	}
	g_object_get ((GObject*) e, property, &bool_v, NULL, NULL);
	result = bool_v;
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	return result;
}


gint harrier_ElementGetPropertyInt (Harrier* self, gint id, const char* element, const char* property) {
	gint result;
	GstElement* e;
	gint integer_v;
	gpointer _tmp0_;
	GstPipeline* pipe;
	GstElement* _tmp2_;
	GstObject* _tmp1_;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (element != NULL, 0);
	g_return_val_if_fail (property != NULL, 0);
	e = NULL;
	integer_v = -1;
	pipe = _gst_object_ref0 ((_tmp0_ = g_hash_table_lookup (self->priv->pipelines, &id), GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL));
	if (pipe == NULL) {
		fprintf (stderr, "Pipe not found by id %d\n", id);
	}
	e = (_tmp2_ = _gst_object_ref0 ((_tmp1_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) pipe, element), GST_IS_ELEMENT (_tmp1_) ? ((GstElement*) _tmp1_) : NULL)), _gst_object_unref0 (e), _tmp2_);
	if (e == NULL) {
		fprintf (stderr, "Element %s not found on pipe id %d", element, id);
	}
	g_object_get ((GObject*) e, property, &integer_v, NULL, NULL);
	result = integer_v;
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	return result;
}


glong harrier_ElementGetPropertyLong (Harrier* self, gint id, const char* element, const char* property) {
	glong result;
	GstElement* e;
	glong long_v;
	gpointer _tmp0_;
	GstPipeline* pipe;
	GstElement* _tmp2_;
	GstObject* _tmp1_;
	g_return_val_if_fail (self != NULL, 0L);
	g_return_val_if_fail (element != NULL, 0L);
	g_return_val_if_fail (property != NULL, 0L);
	e = NULL;
	long_v = (glong) (-1);
	pipe = _gst_object_ref0 ((_tmp0_ = g_hash_table_lookup (self->priv->pipelines, &id), GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL));
	if (pipe == NULL) {
		fprintf (stderr, "Pipe not found by id %d\n", id);
	}
	e = (_tmp2_ = _gst_object_ref0 ((_tmp1_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) pipe, element), GST_IS_ELEMENT (_tmp1_) ? ((GstElement*) _tmp1_) : NULL)), _gst_object_unref0 (e), _tmp2_);
	if (e == NULL) {
		fprintf (stderr, "Element %s not found on pipe id %d", element, id);
	}
	g_object_get ((GObject*) e, property, &long_v, NULL, NULL);
	result = long_v;
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	return result;
}


char* harrier_ElementGetPropertyString (Harrier* self, gint id, const char* element, const char* property) {
	char* result;
	GstElement* e;
	char* string_v;
	gpointer _tmp0_;
	GstPipeline* pipe;
	GstElement* _tmp2_;
	GstObject* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (element != NULL, NULL);
	g_return_val_if_fail (property != NULL, NULL);
	e = NULL;
	string_v = g_strdup ("");
	pipe = _gst_object_ref0 ((_tmp0_ = g_hash_table_lookup (self->priv->pipelines, &id), GST_IS_PIPELINE (_tmp0_) ? ((GstPipeline*) _tmp0_) : NULL));
	if (pipe == NULL) {
		fprintf (stderr, "Pipe not found by id %d\n", id);
	}
	e = (_tmp2_ = _gst_object_ref0 ((_tmp1_ = gst_child_proxy_get_child_by_name ((GstChildProxy*) pipe, element), GST_IS_ELEMENT (_tmp1_) ? ((GstElement*) _tmp1_) : NULL)), _gst_object_unref0 (e), _tmp2_);
	if (e == NULL) {
		fprintf (stderr, "Element %s not found on pipe id %d", element, id);
	}
	g_object_get ((GObject*) e, property, &string_v, NULL, NULL);
	result = string_v;
	_gst_object_unref0 (e);
	_gst_object_unref0 (pipe);
	return result;
}


gint64 harrier_PipelineGetDuration (Harrier* self, gint id) {
	gint64 result;
	GstFormat format;
	gint64 duration = 0LL;
	gpointer _tmp0_;
	GstElement* pipe;
	g_return_val_if_fail (self != NULL, 0LL);
	format = GST_FORMAT_TIME;
	pipe = _gst_object_ref0 ((_tmp0_ = g_hash_table_lookup (self->priv->pipelines, &id), GST_IS_ELEMENT (_tmp0_) ? ((GstElement*) _tmp0_) : NULL));
	if (pipe == NULL) {
		fprintf (stdout, "Pipe not found by id %d\n", id);
		result = (gint64) (-1);
		_gst_object_unref0 (pipe);
		return result;
	}
	if (!gst_element_query_duration (pipe, &format, &duration)) {
		result = (gint64) (-1);
		_gst_object_unref0 (pipe);
		return result;
	}
	result = duration;
	_gst_object_unref0 (pipe);
	return result;
}


gint64 harrier_PipelineGetPosition (Harrier* self, gint id) {
	gint64 result;
	GstFormat format;
	gint64 position = 0LL;
	gpointer _tmp0_;
	GstElement* pipe;
	g_return_val_if_fail (self != NULL, 0LL);
	format = GST_FORMAT_TIME;
	pipe = _gst_object_ref0 ((_tmp0_ = g_hash_table_lookup (self->priv->pipelines, &id), GST_IS_ELEMENT (_tmp0_) ? ((GstElement*) _tmp0_) : NULL));
	if (pipe == NULL) {
		fprintf (stdout, "Pipe not found by id %d\n", id);
		result = (gint64) (-1);
		_gst_object_unref0 (pipe);
		return result;
	}
	if (!gst_element_query_position (pipe, &format, &position)) {
		result = (gint64) (-1);
		_gst_object_unref0 (pipe);
		return result;
	}
	result = position;
	_gst_object_unref0 (pipe);
	return result;
}


void _harrier_dbus_unregister (DBusConnection* connection, void* _user_data_) {
}


static DBusHandlerResult _dbus_harrier_introspect (Harrier* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter;
	GString* xml_data;
	char** children;
	int i;
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	xml_data = g_string_new ("<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\" \"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n");
	g_string_append (xml_data, "<node>\n<interface name=\"org.freedesktop.DBus.Introspectable\">\n  <method name=\"Introspect\">\n    <arg name=\"data\" direction=\"out\" type=\"s\"/>\n  </method>\n</interface>\n<interface name=\"org.freedesktop.DBus.Properties\">\n  <method name=\"Get\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"out\" type=\"v\"/>\n  </method>\n  <method name=\"Set\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"in\" type=\"v\"/>\n  </method>\n  <method name=\"GetAll\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"props\" direction=\"out\" type=\"a{sv}\"/>\n  </method>\n</interface>\n<interface name=\"com.ti.sdo.HarrierInterface\">\n  <method name=\"PipelineCreate\">\n    <arg name=\"description\" type=\"s\" direction=\"in\"/>\n    <arg name=\"result\" type=\"i\" direction=\"out\"/>\n  </method>\n  <method name=\"PipelineDestroy\">\n    <arg name=\"id\" type=\"i\" direction=\"in\"/>\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"PipelinePlay\">\n    <arg name=\"id\" type=\"i\" direction=\"in\"/>\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"PipelinePause\">\n    <arg name=\"id\" type=\"i\" direction=\"in\"/>\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"PipelineNull\">\n    <arg name=\"id\" type=\"i\" direction=\"in\"/>\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"ElementSetPropertyBoolean\">\n    <arg name=\"id\" type=\"i\" direction=\"in\"/>\n    <arg name=\"element\" type=\"s\" direction=\"in\"/>\n    <arg name=\"property\" type=\"s\" direction=\"in\"/>\n    <arg name=\"val\" type=\"b\" direction=\"in\"/>\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"ElementSetPropertyInt\">\n    <arg name=\"id\" type=\"i\" direction=\"in\"/>\n    <arg name=\"element\" type=\"s\" direction=\"in\"/>\n    <arg name=\"property\" type=\"s\" direction=\"in\"/>\n    <arg name=\"val\" type=\"i\" direction=\"in\"/>\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"ElementSetPropertyLong\">\n    <arg name=\"id\" type=\"i\" direction=\"in\"/>\n    <arg name=\"element\" type=\"s\" direction=\"in\"/>\n    <arg name=\"property\" type=\"s\" direction=\"in\"/>\n    <arg name=\"val\" type=\"()\" direction=\"in\"/>\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"ElementSetPropertyString\">\n    <arg name=\"id\" type=\"i\" direction=\"in\"/>\n    <arg name=\"element\" type=\"s\" direction=\"in\"/>\n    <arg name=\"property\" type=\"s\" direction=\"in\"/>\n    <arg name=\"val\" type=\"s\" direction=\"in\"/>\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"ElementGetPropertyBoolean\">\n    <arg name=\"id\" type=\"i\" direction=\"in\"/>\n    <arg name=\"element\" type=\"s\" direction=\"in\"/>\n    <arg name=\"property\" type=\"s\" direction=\"in\"/>\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"ElementGetPropertyInt\">\n    <arg name=\"id\" type=\"i\" direction=\"in\"/>\n    <arg name=\"element\" type=\"s\" direction=\"in\"/>\n    <arg name=\"property\" type=\"s\" direction=\"in\"/>\n    <arg name=\"result\" type=\"i\" direction=\"out\"/>\n  </method>\n  <method name=\"ElementGetPropertyLong\">\n    <arg name=\"id\" type=\"i\" direction=\"in\"/>\n    <arg name=\"element\" type=\"s\" direction=\"in\"/>\n    <arg name=\"property\" type=\"s\" direction=\"in\"/>\n    <arg name=\"result\" type=\"()\" direction=\"out\"/>\n  </method>\n  <method name=\"ElementGetPropertyString\">\n    <arg name=\"id\" type=\"i\" direction=\"in\"/>\n    <arg name=\"element\" type=\"s\" direction=\"in\"/>\n    <arg name=\"property\" type=\"s\" direction=\"in\"/>\n    <arg name=\"result\" type=\"s\" direction=\"out\"/>\n  </method>\n  <method name=\"PipelineGetDuration\">\n    <arg name=\"id\" type=\"i\" direction=\"in\"/>\n    <arg name=\"result\" type=\"x\" direction=\"out\"/>\n  </method>\n  <method name=\"PipelineGetPosition\">\n    <arg name=\"id\" type=\"i\" direction=\"in\"/>\n    <arg name=\"result\" type=\"x\" direction=\"out\"/>\n  </method>\n  <signal name=\"Eos\">\n  </signal>\n  <signal name=\"StateChanged\">\n    <arg name=\"new_state\" type=\"s\"/>\n  </signal>\n  <signal name=\"Error\">\n    <arg name=\"err_message\" type=\"s\"/>\n  </signal>\n</interface>\n");
	dbus_connection_list_registered (connection, g_object_get_data ((GObject *) self, "dbus_object_path"), &children);
	for (i = 0; children[i]; i++) {
		g_string_append_printf (xml_data, "<node name=\"%s\"/>\n", children[i]);
	}
	dbus_free_string_array (children);
	g_string_append (xml_data, "</node>\n");
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &xml_data->str);
	g_string_free (xml_data, TRUE);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_harrier_property_get_all (Harrier* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter, reply_iter, subiter;
	char* interface_name;
	const char* _tmp0_;
	if (strcmp (dbus_message_get_signature (message), "s")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &reply_iter);
	dbus_message_iter_get_basic (&iter, &_tmp0_);
	dbus_message_iter_next (&iter);
	interface_name = g_strdup (_tmp0_);
	if (strcmp (interface_name, "com.ti.sdo.HarrierInterface") == 0) {
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_ARRAY, "{sv}", &subiter);
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else {
		dbus_message_unref (reply);
		reply = NULL;
	}
	g_free (interface_name);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_harrier_PipelineCreate (Harrier* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	char* description = NULL;
	const char* _tmp1_;
	gint result;
	DBusMessage* reply;
	dbus_int32_t _tmp2_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "s")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp1_);
	dbus_message_iter_next (&iter);
	description = g_strdup (_tmp1_);
	result = harrier_PipelineCreate (self, description);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (description);
	_tmp2_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_INT32, &_tmp2_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_harrier_PipelineDestroy (Harrier* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gint id = 0;
	dbus_int32_t _tmp3_;
	gboolean result;
	DBusMessage* reply;
	dbus_bool_t _tmp4_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "i")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp3_);
	dbus_message_iter_next (&iter);
	id = _tmp3_;
	result = harrier_PipelineDestroy (self, id);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_tmp4_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp4_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_harrier_PipelinePlay (Harrier* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gint id = 0;
	dbus_int32_t _tmp5_;
	gboolean result;
	DBusMessage* reply;
	dbus_bool_t _tmp6_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "i")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp5_);
	dbus_message_iter_next (&iter);
	id = _tmp5_;
	result = harrier_PipelinePlay (self, id);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_tmp6_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp6_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_harrier_PipelinePause (Harrier* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gint id = 0;
	dbus_int32_t _tmp7_;
	gboolean result;
	DBusMessage* reply;
	dbus_bool_t _tmp8_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "i")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp7_);
	dbus_message_iter_next (&iter);
	id = _tmp7_;
	result = harrier_PipelinePause (self, id);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_tmp8_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp8_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_harrier_PipelineNull (Harrier* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gint id = 0;
	dbus_int32_t _tmp9_;
	gboolean result;
	DBusMessage* reply;
	dbus_bool_t _tmp10_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "i")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp9_);
	dbus_message_iter_next (&iter);
	id = _tmp9_;
	result = harrier_PipelineNull (self, id);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_tmp10_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp10_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_harrier_ElementSetPropertyBoolean (Harrier* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gint id = 0;
	dbus_int32_t _tmp11_;
	char* element = NULL;
	const char* _tmp12_;
	char* property = NULL;
	const char* _tmp13_;
	gboolean val = FALSE;
	dbus_bool_t _tmp14_;
	gboolean result;
	DBusMessage* reply;
	dbus_bool_t _tmp15_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "issb")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp11_);
	dbus_message_iter_next (&iter);
	id = _tmp11_;
	dbus_message_iter_get_basic (&iter, &_tmp12_);
	dbus_message_iter_next (&iter);
	element = g_strdup (_tmp12_);
	dbus_message_iter_get_basic (&iter, &_tmp13_);
	dbus_message_iter_next (&iter);
	property = g_strdup (_tmp13_);
	dbus_message_iter_get_basic (&iter, &_tmp14_);
	dbus_message_iter_next (&iter);
	val = _tmp14_;
	result = harrier_ElementSetPropertyBoolean (self, id, element, property, val);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (element);
	_g_free0 (property);
	_tmp15_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp15_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_harrier_ElementSetPropertyInt (Harrier* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gint id = 0;
	dbus_int32_t _tmp16_;
	char* element = NULL;
	const char* _tmp17_;
	char* property = NULL;
	const char* _tmp18_;
	gint val = 0;
	dbus_int32_t _tmp19_;
	gboolean result;
	DBusMessage* reply;
	dbus_bool_t _tmp20_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "issi")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp16_);
	dbus_message_iter_next (&iter);
	id = _tmp16_;
	dbus_message_iter_get_basic (&iter, &_tmp17_);
	dbus_message_iter_next (&iter);
	element = g_strdup (_tmp17_);
	dbus_message_iter_get_basic (&iter, &_tmp18_);
	dbus_message_iter_next (&iter);
	property = g_strdup (_tmp18_);
	dbus_message_iter_get_basic (&iter, &_tmp19_);
	dbus_message_iter_next (&iter);
	val = _tmp19_;
	result = harrier_ElementSetPropertyInt (self, id, element, property, val);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (element);
	_g_free0 (property);
	_tmp20_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp20_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_harrier_ElementSetPropertyLong (Harrier* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gint id = 0;
	dbus_int32_t _tmp21_;
	char* element = NULL;
	const char* _tmp22_;
	char* property = NULL;
	const char* _tmp23_;
	glong val = 0L;
	glong _tmp24_;
	DBusMessageIter _tmp25_;
	gboolean result;
	DBusMessage* reply;
	dbus_bool_t _tmp26_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "iss()")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp21_);
	dbus_message_iter_next (&iter);
	id = _tmp21_;
	dbus_message_iter_get_basic (&iter, &_tmp22_);
	dbus_message_iter_next (&iter);
	element = g_strdup (_tmp22_);
	dbus_message_iter_get_basic (&iter, &_tmp23_);
	dbus_message_iter_next (&iter);
	property = g_strdup (_tmp23_);
	dbus_message_iter_recurse (&iter, &_tmp25_);
	dbus_message_iter_next (&iter);
	val = _tmp24_;
	result = harrier_ElementSetPropertyLong (self, id, element, property, val);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (element);
	_g_free0 (property);
	_tmp26_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp26_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_harrier_ElementSetPropertyString (Harrier* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gint id = 0;
	dbus_int32_t _tmp27_;
	char* element = NULL;
	const char* _tmp28_;
	char* property = NULL;
	const char* _tmp29_;
	char* val = NULL;
	const char* _tmp30_;
	gboolean result;
	DBusMessage* reply;
	dbus_bool_t _tmp31_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "isss")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp27_);
	dbus_message_iter_next (&iter);
	id = _tmp27_;
	dbus_message_iter_get_basic (&iter, &_tmp28_);
	dbus_message_iter_next (&iter);
	element = g_strdup (_tmp28_);
	dbus_message_iter_get_basic (&iter, &_tmp29_);
	dbus_message_iter_next (&iter);
	property = g_strdup (_tmp29_);
	dbus_message_iter_get_basic (&iter, &_tmp30_);
	dbus_message_iter_next (&iter);
	val = g_strdup (_tmp30_);
	result = harrier_ElementSetPropertyString (self, id, element, property, val);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (element);
	_g_free0 (property);
	_g_free0 (val);
	_tmp31_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp31_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_harrier_ElementGetPropertyBoolean (Harrier* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gint id = 0;
	dbus_int32_t _tmp32_;
	char* element = NULL;
	const char* _tmp33_;
	char* property = NULL;
	const char* _tmp34_;
	gboolean result;
	DBusMessage* reply;
	dbus_bool_t _tmp35_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "iss")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp32_);
	dbus_message_iter_next (&iter);
	id = _tmp32_;
	dbus_message_iter_get_basic (&iter, &_tmp33_);
	dbus_message_iter_next (&iter);
	element = g_strdup (_tmp33_);
	dbus_message_iter_get_basic (&iter, &_tmp34_);
	dbus_message_iter_next (&iter);
	property = g_strdup (_tmp34_);
	result = harrier_ElementGetPropertyBoolean (self, id, element, property);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (element);
	_g_free0 (property);
	_tmp35_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp35_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_harrier_ElementGetPropertyInt (Harrier* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gint id = 0;
	dbus_int32_t _tmp36_;
	char* element = NULL;
	const char* _tmp37_;
	char* property = NULL;
	const char* _tmp38_;
	gint result;
	DBusMessage* reply;
	dbus_int32_t _tmp39_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "iss")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp36_);
	dbus_message_iter_next (&iter);
	id = _tmp36_;
	dbus_message_iter_get_basic (&iter, &_tmp37_);
	dbus_message_iter_next (&iter);
	element = g_strdup (_tmp37_);
	dbus_message_iter_get_basic (&iter, &_tmp38_);
	dbus_message_iter_next (&iter);
	property = g_strdup (_tmp38_);
	result = harrier_ElementGetPropertyInt (self, id, element, property);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (element);
	_g_free0 (property);
	_tmp39_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_INT32, &_tmp39_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_harrier_ElementGetPropertyLong (Harrier* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gint id = 0;
	dbus_int32_t _tmp40_;
	char* element = NULL;
	const char* _tmp41_;
	char* property = NULL;
	const char* _tmp42_;
	glong result;
	DBusMessage* reply;
	DBusMessageIter _tmp43_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "iss")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp40_);
	dbus_message_iter_next (&iter);
	id = _tmp40_;
	dbus_message_iter_get_basic (&iter, &_tmp41_);
	dbus_message_iter_next (&iter);
	element = g_strdup (_tmp41_);
	dbus_message_iter_get_basic (&iter, &_tmp42_);
	dbus_message_iter_next (&iter);
	property = g_strdup (_tmp42_);
	result = harrier_ElementGetPropertyLong (self, id, element, property);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (element);
	_g_free0 (property);
	dbus_message_iter_open_container (&iter, DBUS_TYPE_STRUCT, NULL, &_tmp43_);
	dbus_message_iter_close_container (&iter, &_tmp43_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_harrier_ElementGetPropertyString (Harrier* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gint id = 0;
	dbus_int32_t _tmp44_;
	char* element = NULL;
	const char* _tmp45_;
	char* property = NULL;
	const char* _tmp46_;
	char* result;
	DBusMessage* reply;
	const char* _tmp47_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "iss")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp44_);
	dbus_message_iter_next (&iter);
	id = _tmp44_;
	dbus_message_iter_get_basic (&iter, &_tmp45_);
	dbus_message_iter_next (&iter);
	element = g_strdup (_tmp45_);
	dbus_message_iter_get_basic (&iter, &_tmp46_);
	dbus_message_iter_next (&iter);
	property = g_strdup (_tmp46_);
	result = harrier_ElementGetPropertyString (self, id, element, property);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (element);
	_g_free0 (property);
	_tmp47_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &_tmp47_);
	_g_free0 (result);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_harrier_PipelineGetDuration (Harrier* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gint id = 0;
	dbus_int32_t _tmp48_;
	gint64 result;
	DBusMessage* reply;
	dbus_int64_t _tmp49_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "i")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp48_);
	dbus_message_iter_next (&iter);
	id = _tmp48_;
	result = harrier_PipelineGetDuration (self, id);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_tmp49_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_INT64, &_tmp49_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_harrier_PipelineGetPosition (Harrier* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	gint id = 0;
	dbus_int32_t _tmp50_;
	gint64 result;
	DBusMessage* reply;
	dbus_int64_t _tmp51_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "i")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp50_);
	dbus_message_iter_next (&iter);
	id = _tmp50_;
	result = harrier_PipelineGetPosition (self, id);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_tmp51_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_INT64, &_tmp51_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


DBusHandlerResult harrier_dbus_message (DBusConnection* connection, DBusMessage* message, void* object) {
	DBusHandlerResult result;
	result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Introspectable", "Introspect")) {
		result = _dbus_harrier_introspect (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Properties", "GetAll")) {
		result = _dbus_harrier_property_get_all (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ti.sdo.HarrierInterface", "PipelineCreate")) {
		result = _dbus_harrier_PipelineCreate (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ti.sdo.HarrierInterface", "PipelineDestroy")) {
		result = _dbus_harrier_PipelineDestroy (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ti.sdo.HarrierInterface", "PipelinePlay")) {
		result = _dbus_harrier_PipelinePlay (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ti.sdo.HarrierInterface", "PipelinePause")) {
		result = _dbus_harrier_PipelinePause (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ti.sdo.HarrierInterface", "PipelineNull")) {
		result = _dbus_harrier_PipelineNull (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ti.sdo.HarrierInterface", "ElementSetPropertyBoolean")) {
		result = _dbus_harrier_ElementSetPropertyBoolean (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ti.sdo.HarrierInterface", "ElementSetPropertyInt")) {
		result = _dbus_harrier_ElementSetPropertyInt (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ti.sdo.HarrierInterface", "ElementSetPropertyLong")) {
		result = _dbus_harrier_ElementSetPropertyLong (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ti.sdo.HarrierInterface", "ElementSetPropertyString")) {
		result = _dbus_harrier_ElementSetPropertyString (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ti.sdo.HarrierInterface", "ElementGetPropertyBoolean")) {
		result = _dbus_harrier_ElementGetPropertyBoolean (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ti.sdo.HarrierInterface", "ElementGetPropertyInt")) {
		result = _dbus_harrier_ElementGetPropertyInt (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ti.sdo.HarrierInterface", "ElementGetPropertyLong")) {
		result = _dbus_harrier_ElementGetPropertyLong (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ti.sdo.HarrierInterface", "ElementGetPropertyString")) {
		result = _dbus_harrier_ElementGetPropertyString (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ti.sdo.HarrierInterface", "PipelineGetDuration")) {
		result = _dbus_harrier_PipelineGetDuration (object, connection, message);
	} else if (dbus_message_is_method_call (message, "com.ti.sdo.HarrierInterface", "PipelineGetPosition")) {
		result = _dbus_harrier_PipelineGetPosition (object, connection, message);
	}
	if (result == DBUS_HANDLER_RESULT_HANDLED) {
		return result;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static void _dbus_harrier_eos (GObject* _sender, DBusConnection* _connection) {
	const char * _path;
	DBusMessage *_message;
	DBusMessageIter _iter;
	_path = g_object_get_data (_sender, "dbus_object_path");
	_message = dbus_message_new_signal (_path, "com.ti.sdo.HarrierInterface", "Eos");
	dbus_message_iter_init_append (_message, &_iter);
	dbus_connection_send (_connection, _message, NULL);
	dbus_message_unref (_message);
}


static void _dbus_harrier_state_changed (GObject* _sender, const char* new_state, DBusConnection* _connection) {
	const char * _path;
	DBusMessage *_message;
	DBusMessageIter _iter;
	const char* _tmp52_;
	_path = g_object_get_data (_sender, "dbus_object_path");
	_message = dbus_message_new_signal (_path, "com.ti.sdo.HarrierInterface", "StateChanged");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp52_ = new_state;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp52_);
	dbus_connection_send (_connection, _message, NULL);
	dbus_message_unref (_message);
}


static void _dbus_harrier_error (GObject* _sender, const char* err_message, DBusConnection* _connection) {
	const char * _path;
	DBusMessage *_message;
	DBusMessageIter _iter;
	const char* _tmp53_;
	_path = g_object_get_data (_sender, "dbus_object_path");
	_message = dbus_message_new_signal (_path, "com.ti.sdo.HarrierInterface", "Error");
	dbus_message_iter_init_append (_message, &_iter);
	_tmp53_ = err_message;
	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp53_);
	dbus_connection_send (_connection, _message, NULL);
	dbus_message_unref (_message);
}


void harrier_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
	if (!g_object_get_data (object, "dbus_object_path")) {
		g_object_set_data (object, "dbus_object_path", g_strdup (path));
		dbus_connection_register_object_path (connection, path, &_harrier_dbus_path_vtable, object);
		g_object_weak_ref (object, _vala_dbus_unregister_object, connection);
	}
	g_signal_connect (object, "eos", (GCallback) _dbus_harrier_eos, connection);
	g_signal_connect (object, "state-changed", (GCallback) _dbus_harrier_state_changed, connection);
	g_signal_connect (object, "error", (GCallback) _dbus_harrier_error, connection);
}


static void harrier_class_init (HarrierClass * klass) {
	harrier_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (HarrierPrivate));
	G_OBJECT_CLASS (klass)->finalize = harrier_finalize;
	g_signal_new ("eos", TYPE_HARRIER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("state_changed", TYPE_HARRIER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
	g_signal_new ("error", TYPE_HARRIER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
	g_type_set_qdata (TYPE_HARRIER, g_quark_from_static_string ("DBusObjectVTable"), (void*) (&_harrier_dbus_vtable));
}


static void harrier_instance_init (Harrier * self) {
	self->priv = HARRIER_GET_PRIVATE (self);
}


static void harrier_finalize (GObject* obj) {
	Harrier * self;
	self = HARRIER (obj);
	_g_hash_table_unref0 (self->priv->pipelines);
	self->priv->ids = (g_free (self->priv->ids), NULL);
	G_OBJECT_CLASS (harrier_parent_class)->finalize (obj);
}


GType harrier_get_type (void) {
	static GType harrier_type_id = 0;
	if (harrier_type_id == 0) {
		static const GTypeInfo g_define_type_info = { sizeof (HarrierClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) harrier_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Harrier), 0, (GInstanceInitFunc) harrier_instance_init, NULL };
		harrier_type_id = g_type_register_static (G_TYPE_OBJECT, "Harrier", &g_define_type_info, 0);
	}
	return harrier_type_id;
}


static void _vala_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
	const _DBusObjectVTable * vtable;
	vtable = g_type_get_qdata (G_TYPE_FROM_INSTANCE (object), g_quark_from_static_string ("DBusObjectVTable"));
	if (vtable) {
		vtable->register_object (connection, path, object);
	} else {
		g_warning ("Object does not implement any D-Bus interface");
	}
}


static void _vala_dbus_unregister_object (gpointer connection, GObject* object) {
	char* path;
	path = g_object_steal_data ((GObject*) object, "dbus_object_path");
	dbus_connection_unregister_object_path (connection, path);
	g_free (path);
}




