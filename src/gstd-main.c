/* gstd-main.c generated by valac 0.15.0, the Vala compiler
 * generated from gstd-main.vala, do not modify */

/*
 * gstd/src/main.vala
 *
 * Main function for GStreamer daemon - framework for controlling audio and video streaming using D-Bus messages
 *
 * Copyright (c) 2010, RidgeRun
 * All rights reserved.
 *
 * GPL2 license - See http://www.opensource.org/licenses/gpl-2.0.php for complete text.
 */
/*Global Variable*/

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <gst/gst.h>
#include <gio/gio.h>


#define GSTD_TYPE_FACTORY (gstd_factory_get_type ())
#define GSTD_FACTORY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSTD_TYPE_FACTORY, gstdFactory))
#define GSTD_FACTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GSTD_TYPE_FACTORY, gstdFactoryClass))
#define GSTD_IS_FACTORY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSTD_TYPE_FACTORY))
#define GSTD_IS_FACTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GSTD_TYPE_FACTORY))
#define GSTD_FACTORY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GSTD_TYPE_FACTORY, gstdFactoryClass))

typedef struct _gstdFactory gstdFactory;
typedef struct _gstdFactoryClass gstdFactoryClass;
typedef struct _Block1Data Block1Data;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_main_loop_unref0(var) ((var == NULL) ? NULL : (var = (g_main_loop_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_option_context_free0(var) ((var == NULL) ? NULL : (var = (g_option_context_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define GSTD_TYPE_SIGNALS (gstd_signals_get_type ())
#define GSTD_SIGNALS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSTD_TYPE_SIGNALS, gstdSignals))
#define GSTD_SIGNALS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GSTD_TYPE_SIGNALS, gstdSignalsClass))
#define GSTD_IS_SIGNALS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSTD_TYPE_SIGNALS))
#define GSTD_IS_SIGNALS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GSTD_TYPE_SIGNALS))
#define GSTD_SIGNALS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GSTD_TYPE_SIGNALS, gstdSignalsClass))

typedef struct _gstdSignals gstdSignals;
typedef struct _gstdSignalsClass gstdSignalsClass;

#define GSTD_TYPE_FACTORY_INTERFACE (gstd_factory_interface_get_type ())
#define GSTD_FACTORY_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSTD_TYPE_FACTORY_INTERFACE, gstdFactoryInterface))
#define GSTD_IS_FACTORY_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSTD_TYPE_FACTORY_INTERFACE))
#define GSTD_FACTORY_INTERFACE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GSTD_TYPE_FACTORY_INTERFACE, gstdFactoryInterfaceIface))

typedef struct _gstdFactoryInterface gstdFactoryInterface;
typedef struct _gstdFactoryInterfaceIface gstdFactoryInterfaceIface;

#define GSTD_TYPE_FACTORY_INTERFACE_PROXY (gstd_factory_interface_proxy_get_type ())

typedef enum  {
	ERROR_GSTD_OPTION,
	ERROR_GSTD_BUS,
	ERROR_GSTD_SERVICE_OWNERSHIP
} ErrorGstd;
#define ERROR_GSTD error_gstd_quark ()
struct _Block1Data {
	int _ref_count_;
	GMainLoop* loop;
	gstdFactory* factory;
};

struct _gstdFactoryInterfaceIface {
	GTypeInterface parent_iface;
	gchar* (*create) (gstdFactoryInterface* self, const gchar* description, GError** error);
	gboolean (*destroy) (gstdFactoryInterface* self, const gchar* path, GError** error);
	gboolean (*destroy_all) (gstdFactoryInterface* self, GError** error);
	gchar** (*list) (gstdFactoryInterface* self, int* result_length1, GError** error);
	gboolean (*ping) (gstdFactoryInterface* self, GError** error);
};


extern gboolean useSystemBus;
gboolean useSystemBus = FALSE;
extern gboolean useSessionBus;
gboolean useSessionBus = FALSE;
extern gchar* busName;
gchar* busName = NULL;
extern gboolean autoTerminate;
gboolean autoTerminate = FALSE;
extern gint debugLevel;
gint debugLevel = 0;
extern gint signalPollRate;
gint signalPollRate = 0;

GQuark error_gstd_quark (void);
gint _vala_main (gchar** args, int args_length1);
GType gstd_factory_get_type (void) G_GNUC_CONST;
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (Block1Data* _data1_);
GType gstd_signals_get_type (void) G_GNUC_CONST;
gstdSignals* gstd_signals_new (void);
gstdSignals* gstd_signals_construct (GType object_type);
gstdFactory* gstd_factory_new (GDBusConnection* conn);
gstdFactory* gstd_factory_construct (GType object_type, GDBusConnection* conn);
static void ____lambda2_ (Block1Data* _data1_);
static void _____lambda2__gstd_factory_last_pipe_destroyed (gstdFactory* _sender, gpointer self);
static void ___lambda3_ (Block1Data* _data1_, GDBusConnection* connection, const gchar* name);
GType gstd_factory_interface_proxy_get_type (void) G_GNUC_CONST;
guint gstd_factory_interface_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
GType gstd_factory_interface_get_type (void) G_GNUC_CONST;
static void ____lambda3__gbus_name_acquired_callback (GDBusConnection* connection, const gchar* name, gpointer self);
static void ___lambda4_ (Block1Data* _data1_, GDBusConnection* connection, const gchar* name);
static void ____lambda4__gbus_name_lost_callback (GDBusConnection* connection, const gchar* name, gpointer self);
void gstd_signals_monitor (gstdSignals* self, GMainLoop* loop, gstdFactoryInterface* factory, guint pollrate_ms);

const GOptionEntry options[6] = {{"system", '\0', 0, G_OPTION_ARG_NONE, &useSystemBus, "Use system bus", NULL}, {"session", '\0', 0, G_OPTION_ARG_NONE, &useSessionBus, "Use session bus", NULL}, {"busname", '\0', 0, G_OPTION_ARG_STRING, &busName, "Bus name, default is com.ridgerun.gstreamer.gstd", NULL}, {"autoterminate", '\0', 0, G_OPTION_ARG_NONE, &autoTerminate, "Automatically terminate gstd after the last pipe has been destroyed.", NULL}, {"debug", 'd', 0, G_OPTION_ARG_INT, &debugLevel, "Set debug level (0..3: error, warning, info, debug)", NULL}, {NULL}};

GQuark error_gstd_quark (void) {
	return g_quark_from_static_string ("error_gstd-quark");
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (Block1Data* _data1_) {
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		_g_object_unref0 (_data1_->factory);
		_g_main_loop_unref0 (_data1_->loop);
		g_slice_free (Block1Data, _data1_);
	}
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void ____lambda2_ (Block1Data* _data1_) {
	GMainLoop* _tmp0_;
	_tmp0_ = _data1_->loop;
	g_main_loop_quit (_tmp0_);
}


static void _____lambda2__gstd_factory_last_pipe_destroyed (gstdFactory* _sender, gpointer self) {
	____lambda2_ (self);
}


static void ___lambda3_ (Block1Data* _data1_, GDBusConnection* connection, const gchar* name) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (connection != NULL);
	g_return_if_fail (name != NULL);
	{
		GDBusConnection* _tmp0_;
		gstdFactory* _tmp1_;
		_tmp0_ = connection;
		_tmp1_ = _data1_->factory;
		gstd_factory_interface_register_object (GSTD_FACTORY_INTERFACE (_tmp1_), _tmp0_, "/com/ridgerun/gstreamer/gstd/factory", &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_IO_ERROR) {
				goto __catch2_g_io_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	goto __finally2;
	__catch2_g_io_error:
	{
		GError* e = NULL;
		GMainLoop* _tmp2_;
		e = _inner_error_;
		_inner_error_ = NULL;
		syslog (LOG_ERR, "Could not register service", NULL);
		_tmp2_ = _data1_->loop;
		g_main_loop_quit (_tmp2_);
		_g_error_free0 (e);
	}
	__finally2:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void ____lambda3__gbus_name_acquired_callback (GDBusConnection* connection, const gchar* name, gpointer self) {
	___lambda3_ (self, connection, name);
}


static void ___lambda4_ (Block1Data* _data1_, GDBusConnection* connection, const gchar* name) {
	GMainLoop* _tmp0_;
	g_return_if_fail (connection != NULL);
	g_return_if_fail (name != NULL);
	syslog (LOG_ERR, "Lost bus name", NULL);
	_tmp0_ = _data1_->loop;
	g_main_loop_quit (_tmp0_);
}


static void ____lambda4__gbus_name_lost_callback (GDBusConnection* connection, const gchar* name, gpointer self) {
	___lambda4_ (self, connection, name);
}


gint _vala_main (gchar** args, int args_length1) {
	gint result = 0;
	GError * _inner_error_ = NULL;
	{
		Block1Data* _data1_;
		gchar* _tmp0_;
		GOptionContext* _tmp1_;
		GOptionContext* opt;
		GOptionContext* _tmp2_;
		gint _tmp7_;
		gstdSignals* _tmp12_ = NULL;
		gint _tmp13_;
		gstdSignals* _tmp15_;
		gstdSignals* _tmp16_;
		gstdSignals* signal_processor;
		gboolean _tmp17_ = FALSE;
		gboolean _tmp18_;
		gboolean _tmp20_;
		GMainLoop* _tmp22_;
		GBusType _tmp23_ = 0;
		gboolean _tmp24_;
		GBusType _tmp28_;
		GDBusConnection* _tmp29_ = NULL;
		GDBusConnection* connection;
		GDBusConnection* _tmp30_;
		gstdFactory* _tmp31_;
		gboolean _tmp32_;
		GDBusConnection* _tmp34_;
		const gchar* _tmp35_;
		gstdSignals* _tmp36_;
		GMainLoop* _tmp41_;
		_data1_ = g_slice_new0 (Block1Data);
		_data1_->_ref_count_ = 1;
		openlog ("gstd", LOG_PID, LOG_USER);
		syslog (LOG_ERR, "Started", NULL);
		_tmp0_ = g_strdup ("com.ridgerun.gstreamer.gstd");
		_g_free0 (busName);
		busName = _tmp0_;
		_tmp1_ = g_option_context_new ("");
		opt = _tmp1_;
		_tmp2_ = opt;
		g_option_context_add_main_entries (_tmp2_, options, NULL);
		{
			GOptionContext* _tmp3_;
			_tmp3_ = opt;
			g_option_context_parse (_tmp3_, &args_length1, &args, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == G_OPTION_ERROR) {
					goto __catch1_g_option_error;
				}
				_g_option_context_free0 (opt);
				block1_data_unref (_data1_);
				_data1_ = NULL;
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return 0;
			}
		}
		goto __finally1;
		__catch1_g_option_error:
		{
			GError* e = NULL;
			GError* _tmp4_;
			const gchar* _tmp5_;
			GError* _tmp6_;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp4_ = e;
			_tmp5_ = _tmp4_->message;
			_tmp6_ = g_error_new (ERROR_GSTD, ERROR_GSTD_OPTION, "OptionError failure: %s", _tmp5_);
			_inner_error_ = _tmp6_;
			_g_error_free0 (e);
			goto __finally1;
		}
		__finally1:
		if (_inner_error_ != NULL) {
			_g_option_context_free0 (opt);
			block1_data_unref (_data1_);
			_data1_ = NULL;
			goto __catch0_g_error;
		}
		_tmp7_ = debugLevel;
		switch (_tmp7_) {
			case 0:
			{
				gint _tmp8_ = 0;
				_tmp8_ = LOG_UPTO (LOG_ERR);
				setlogmask (_tmp8_);
				break;
			}
			case 1:
			{
				gint _tmp9_ = 0;
				_tmp9_ = LOG_UPTO (LOG_WARNING);
				setlogmask (_tmp9_);
				break;
			}
			case 2:
			{
				gint _tmp10_ = 0;
				_tmp10_ = LOG_UPTO (LOG_INFO);
				setlogmask (_tmp10_);
				break;
			}
			default:
			{
				gint _tmp11_ = 0;
				_tmp11_ = LOG_UPTO (LOG_DEBUG);
				setlogmask (_tmp11_);
				break;
			}
		}
		syslog (LOG_DEBUG, "Debug logging enabled", NULL);
		_tmp13_ = signalPollRate;
		if (_tmp13_ > 0) {
			gstdSignals* _tmp14_;
			_tmp14_ = gstd_signals_new ();
			_g_object_unref0 (_tmp12_);
			_tmp12_ = _tmp14_;
		} else {
			_g_object_unref0 (_tmp12_);
			_tmp12_ = NULL;
		}
		_tmp15_ = _tmp12_;
		_tmp16_ = _g_object_ref0 (_tmp15_);
		signal_processor = _tmp16_;
		_tmp18_ = useSystemBus;
		if (_tmp18_) {
			gboolean _tmp19_;
			_tmp19_ = useSessionBus;
			_tmp17_ = _tmp19_;
		} else {
			_tmp17_ = FALSE;
		}
		_tmp20_ = _tmp17_;
		if (_tmp20_) {
			GError* _tmp21_;
			_tmp21_ = g_error_new_literal (ERROR_GSTD, ERROR_GSTD_BUS, "you have to choose: system or session bus");
			_inner_error_ = _tmp21_;
			_g_object_unref0 (signal_processor);
			_g_object_unref0 (_tmp12_);
			_g_option_context_free0 (opt);
			block1_data_unref (_data1_);
			_data1_ = NULL;
			goto __catch0_g_error;
		}
		gst_init (&args_length1, &args);
		_tmp22_ = g_main_loop_new (NULL, FALSE);
		_data1_->loop = _tmp22_;
		_tmp24_ = useSystemBus;
		if (_tmp24_) {
			_tmp23_ = G_BUS_TYPE_SYSTEM;
		} else {
			GBusType _tmp25_ = 0;
			gboolean _tmp26_;
			GBusType _tmp27_;
			_tmp26_ = useSessionBus;
			if (_tmp26_) {
				_tmp25_ = G_BUS_TYPE_SESSION;
			} else {
				_tmp25_ = G_BUS_TYPE_STARTER;
			}
			_tmp27_ = _tmp25_;
			_tmp23_ = _tmp27_;
		}
		_tmp28_ = _tmp23_;
		_tmp29_ = g_bus_get_sync (_tmp28_, NULL, &_inner_error_);
		connection = _tmp29_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (signal_processor);
			_g_object_unref0 (_tmp12_);
			_g_option_context_free0 (opt);
			block1_data_unref (_data1_);
			_data1_ = NULL;
			goto __catch0_g_error;
		}
		_tmp30_ = connection;
		_tmp31_ = gstd_factory_new (_tmp30_);
		_data1_->factory = _tmp31_;
		_tmp32_ = autoTerminate;
		if (_tmp32_) {
			gstdFactory* _tmp33_;
			_tmp33_ = _data1_->factory;
			g_signal_connect_data (_tmp33_, "last-pipe-destroyed", (GCallback) _____lambda2__gstd_factory_last_pipe_destroyed, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
		}
		_tmp34_ = connection;
		_tmp35_ = busName;
		g_bus_own_name_on_connection_with_closures (_tmp34_, _tmp35_, G_BUS_NAME_OWNER_FLAGS_NONE, (GClosure*) ((____lambda3__gbus_name_acquired_callback == NULL) ? NULL : g_cclosure_new ((GCallback) ____lambda3__gbus_name_acquired_callback, block1_data_ref (_data1_), block1_data_unref)), (GClosure*) ((____lambda4__gbus_name_lost_callback == NULL) ? NULL : g_cclosure_new ((GCallback) ____lambda4__gbus_name_lost_callback, block1_data_ref (_data1_), block1_data_unref)));
		_tmp36_ = signal_processor;
		if (_tmp36_ != NULL) {
			gstdSignals* _tmp37_;
			GMainLoop* _tmp38_;
			gstdFactory* _tmp39_;
			gint _tmp40_;
			_tmp37_ = signal_processor;
			_tmp38_ = _data1_->loop;
			_tmp39_ = _data1_->factory;
			_tmp40_ = signalPollRate;
			gstd_signals_monitor (_tmp37_, _tmp38_, (gstdFactoryInterface*) _tmp39_, (guint) _tmp40_);
		}
		_tmp41_ = _data1_->loop;
		g_main_loop_run (_tmp41_);
		_g_object_unref0 (connection);
		_g_object_unref0 (signal_processor);
		_g_object_unref0 (_tmp12_);
		_g_option_context_free0 (opt);
		block1_data_unref (_data1_);
		_data1_ = NULL;
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp42_;
		const gchar* _tmp43_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp42_ = e;
		_tmp43_ = _tmp42_->message;
		syslog (LOG_ERR, "Error: %s", _tmp43_, NULL);
		_g_error_free0 (e);
	}
	__finally0:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	syslog (LOG_ERR, "Ended", NULL);
	result = 0;
	return result;
}


int main (int argc, char ** argv) {
	g_thread_init (NULL);
	g_type_init ();
	return _vala_main (argv, argc);
}



